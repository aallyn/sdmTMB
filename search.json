[{"path":"https://pbs-assess.github.io/sdmTMB/articles/model-description.html","id":"other-vignettes-available","dir":"Articles","previous_headings":"","what":"Other vignettes available","title":"sdmTMB model description","text":"vignette viewed CRAN, note many vignettes describing use sdmTMB available documentation site Articles.","code":""},{"path":"https://pbs-assess.github.io/sdmTMB/articles/model-description.html","id":"notation-conventions","dir":"Articles","previous_headings":"","what":"Notation conventions","title":"sdmTMB model description","text":"appendix uses following notation conventions, generally follows guidance Edwards & Auger-Méthé (2019): Greek symbols parameters, Latin/Roman alphabet data (except \\(\\boldsymbol{Q}\\) \\(\\boldsymbol{H}\\), used convention), bold symbols vectors matrices (e.g., \\(\\boldsymbol{\\omega}\\) vector \\(\\omega_{\\boldsymbol{s}}\\) value \\(\\boldsymbol{\\omega}\\) point space \\(\\boldsymbol{s}\\)), \\(\\phi\\) distribution dispersion parameters consistency code, \\(\\mathbb{E}[y]\\) define expected value (mean) variable \\(y\\), \\(\\mathrm{Var}[y]\\) define expected variance variable \\(y\\), \\(^*\\) superscript represents interpolated projected values opposed values knot locations (e.g., \\(\\boldsymbol{\\omega}\\) vs. \\(\\boldsymbol{\\omega}^*\\)), possible, notation chosen match VAST (Thorson 2019) maintain consistency (e.g., \\(\\boldsymbol{\\omega}\\) spatial fields \\(\\boldsymbol{\\epsilon}_t\\) spatiotemporal fields). include tables major indices (Table 1) symbols (Table 2). Table 1: Subscript notation Table 2: Symbol notation, code representation (model output model template code), descriptions.","code":""},{"path":"https://pbs-assess.github.io/sdmTMB/articles/model-description.html","id":"sdmtmb-model-structure","dir":"Articles","previous_headings":"","what":"sdmTMB model structure","title":"sdmTMB model description","text":"complete sdmTMB model can written \\[ \\begin{aligned} \\mathbb{E}[y_{\\boldsymbol{s},t}] &= \\mu_{\\boldsymbol{s},t},\\\\ \\mu_{\\boldsymbol{s},t} &= f^{-1} \\left( \\boldsymbol{X}^{\\mathrm{main}}_{\\boldsymbol{s},t} \\boldsymbol{\\beta} + O_{\\boldsymbol{s},t} + \\alpha_g + \\boldsymbol{X}^{\\mathrm{tvc}}_{\\boldsymbol{s},t} \\boldsymbol{\\gamma_t} + \\boldsymbol{X}^{\\mathrm{svc}}_{\\boldsymbol{s},t} \\zeta_{\\boldsymbol{s}} + \\omega_{\\boldsymbol{s}} + \\epsilon_{\\boldsymbol{s},t} \\right), \\end{aligned} \\] \\(y_{\\boldsymbol{s},t}\\) represents response data point \\(\\boldsymbol{s}\\) time \\(t\\); \\(\\mu\\) represents mean; \\(f\\) represents link function (e.g., log logit) \\(f^{-1}\\) represents inverse; \\(\\boldsymbol{X}^{\\mathrm{main}}\\), \\(\\boldsymbol{X}^{\\mathrm{tvc}}\\), \\(\\boldsymbol{X}^{\\mathrm{svc}}\\) represent design matrices (superscript identifiers ‘main’ = main effects, ‘tvc’ = time varying coefficients, ‘svc’ = spatially varying coefficients); \\(\\boldsymbol{\\beta}\\) represents vector fixed-effect coefficients; \\(O_{\\boldsymbol{s},t}\\) represents offset: covariate (usually log transformed) coefficient fixed one; \\(\\alpha_{g}\\) represents random intercepts group \\(g\\), \\(\\alpha_{g}\\sim \\mathrm{N}(0,\\sigma^2_\\alpha)\\); \\(\\gamma_{t}\\) represents time-varying coefficients (random walk), \\(\\gamma_{t} \\sim \\mathrm{N}(\\gamma_{t-1},\\sigma^2_\\gamma)\\); \\(\\zeta_{\\boldsymbol{s}}\\) represents spatially varying coefficients (random field), \\(\\zeta_{\\boldsymbol{s}} \\sim \\mathrm{MVN}(\\boldsymbol{0},\\boldsymbol{\\Sigma}_\\zeta)\\); \\(\\omega_{\\boldsymbol{s}}\\) represents spatial component (random field), \\(\\omega_{\\boldsymbol{s}} \\sim \\mathrm{MVN}(\\boldsymbol{0},\\boldsymbol{\\Sigma}_\\omega)\\); \\(\\epsilon_{\\boldsymbol{s},t}\\) represents spatiotemporal component (random field), \\(\\epsilon_{\\boldsymbol{s},t} \\sim \\mathrm{MVN}(\\boldsymbol{0},\\boldsymbol{\\Sigma}_{\\epsilon})\\). single sdmTMB model rarely, ever, contain components. Next, split model describe various parts detail using ‘\\(\\ldots\\)’ represent optional components.","code":""},{"path":"https://pbs-assess.github.io/sdmTMB/articles/model-description.html","id":"main-effects","dir":"Articles","previous_headings":"sdmTMB model structure","what":"Main effects","title":"sdmTMB model description","text":"\\[ \\begin{aligned} \\mu_{\\boldsymbol{s},t} &= f^{-1} \\left( \\boldsymbol{X}^{\\mathrm{main}}_{\\boldsymbol{s},t} \\boldsymbol{\\beta} \\ldots \\right) \\end{aligned} \\] Within sdmTMB(), \\(\\boldsymbol{X}^{\\mathrm{main}}_{\\boldsymbol{s},t} \\boldsymbol{\\beta}\\) defined formula argument represents main-effect model matrix corresponding vector coefficients. main effect formula can contain optional penalized smoothers non-linear functions defined .","code":""},{"path":"https://pbs-assess.github.io/sdmTMB/articles/model-description.html","id":"smoothers","dir":"Articles","previous_headings":"sdmTMB model structure > Main effects","what":"Smoothers","title":"sdmTMB model description","text":"Smoothers sdmTMB implemented formula syntax familiar mgcv (Wood 2017) users fitting GAMs (generalized additive models). Smooths implemented formula using + s(x), implements smooth mgcv::s(). Within smooths, syntax commonly used mgcv::s() can applied, e.g. 2-dimensional smooths may constructed + s(x, y); smooths can specific various factor levels, + s(x, = group); smooths can vary according continuous variable, + s(x, = x2); basis function dimensions may specified, e.g. + s(x, k = 4) (see ?mgcv::choose.k); various types splines may constructed cyclic splines model seasonality, e.g. + s(month, bs = \"cc\", k = 12). mgcv can fit unpenalized (e.g., B-splines) penalized splines (P-splines), sdmTMB implements penalized splines. penalized splines constructed sdmTMB using function mgcv::smooth2random(), transforms splines random effects (associated design matrices) estimable mixed-effects modelling framework. approach implemented R packages gamm4 (Wood & Scheipl 2020) brms (Bürkner 2017).","code":""},{"path":"https://pbs-assess.github.io/sdmTMB/articles/model-description.html","id":"linear-break-point-threshold-models","dir":"Articles","previous_headings":"sdmTMB model structure > Main effects","what":"Linear break-point threshold models","title":"sdmTMB model description","text":"linear break-point “hockey stick” model can used describe threshold asymptotic responses. function consists two pieces, \\(x < b_{1}\\), \\(s(x) = x \\cdot b_{0}\\), \\(x > b_{1}\\), \\(s(x) = b_{1} \\cdot b_{0}\\). cases, \\(b_{0}\\) represents slope function threshold, product \\(b_{1} \\cdot b_{0}\\) represents value asymptote. constraints placed parameters \\(b_{0}\\) \\(b_{1}\\). models can fit including + breakpt(x) model formula, x covariate. formula can contain single break-point covariate.","code":""},{"path":"https://pbs-assess.github.io/sdmTMB/articles/model-description.html","id":"logistic-threshold-models","dir":"Articles","previous_headings":"sdmTMB model structure > Main effects","what":"Logistic threshold models","title":"sdmTMB model description","text":"Models logistic threshold relationships predictor response can fit form \\[ s(x)=\\tau + \\psi\\ { \\left[ 1+{ e }^{ -\\ln \\left(19\\right) \\cdot \\left( x-s50 \\right)      / \\left(s95 - s50 \\right) } \\right] }^{-1}, \\] \\(s\\) represents logistic function, \\(\\psi\\) scaling parameter (controlling height y-axis response; unconstrained), \\(\\tau\\) intercept, \\(s50\\) parameter controlling point function reaches 50% maximum (\\(\\psi\\)), \\(s95\\) parameter controlling point function reaches 95% maximum. parameter \\(s50\\) unconstrained \\(s95\\) constrained larger \\(s50\\). models can fit including + logistic(x) model formula, x covariate. formula can contain single logistic covariate.","code":""},{"path":"https://pbs-assess.github.io/sdmTMB/articles/model-description.html","id":"spatial-random-fields","dir":"Articles","previous_headings":"sdmTMB model structure","what":"Spatial random fields","title":"sdmTMB model description","text":"Spatial random fields, \\(\\omega_{\\boldsymbol{s}}\\), included spatial = '' (TRUE) omitted spatial = '' (FALSE). \\[ \\begin{aligned} \\mu_{\\boldsymbol{s},t} &= f^{-1} \\left( \\ldots + \\omega_{\\boldsymbol{s}} + \\ldots \\right),\\\\ \\boldsymbol{\\omega} &\\sim \\operatorname{MVNormal} \\left( \\boldsymbol{0}, \\boldsymbol{\\Sigma}_\\omega \\right),\\\\ \\end{aligned} \\] marginal standard deviation \\(\\boldsymbol{\\omega}\\) indicated Spatial SD printed model output sigma_O output sdmTMB::tidy(fit, \"ran_pars\"). ‘O’ ‘omega’ (\\(\\omega\\)). Internally, random fields follow Gaussian Markov random field (GMRF) \\[ \\boldsymbol{\\omega} \\sim \\mathrm{MVNormal}\\left(\\boldsymbol{0}, \\sigma_\\omega^2 \\boldsymbol{Q}^{-1}_\\omega\\right), \\] \\(\\boldsymbol{Q}_\\omega\\) sparse precision matrix \\(\\sigma_\\omega^2\\) marginal variance.","code":""},{"path":"https://pbs-assess.github.io/sdmTMB/articles/model-description.html","id":"spatiotemporal-random-fields","dir":"Articles","previous_headings":"sdmTMB model structure","what":"Spatiotemporal random fields","title":"sdmTMB model description","text":"Spatiotemporal random fields included default multiple time elements (time argument NULL) can set IID (independent identically distributed, 'iid'; default), AR(1) ('ar1'), random walk ('rw'), ('') via spatiotemporal argument. text values case insensitive. Spatiotemporal random fields represented \\(\\boldsymbol{\\epsilon}_t\\) within sdmTMB. chosen match representation VAST (Thorson 2019). marginal standard deviation \\(\\boldsymbol{\\epsilon}_t\\) indicated Spatiotemporal SD printed model output sigma_E output sdmTMB::tidy(fit, \"ran_pars\"). ‘E’ ‘epsilon’ (\\(\\epsilon\\)).","code":""},{"path":"https://pbs-assess.github.io/sdmTMB/articles/model-description.html","id":"iid-spatiotemporal-random-fields","dir":"Articles","previous_headings":"sdmTMB model structure > Spatiotemporal random fields","what":"IID spatiotemporal random fields","title":"sdmTMB model description","text":"IID spatiotemporal random fields (spatiotemporal = 'iid') can represented \\[ \\begin{aligned} \\mu_{\\boldsymbol{s},t} &= f^{-1} \\left( \\ldots + \\epsilon_{\\boldsymbol{s},t} + \\ldots \\right),\\\\ \\boldsymbol{\\epsilon_{t}} &\\sim \\operatorname{MVNormal} \\left( \\boldsymbol{0}, \\boldsymbol{\\Sigma}_{\\epsilon} \\right). \\end{aligned} \\] \\(\\epsilon_{\\boldsymbol{s},t}\\) represent random field deviations point \\(\\boldsymbol{s}\\) time \\(t\\). random fields assumed independent across time steps. Similarly spatial random fields, spatiotemporal random fields (including versions described ) parameterized internally sparse precision matrix (\\(\\boldsymbol{Q}_\\epsilon\\)) \\[ \\boldsymbol{\\epsilon_{t}} \\sim \\mathrm{MVNormal}\\left(\\boldsymbol{0}, \\sigma_\\epsilon^2 \\boldsymbol{Q}^{-1}_\\epsilon\\right). \\]","code":""},{"path":"https://pbs-assess.github.io/sdmTMB/articles/model-description.html","id":"ar1-spatiotemporal-random-fields","dir":"Articles","previous_headings":"sdmTMB model structure > Spatiotemporal random fields","what":"AR(1) spatiotemporal random fields","title":"sdmTMB model description","text":"First-order auto regressive, AR(1), spatiotemporal random fields (spatiotemporal = 'ar1') add parameter defining correlation random field deviations one time step next. defined \\[ \\begin{aligned} \\mu_{\\boldsymbol{s},t} &= f^{-1} \\left( \\ldots + \\delta_{\\boldsymbol{s},t} \\ldots \\right),\\\\ \\boldsymbol{\\delta}_{t=1} &\\sim \\operatorname{MVNormal} (\\boldsymbol{0}, \\boldsymbol{\\Sigma}_{\\epsilon}),\\\\ \\boldsymbol{\\delta}_{t>1} &= \\rho \\boldsymbol{\\delta}_{t-1} + \\sqrt{1 - \\rho^2} \\boldsymbol{\\epsilon_{t}},  \\: \\boldsymbol{\\epsilon_{t}} \\sim \\operatorname{MVNormal} \\left(\\boldsymbol{0}, \\boldsymbol{\\Sigma}_{\\epsilon} \\right), \\end{aligned} \\] \\(\\rho\\) correlation subsequent spatiotemporal random fields. \\(\\rho \\boldsymbol{\\delta}_{t-1} + \\sqrt{1 - \\rho^2}\\) term scales spatiotemporal variance correlation represents steady-state marginal variance. correlation \\(\\rho\\) allows mean-reverting spatiotemporal fields, constrained \\(-1 < \\rho < 1\\). Internally, parameter estimated ar1_phi, unconstrained. parameter ar1_phi transformed \\(\\rho\\) \\(\\rho = 2 \\left( \\mathrm{logit}^{-1}(\\texttt{ar1\\_phi}) - 1 \\right)\\).","code":""},{"path":"https://pbs-assess.github.io/sdmTMB/articles/model-description.html","id":"random-walk-spatiotemporal-random-fields-rw","dir":"Articles","previous_headings":"sdmTMB model structure > Spatiotemporal random fields","what":"Random walk spatiotemporal random fields (RW)","title":"sdmTMB model description","text":"Random walk spatiotemporal random fields (spatiotemporal = 'rw') represent model difference spatiotemporal deviations one time step next IID. defined \\[ \\begin{aligned} \\mu_{\\boldsymbol{s},t} &= f^{-1} \\left( \\ldots + \\delta_{\\boldsymbol{s},t} + \\ldots \\right),\\\\ \\boldsymbol{\\delta}_{t=1} &\\sim \\operatorname{MVNormal} (\\boldsymbol{0}, \\boldsymbol{\\Sigma}_{\\epsilon}),\\\\ \\boldsymbol{\\delta}_{t>1} &= \\boldsymbol{\\delta}_{t-1} +  \\boldsymbol{\\epsilon_{t-1}},  \\: \\boldsymbol{\\epsilon_{t-1}} \\sim \\operatorname{MVNormal} \\left(\\boldsymbol{0}, \\boldsymbol{\\Sigma}_{\\epsilon} \\right), \\end{aligned} \\] distribution spatiotemporal field initial time step AR(1) model, absence \\(\\rho\\) parameter allows spatiotemporal field non-stationary time. Note , contrast AR(1) parametrization, variance longer steady-state marginal variance.","code":""},{"path":"https://pbs-assess.github.io/sdmTMB/articles/model-description.html","id":"time-varying-regression-parameters","dir":"Articles","previous_headings":"sdmTMB model structure","what":"Time-varying regression parameters","title":"sdmTMB model description","text":"Parameters can modelled time varying (random walk) according form \\[ \\begin{aligned}   \\mu_{\\boldsymbol{s},t} &= f^{-1} \\left( \\ldots +  \\boldsymbol{X}^{\\mathrm{tvc}}_{\\boldsymbol{s},t} \\boldsymbol{\\gamma_{t}} + \\ldots \\right),\\\\   \\gamma_{t=1} &\\sim \\operatorname{Uniform} \\left(-\\infty, \\infty \\right),\\\\   \\gamma_{t>1} &\\sim \\operatorname{Normal} \\left(\\gamma_{t-1}, \\sigma^2_{\\gamma} \\right), \\end{aligned} \\] \\(\\boldsymbol{\\gamma_t}\\) optional vector time-varying regression parameters \\(\\boldsymbol{X}^{\\mathrm{tvc}}_{\\boldsymbol{s},t}\\) corresponding model matrix covariate values. defined via time_varying argument, assuming time argument also supplied column name. example, time_varying ~ 0 + x. first value given implicit uniform prior. .e., variable appear fixed effect formula since initial value estimated part time-varying formula. formula time_varying = ~ 1 implicitly represents time-varying intercept , case, intercept omitted main effects (formula ~ + 0 + ... formula ~ -1 + ...).","code":""},{"path":"https://pbs-assess.github.io/sdmTMB/articles/model-description.html","id":"spatially-varying-coefficients-svc","dir":"Articles","previous_headings":"sdmTMB model structure","what":"Spatially varying coefficients (SVC)","title":"sdmTMB model description","text":"Spatially varying coefficient models defined \\[ \\begin{aligned}   \\mu_{\\boldsymbol{s},t} &= f^{-1} \\left( \\ldots + \\boldsymbol{X}^{\\mathrm{svc}}_{\\boldsymbol{s}, t} \\zeta_{\\boldsymbol{s}} + \\ldots \\right),\\\\   \\boldsymbol{\\zeta} &\\sim \\operatorname{MVNormal} \\left( \\boldsymbol{0}, \\boldsymbol{\\Sigma}_\\zeta \\right), \\end{aligned} \\] \\(\\boldsymbol{\\zeta}\\) random field representing spatially varying coefficient. Usually, \\(\\boldsymbol{X}^{\\mathrm{svc}}_{\\boldsymbol{s}, t}\\) represent prediction matrix constant spatially given time \\(t\\) defined one-sided formula supplied spatial_varying. example spatial_varying = ~ 0 + x, 0 omits intercept. random fields parameterized internally sparse precision matrix (\\(\\boldsymbol{Q}_\\zeta\\)) \\[ \\boldsymbol{\\zeta} \\sim \\mathrm{MVNormal}\\left(\\boldsymbol{0}, \\sigma_\\zeta^2 \\boldsymbol{Q}^{-1}_\\zeta\\right). \\]","code":""},{"path":"https://pbs-assess.github.io/sdmTMB/articles/model-description.html","id":"iid-random-or-multi-level-intercepts","dir":"Articles","previous_headings":"sdmTMB model structure","what":"IID random or multi-level intercepts","title":"sdmTMB model description","text":"Multilevel/hierchical intercepts defined \\[ \\begin{aligned}   \\mu_{\\boldsymbol{s},t} &= f^{-1} \\left( \\ldots + \\alpha_{g} + \\ldots \\right),\\\\   \\alpha_g &\\sim \\operatorname{Normal} \\left(0, \\sigma_\\alpha^2 \\right),\\\\ \\end{aligned} \\] \\(\\alpha_g\\) example optional “random” intercept—intercept mean zero varies level \\(g\\) constrained \\(\\sigma_\\alpha\\). defined formula argument via (1 | g) syntax lme4 glmmTMB. can multiple random intercepts, despite showing one . E.g., (1 | g1) + (1 | g2), case assumed independent uncorrelated .","code":""},{"path":"https://pbs-assess.github.io/sdmTMB/articles/model-description.html","id":"offset-terms","dir":"Articles","previous_headings":"sdmTMB model structure","what":"Offset terms","title":"sdmTMB model description","text":"Offset terms can included offset argument sdmTMB(). included linear predictor \\[ \\begin{aligned}   \\mu_{\\boldsymbol{s},t} &= f^{-1} \\left( \\ldots + O_{\\boldsymbol{s},t} + \\ldots \\right), \\end{aligned} \\] \\(O_{\\boldsymbol{s},t}\\) offset term—log transformed variable without coefficient (assuming log link). offset included prediction. Therefore, offset represents measure effort, example, prediction one unit effort (log(1) = 0).","code":""},{"path":"https://pbs-assess.github.io/sdmTMB/articles/model-description.html","id":"observation-model-families","dir":"Articles","previous_headings":"","what":"Observation model families","title":"sdmTMB model description","text":"describe main observation families available sdmTMB comment parametrization, statistical properties, utility, code representation sdmTMB.","code":""},{"path":"https://pbs-assess.github.io/sdmTMB/articles/model-description.html","id":"binomial","dir":"Articles","previous_headings":"Observation model families","what":"Binomial","title":"sdmTMB model description","text":"\\[ \\operatorname{Binomial} \\left(N, \\mu \\right) \\] \\(N\\) size number trials, \\(\\mu\\) probability success trial. \\(N = 1\\), distribution becomes Bernoulli distribution. Internally, distribution parameterized robust version TMB, numerically stable probabilities approach 0 1. Following structure stats::glm(), lme4, glmmTMB, binomial family can specified one 4 ways: response may factor (model classifies first level versus others) response may binomial (0/1) response can matrix form cbind(success, failure), response may observed proportions, weights argument used specify Binomial size (\\(N\\)) parameter (probabilty ~ ..., weights = N). Code defined within TMB. Example: family = binomial(link = \"logit\")","code":""},{"path":"https://pbs-assess.github.io/sdmTMB/articles/model-description.html","id":"beta","dir":"Articles","previous_headings":"Observation model families","what":"Beta","title":"sdmTMB model description","text":"\\[ \\operatorname{Beta} \\left(\\mu \\phi, (1 - \\mu) \\phi \\right) \\] \\(\\mu\\) mean \\(\\phi\\) precision parameter. parametrization follows Ferrari & Cribari-Neto (2004) betareg R package (Cribari-Neto & Zeileis 2010). variance \\(\\mu (1 - \\mu) / (\\phi + 1)\\). Code defined within TMB. Example: family = Beta(link = \"logit\")","code":""},{"path":"https://pbs-assess.github.io/sdmTMB/articles/model-description.html","id":"gamma","dir":"Articles","previous_headings":"Observation model families","what":"Gamma","title":"sdmTMB model description","text":"\\[ \\operatorname{Gamma} \\left( \\phi, \\frac{\\mu}{\\phi}  \\right) \\] \\(\\phi\\) represents Gamma shape \\(\\mu / \\phi\\) represents scale. mean \\(\\mu\\) variance \\(\\mu \\cdot \\phi^2\\). Code defined within TMB. Example: family = Gamma(link = \"log\")","code":""},{"path":"https://pbs-assess.github.io/sdmTMB/articles/model-description.html","id":"gaussian","dir":"Articles","previous_headings":"Observation model families","what":"Gaussian","title":"sdmTMB model description","text":"\\[ \\operatorname{Normal} \\left( \\mu, \\phi^2 \\right) \\] \\(\\mu\\) mean \\(\\phi\\) standard deviation. variance \\(\\phi^2\\). Example: family = Gaussian(link = \"identity\") Code defined within TMB.","code":""},{"path":"https://pbs-assess.github.io/sdmTMB/articles/model-description.html","id":"lognormal","dir":"Articles","previous_headings":"Observation model families","what":"Lognormal","title":"sdmTMB model description","text":"sdmTMB uses bias-corrected lognormal distribution \\(\\phi\\) represents standard deviation log-space: \\[ \\operatorname{Lognormal} \\left( \\log \\mu - \\frac{\\phi^2}{2}, \\phi^2 \\right). \\] bias correction, \\(\\mathbb{E}[y] = \\mu\\) \\(\\mathrm{Var}[\\log y] = \\phi^2\\). Code defined within sdmTMB based TMB dnorm() normal density. Example: family = lognormal(link = \"log\")","code":""},{"path":"https://pbs-assess.github.io/sdmTMB/articles/model-description.html","id":"negative-binomial-1-nb1","dir":"Articles","previous_headings":"Observation model families","what":"Negative Binomial 1 (NB1)","title":"sdmTMB model description","text":"\\[ \\operatorname{NB1} \\left( \\mu, \\phi \\right) \\] \\(\\mu\\) mean \\(\\phi\\) dispersion parameter. variance scales linearly mean \\(\\mathrm{Var}[y] = \\mu + \\mu / \\phi\\) (Hilbe 2011). Internally, distribution parameterized robust version TMB. Code defined within sdmTMB based NB2 borrowed glmmTMB. Example: family = nbinom1(link = \"log\")","code":""},{"path":"https://pbs-assess.github.io/sdmTMB/articles/model-description.html","id":"negative-binomial-2-nb2","dir":"Articles","previous_headings":"Observation model families","what":"Negative Binomial 2 (NB2)","title":"sdmTMB model description","text":"\\[ \\operatorname{NB2} \\left( \\mu, \\phi \\right) \\] \\(\\mu\\) mean \\(\\phi\\) dispersion parameter. variance scales quadratically mean \\(\\mathrm{Var}[y] = \\mu + \\mu^2 / \\phi\\) (Hilbe 2011). NB2 parametrization commonly seen ecology NB1. Internally, distribution parameterized robust version TMB. Code defined within TMB. Example: family = nbinom2(link = \"log\")","code":""},{"path":"https://pbs-assess.github.io/sdmTMB/articles/model-description.html","id":"poisson","dir":"Articles","previous_headings":"Observation model families","what":"Poisson","title":"sdmTMB model description","text":"\\[ \\operatorname{Poisson} \\left( \\mu \\right) \\] \\(\\mu\\) represents mean \\(\\mathrm{Var}[y] = \\mu\\). Code defined within TMB. Example: family = poisson(link = \"log\")","code":""},{"path":"https://pbs-assess.github.io/sdmTMB/articles/model-description.html","id":"student-t","dir":"Articles","previous_headings":"Observation model families","what":"Student-t","title":"sdmTMB model description","text":"\\[ \\operatorname{Student-t} \\left( \\mu, \\phi, \\nu \\right) \\] \\(\\nu\\), degrees freedom (df), user-supplied fixed parameter. Lower values \\(\\nu\\) result heavier tails compared Gaussian distribution. approximately df = 20, distribution becomes similar Gaussian. Student-t distribution low degrees freedom (e.g., \\(\\nu \\le 7\\)) can helpful modelling data otherwise suitable Gaussian needs approach robust outliers (e.g., Anderson et al. 2017). Code defined within sdmTMB based dt() distribution TMB. Example: family = student(link = \"log\", df = 7)","code":""},{"path":"https://pbs-assess.github.io/sdmTMB/articles/model-description.html","id":"tweedie","dir":"Articles","previous_headings":"Observation model families","what":"Tweedie","title":"sdmTMB model description","text":"\\[ \\operatorname{Tweedie} \\left(\\mu, p, \\phi \\right), \\: 1 < p < 2 \\] \\(\\mu\\) mean, \\(p\\) power parameter constrained 1 2, \\(\\phi\\) dispersion parameter. Tweedie distribution can helpful modelling data positive continuous also contain zeros. Internally, \\(p\\) transformed \\(\\mathrm{logit}^{-1} (\\texttt{thetaf}) + 1\\) constrain 1 2 estimated unconstrained variable. source code implemented cplm package (Zhang 2013) based Dunn & Smyth (2005). TMB version defined . Example: family = tweedie(link = \"log\")","code":""},{"path":"https://pbs-assess.github.io/sdmTMB/articles/model-description.html","id":"gamma-mixture","dir":"Articles","previous_headings":"Observation model families","what":"Gamma mixture","title":"sdmTMB model description","text":"2 component mixture extends Gamma distribution, \\[ (1 - p) \\cdot \\operatorname{Gamma} \\left( \\phi, \\frac{\\mu_{1}}{\\phi}  \\right) + p \\cdot \\operatorname{Gamma} \\left( \\phi, \\frac{\\mu_{2}}{\\phi}  \\right), \\] \\(\\phi\\) represents Gamma shape, \\(\\mu_{1} / \\phi\\) represents scale first (smaller component) distribution, \\(\\mu_{2} / \\phi\\) represents scale second (larger component) distribution, \\(p\\) controls contribution component mixture (also interpreted probability larger events). mean \\((1-p) \\cdot \\mu_{1} + p \\cdot \\mu_{2}\\) variance \\((1-p) ^ 2 \\cdot \\mu_{1} \\cdot \\phi^2 + (p) ^ 2 \\cdot \\mu_{2} \\cdot \\phi^2\\). Example: family = gamma_mix(link = \"log\"). See also family = delta_gamma_mix() extension incorporating distribution delta models.","code":""},{"path":"https://pbs-assess.github.io/sdmTMB/articles/model-description.html","id":"lognormal-mixture","dir":"Articles","previous_headings":"Observation model families","what":"Lognormal mixture","title":"sdmTMB model description","text":"2 component mixture extends lognormal distribution, \\[ (1 - p) \\cdot \\operatorname{Lognormal} \\left( \\log \\mu_{1} - \\frac{\\phi^2}{2}, \\phi^2 \\right) + p \\cdot \\operatorname{Lognormal} \\left( \\log \\mu_{2} - \\frac{\\phi^2}{2}, \\phi^2 \\right). \\] bias correction, \\(\\mathbb{E}[y] = (1-p) \\cdot \\mu_{1} + p \\cdot \\mu_{2}\\) \\(\\mathrm{Var}[\\log y] = (1-p)^2 \\cdot \\phi^2 + p^2 \\cdot \\phi^2\\). Gamma mixture, \\(p\\) controls contribution component mixture (also interpreted probability larger events). Example: family = lognormal_mix(link = \"log\"). See also family = delta_lognormal_mix() extension incorporating distribution delta models.","code":""},{"path":[]},{"path":"https://pbs-assess.github.io/sdmTMB/articles/model-description.html","id":"matérn-parameterization","dir":"Articles","previous_headings":"Gaussian random fields","what":"Matérn parameterization","title":"sdmTMB model description","text":"Matérn defines covariance \\(\\Phi \\left( s_j, s_k \\right)\\) spatial locations \\(s_j\\) \\(s_k\\) \\[ \\Phi\\left( s_j,s_k \\right) = \\tau^2/\\Gamma(\\nu)2^{\\nu - 1} (\\kappa d_{jk})^\\nu K_\\nu \\left( \\kappa d_{jk} \\right), \\] \\(\\tau^2\\) controls spatial variance, \\(\\nu\\) controls smoothness, \\(\\Gamma\\) represents Gamma function, \\(d_{jk}\\) represents distance locations \\(s_j\\) \\(s_k\\), \\(K_\\nu\\) represents modified Bessel function second kind, \\(\\kappa\\) represents decorrelation rate. parameter \\(\\nu\\) set 1 take advantage Stochastic Partial Differential Equation (SPDE) approximation GRF greatly increase computational efficiency (Lindgren et al. 2011). Internally, parameters \\(\\kappa\\) \\(\\tau\\) converted range marginal standard deviation \\(\\sigma\\) \\(\\textrm{range} = \\sqrt{8} / \\kappa\\) \\(\\sigma = 1 / \\sqrt{4 \\pi \\exp \\left(2 \\log(\\tau) + 2 \\log(\\kappa) \\right) }\\). case spatiotemporal model spatial spatiotemporal fields, share_range = TRUE sdmTMB() (default), single \\(\\kappa\\) range estimated separate \\(\\sigma_\\omega\\) \\(\\sigma_\\epsilon\\). often makes sense since data often weakly informative \\(\\kappa\\). share_range = FALSE, separate \\(\\kappa_\\omega\\) \\(\\kappa_\\epsilon\\) estimated. spatially varying coefficient field always shares \\(\\kappa\\) spatial random field.","code":""},{"path":"https://pbs-assess.github.io/sdmTMB/articles/model-description.html","id":"projection-boldsymbola-matrix","dir":"Articles","previous_headings":"Gaussian random fields","what":"Projection \\(\\boldsymbol{A}\\) matrix","title":"sdmTMB model description","text":"values spatial variables knots multiplied projection matrix \\(\\boldsymbol{}\\) bilinearly interpolates knot locations values locations observed predicted data (Lindgren & Rue 2015) \\[ \\boldsymbol{\\omega}^* = \\boldsymbol{} \\boldsymbol{\\omega}, \\] \\(\\boldsymbol{\\omega}^*\\) represents values spatial random fields observed locations predicted data locations. matrix \\(\\boldsymbol{}\\) row data point prediction point column knot. Three non-zero elements row define weight neighbouring 3 knot locations location \\(\\boldsymbol{s}\\). bilinear interpolation happens spatiotemporal random fields \\[ \\boldsymbol{\\epsilon}_t^* = \\boldsymbol{} \\boldsymbol{\\epsilon}_t. \\]","code":""},{"path":"https://pbs-assess.github.io/sdmTMB/articles/model-description.html","id":"anisotropy","dir":"Articles","previous_headings":"Gaussian random fields","what":"Anisotropy","title":"sdmTMB model description","text":"TMB allows anisotropy, spatial covariance may asymmetric respect latitude longitude (full details). Anisotropy can turned logical anisotropy argument sdmTMB(). number ways implement anisotropic covariance (Fuglstad et al. 2015), adopt 2-parameter rotation matrix \\(\\textbf{H}\\). elements \\(\\textbf{H}\\) defined parameter vector \\(\\boldsymbol{x}\\) \\(H_{1,1} = x_{1}\\), \\(H_{1,2} = H_{2,1} = x_{2}\\) \\(H_{2,2} = (1 + x_{2}^2) / x_{1}\\). model fitted sdmTMB(), anisotropy relationships may plotted using plot_anisotropy() function, takes fitted object argument. barrier mesh used, anisotropy disabled.","code":""},{"path":"https://pbs-assess.github.io/sdmTMB/articles/model-description.html","id":"incorporating-physical-barriers-into-the-spde","dir":"Articles","previous_headings":"Gaussian random fields","what":"Incorporating physical barriers into the SPDE","title":"sdmTMB model description","text":"cases spatial domain interest may complex bounded barrier land water (e.g., coastlines, islands, lakes). SPDE models allow physical barriers incorporated modelling (Bakka et al. 2019). sdmTMB() models, mesh construction occurs two steps: user (1) constructs mesh call sdmTMB::make_mesh(), (2) passes mesh sdmTMB::add_barrier_mesh(). barriers must constructed sf objects (Pebesma 2018) polygons defining barriers. See ?sdmTMB::add_barrier_mesh example. barrier implementation requires user select fraction value (range_fraction argument) defines fraction usual spatial range crossing barrier (Bakka et al. 2019). example, range estimated 10 km, range_fraction = 0.2 assume range 2 km across barrier. let spatial correlation decay 5 times faster distance. experimentation, values around 0.1 0.2 seem work well values much lower 0.1 can result convergence issues. website Francesco Serafini Haakon Bakka provides illustration INLA. implementation within TMB borrowed code written Olav Nikolai Breivik Hans Skaug TMB Case Studies Github site.","code":""},{"path":[]},{"path":"https://pbs-assess.github.io/sdmTMB/articles/model-description.html","id":"optimization-details","dir":"Articles","previous_headings":"Optimization","what":"Optimization details","title":"sdmTMB model description","text":"sdmTMB model fit maximum marginal likelihood. Internally, TMB (Kristensen et al. 2016) model template calculates marginal log likelihood gradient, negative log likelihood minimized via non-linear optimization routine stats::nlminb() R (Gay 1990; R Core Team 2021). Random effects estimated values maximize log likelihood conditional estimated fixed effects integrated via Laplace approximation (Kristensen et al. 2016). Like AD Model Builder (Fournier et al. 2012), TMB allows parameters fit phases include multiphase argument sdmTMB::sdmTMBcontrol() allow . high-dimensional models (many fixed random effects), phased estimation may faster result stable convergence. sdmTMB, phased estimation proceeds first estimating fixed-effect parameters contributing likelihood (holding random effects constant initial values). second phase, random-effect parameters (variances) also estimated. Fixed-effect parameters also estimated second phase initialized estimates first phase. cases, single call stats::nlminb() may result convergence (e.g., maximum gradient marginal likelihood respect fixed-effect parameters small enough yet), algorithm may need run multiple times. sdmTMB::sdmTMBcontrol() function, include argument nlminb_loops restart optimization previous best values. number nlminb_loops generally small (e.g., 2 3 initially), defaults 1. sdmTMB models, Hessian may also unstable need re-evaluated. optionally stats::optimHess() routine call stats::nlminb(). stats::optimHess() function implements Newton optimization routine find Hessian, include argument newton_loops sdmTMB::sdmTMBcontrol() allow multiple function evaluations (starting previous best value). default, included newton_loops set 0. model already fit, function sdmTMB::run_extra_optimization() can run additional optimization loops either routine reduce maximum gradient.","code":""},{"path":"https://pbs-assess.github.io/sdmTMB/articles/model-description.html","id":"assessing-convergence","dir":"Articles","previous_headings":"Optimization","what":"Assessing convergence","title":"sdmTMB model description","text":"Much guidance around diagnostics glmmTMB also applies sdmTMB, e.g. glmmTMB vignette troubleshooting. Optimization stats::nlminb() involves specifying number iterations evaluations (eval.max iter.max) tolerances (abs.tol, rel.tol, x.tol, xf.tol)—greater number iterations smaller tolerance thresholds increase chance optimal solution found, evaluations translates longer computation time. Warnings non-positive-definite Hessian matrices (accompanied parameters NAs standard errors) often mean models improperly specified given data. Standard errors can observed output print.sdmTMB() checking fit$sd_report. maximum gradient marginal likelihood respect fixed-effect parameters can checked inspecting (fit$gradients). Guidance varies, maximum gradient likely least \\(< 0.001\\) assuming fitting routine consistent convergence. maximum gradients already relatively small, can often reduced additional optimization calls beginning previous best parameter vector described sdmTMB::run_extra_optimization().","code":""},{"path":[]},{"path":"https://pbs-assess.github.io/sdmTMB/articles/web_only/basic-intro.html","id":"parameter-estimates","dir":"Articles > Web_only","previous_headings":"","what":"Parameter estimates","title":"Introduction to modelling with sdmTMB","text":"can view confidence intervals fixed effects using tidy function: similarly random effect variance parameters: Note standard errors reported coefficients log space, confidence intervals reported. parameters defined follows: range: derived parameter defines distance 2 points effectively independent (actually 13% correlated). share_range argument changed FALSE spatial spatiotemporal ranges unique, otherwise default share range. phi: Observation error scale parameter (e.g., SD Gaussian). sigma_O: SD spatial process (“Omega”). sigma_E: SD spatiotemporal process (“Epsilon”). tweedie_p: Tweedie p (power) parameter; 1 2. model used AR1 spatiotemporal fields : rho: Spatiotemporal correlation years; -1 1. model includes spatial_varying predictor : sigma_Z: SD spatially varying coefficient field (“Zeta”).","code":"tidy(m3, conf.int = TRUE) #> # A tibble: 3 × 5 #>   term                 estimate std.error conf.low conf.high #>   <chr>                   <dbl>     <dbl>    <dbl>     <dbl> #> 1 (Intercept)              1.86     0.208     1.45      2.26 #> 2 poly(log(depth), 2)1   -65.1      6.32    -77.5     -52.8  #> 3 poly(log(depth), 2)2   -96.5      5.98   -108.      -84.8 tidy(m3, \"ran_pars\", conf.int = TRUE) #> Standard errors intentionally omitted because they have been calculated in log #> space. #> # A tibble: 5 × 5 #>   term      estimate std.error conf.low conf.high #>   <chr>        <dbl> <lgl>        <dbl>     <dbl> #> 1 range        19.8  NA           14.6      26.7  #> 2 phi          11.0  NA           10.3      11.8  #> 3 sigma_O       1.40 NA            1.12      1.76 #> 4 sigma_E       1.55 NA            1.32      1.83 #> 5 tweedie_p     1.50 NA            1.48      1.52"},{"path":"https://pbs-assess.github.io/sdmTMB/articles/web_only/basic-intro.html","id":"model-diagnostics","dir":"Articles > Web_only","previous_headings":"","what":"Model diagnostics","title":"Introduction to modelling with sdmTMB","text":"can inspect randomized quantile residuals:   fast calculate can look ‘’ even model consistent data. MCMC-based residuals reliable slow. practice like want mcmc_iter mcmc_warmup. Total samples mcmc_iter - mcmc_warmup. also just use spatial model vignette builds quickly.  See ?residuals.sdmTMB().","code":"pcod$resids <- residuals(m3) # randomized quantile residuals qqnorm(pcod$resids) qqline(pcod$resids) ggplot(pcod, aes(X, Y, col = resids)) +   scale_colour_gradient2() +   geom_point() +   facet_wrap(~year) +   coord_fixed() r <- residuals(m3, \"mle-mcmc\", mcmc_warmup = 100, mcmc_iter = 101) #>  #> SAMPLING FOR MODEL 'tmb_generic' NOW (CHAIN 1). #> Chain 1:  #> Chain 1: Gradient evaluation took 0.01253 seconds #> Chain 1: 1000 transitions using 10 leapfrog steps per transition would take 125.3 seconds. #> Chain 1: Adjust your expectations accordingly! #> Chain 1:  #> Chain 1:  #> Chain 1: WARNING: There aren't enough warmup iterations to fit the #> Chain 1:          three stages of adaptation as currently configured. #> Chain 1:          Reducing each adaptation stage to 15%/75%/10% of #> Chain 1:          the given number of warmup iterations: #> Chain 1:            init_buffer = 15 #> Chain 1:            adapt_window = 75 #> Chain 1:            term_buffer = 10 #> Chain 1:  #> Chain 1: Iteration:   1 / 101 [  0%]  (Warmup) #> Chain 1: Iteration:  10 / 101 [  9%]  (Warmup) #> Chain 1: Iteration:  20 / 101 [ 19%]  (Warmup) #> Chain 1: Iteration:  30 / 101 [ 29%]  (Warmup) #> Chain 1: Iteration:  40 / 101 [ 39%]  (Warmup) #> Chain 1: Iteration:  50 / 101 [ 49%]  (Warmup) #> Chain 1: Iteration:  60 / 101 [ 59%]  (Warmup) #> Chain 1: Iteration:  70 / 101 [ 69%]  (Warmup) #> Chain 1: Iteration:  80 / 101 [ 79%]  (Warmup) #> Chain 1: Iteration:  90 / 101 [ 89%]  (Warmup) #> Chain 1: Iteration: 100 / 101 [ 99%]  (Warmup) #> Chain 1: Iteration: 101 / 101 [100%]  (Sampling) #> Chain 1:  #> Chain 1:  Elapsed Time: 27.6362 seconds (Warm-up) #> Chain 1:                0.236982 seconds (Sampling) #> Chain 1:                27.8732 seconds (Total) #> Chain 1: qqnorm(r) qqline(r)"},{"path":"https://pbs-assess.github.io/sdmTMB/articles/web_only/basic-intro.html","id":"spatial-predictions","dir":"Articles > Web_only","previous_headings":"","what":"Spatial predictions","title":"Introduction to modelling with sdmTMB","text":"Now, purposes example (e.g., visualization), want predict fine-scale grid entire survey domain. grid built package Queen Charlotte Sound named qcs_grid. prediction grid also needs covariates used model . Now make predictions new data: Let’s make small function help make maps. four kinds predictions get model. First, show predictions incorporate fixed effects random effects:  can also look just fixed effects, quadratic effect depth:  can look spatial random effects represent consistent deviations space time accounted fixed effects. words, deviations represent consistent biotic abiotic factors affecting biomass density accounted model.  finally can look spatiotemporal random effects represent deviation fixed effect predictions spatial random effect deviations. represent biotic abiotic factors changing time accounted model.  can also estimate uncertainty spatiotemporal density predictions using simulations joint precision matrix setting nsim > 0 predict function. generate 100 estimates use apply() calculate upper lower confidence intervals, standard deviation, coefficient variation (CV). Plot CV estimates:","code":"glimpse(qcs_grid) #> Rows: 65,826 #> Columns: 6 #> $ X             <dbl> 456, 458, 460, 462, 464, 466, 468, 470, 472, 474, 476, 4… #> $ Y             <dbl> 5636, 5636, 5636, 5636, 5636, 5636, 5636, 5636, 5636, 56… #> $ depth         <dbl> 347.08345, 223.33479, 203.74085, 183.29868, 182.99983, 1… #> $ depth_scaled  <dbl> 1.56081222, 0.56976987, 0.36336929, 0.12570465, 0.122036… #> $ depth_scaled2 <dbl> 2.436134789, 0.324637708, 0.132037240, 0.015801658, 0.01… #> $ year          <int> 2003, 2003, 2003, 2003, 2003, 2003, 2003, 2003, 2003, 20… predictions <- predict(m3, newdata = qcs_grid) plot_map <- function(dat, column) {   ggplot(dat, aes(X, Y, fill = {{ column }})) +     geom_raster() +     coord_fixed() } plot_map(predictions, exp(est)) +   scale_fill_viridis_c(     trans = \"sqrt\",     # trim extreme high values to make spatial variation more visible     na.value = \"yellow\", limits = c(0, quantile(exp(predictions$est), 0.995))   ) +   facet_wrap(~year) +   ggtitle(\"Prediction (fixed effects + all random effects)\",     subtitle = paste(\"maximum estimated biomass density =\", round(max(exp(predictions$est))))   ) plot_map(predictions, exp(est_non_rf)) +   scale_fill_viridis_c(trans = \"sqrt\") +   ggtitle(\"Prediction (fixed effects only)\") plot_map(predictions, omega_s) +   scale_fill_gradient2() +   ggtitle(\"Spatial random effects only\") plot_map(predictions, epsilon_st) +   scale_fill_gradient2() +   facet_wrap(~year) +   ggtitle(\"Spatiotemporal random effects only\") sim <- predict(m3, newdata = qcs_grid, nsim = 100) sim_last <- sim[qcs_grid$year == max(qcs_grid$year), ] # just plot last year pred_last <- predictions[predictions$year == max(qcs_grid$year), ] pred_last$lwr <- apply(exp(sim_last), 1, quantile, probs = 0.025) pred_last$upr <- apply(exp(sim_last), 1, quantile, probs = 0.975) pred_last$sd <- round(apply(exp(sim_last), 1, function(x) sd(x)), 2) pred_last$cv <- round(apply(exp(sim_last), 1, function(x) sd(x) / mean(x)), 2) ggplot(pred_last, aes(X, Y, fill = cv)) +   geom_raster() +   scale_fill_viridis_c()"},{"path":"https://pbs-assess.github.io/sdmTMB/articles/web_only/basic-intro.html","id":"conditional-effects","dir":"Articles > Web_only","previous_headings":"","what":"Conditional effects","title":"Introduction to modelling with sdmTMB","text":"can visualize conditional effect covariates feeding simplified data frames predict function fix covariate values want fixed (e.g., means) vary parameters want visualize (across range values):  also visreg package. version link space residuals partial randomized quantile residuals. See scale argument visreg response scale plots.  ggeffects package marginal effects plot. also faster since relies already estimated coefficients variance-covariance matrix.","code":"nd <- data.frame(   depth = seq(min(pcod$depth),     max(pcod$depth),     length.out = 100   ),   year = 2015L # a chosen year ) p <- predict(m3, newdata = nd, se_fit = TRUE, re_form = NA)  ggplot(p, aes(depth, exp(est),   ymin = exp(est - 1.96 * est_se),   ymax = exp(est + 1.96 * est_se) )) +   geom_line() +   geom_ribbon(alpha = 0.4) +   scale_x_continuous() +   coord_cartesian(expand = F) +   labs(x = \"Depth (m)\", y = \"Biomass density (kg/km2)\") visreg::visreg(m3, \"depth\") ggeffects::ggeffect(m3,  \"depth [0:500 by=1]\") %>% plot() #> Warning: Removed 1 row containing missing values (`geom_line()`)."},{"path":"https://pbs-assess.github.io/sdmTMB/articles/web_only/basic-intro.html","id":"time-varying-effects","dir":"Articles > Web_only","previous_headings":"Conditional effects","what":"Time-varying effects","title":"Introduction to modelling with sdmTMB","text":"also let effect depth vary time. example, helps give year separate mean effect (.factor(year)). ~ 0 part formula omits intercept. models like take longer fit, might want set silent = FALSE can monitor progress. plot , make data frame contains combinations time-varying covariate time. easily created using expand.grid() tidyr::expand_grid().","code":"m4 <- sdmTMB(   density ~ 0 + as.factor(year),   data = pcod,   time_varying = ~ 0 + depth_scaled + depth_scaled2,   mesh = mesh,   family = tweedie(link = \"log\"),   spatial = \"on\",   time = \"year\",   spatiotemporal = \"IID\" ) #> Detected irregular time spacing with an AR(1) or random walk process. #> Consider filling in the missing time slices with `extra_time`. #> `extra_time = c(2006, 2008, 2010, 2012, 2014, 2016)` m4 #> Spatiotemporal model fit by ML ['sdmTMB'] #> Formula: density ~ 0 + as.factor(year) #> Mesh: mesh (isotropic covariance) #> Time column: year #> Data: pcod #> Family: tweedie(link = 'log') #>   #>                     coef.est coef.se #> as.factor(year)2003     3.36    0.30 #> as.factor(year)2004     4.04    0.28 #> as.factor(year)2005     3.77    0.28 #> as.factor(year)2007     2.64    0.30 #> as.factor(year)2009     2.65    0.29 #> as.factor(year)2011     3.72    0.29 #> as.factor(year)2013     3.51    0.27 #> as.factor(year)2015     3.76    0.28 #> as.factor(year)2017     3.21    0.30 #>  #> Time-varying parameters: #>                    coef.est coef.se #> depth_scaled-2003     -0.96    0.08 #> depth_scaled-2004     -0.96    0.08 #> depth_scaled-2005     -0.96    0.08 #> depth_scaled-2007     -0.96    0.08 #> depth_scaled-2009     -0.96    0.08 #> depth_scaled-2011     -0.96    0.08 #> depth_scaled-2013     -0.96    0.08 #> depth_scaled-2015     -0.96    0.08 #> depth_scaled-2017     -0.96    0.08 #> depth_scaled2-2003    -1.50    0.23 #> depth_scaled2-2004    -1.70    0.17 #> depth_scaled2-2005    -1.68    0.22 #> depth_scaled2-2007    -1.82    0.28 #> depth_scaled2-2009    -0.99    0.17 #> depth_scaled2-2011    -2.02    0.25 #> depth_scaled2-2013    -1.09    0.12 #> depth_scaled2-2015    -1.80    0.22 #> depth_scaled2-2017    -2.10    0.26 #>  #> Dispersion parameter: 10.86 #> Tweedie p: 1.50 #> Matern range: 13.58 #> Spatial SD: 1.63 #> Spatiotemporal SD: 1.66 #> ML criterion at convergence: 6251.146 #>  #> See ?tidy.sdmTMB to extract these values as a data frame. AIC(m4) #> [1] 12534.29 nd <- expand.grid(   depth_scaled = seq(min(pcod$depth_scaled) + 0.2,     max(pcod$depth_scaled) - 0.2,     length.out = 50   ),   year = unique(pcod$year) # all years ) nd$depth_scaled2 <- nd$depth_scaled^2  p <- predict(m4, newdata = nd, se_fit = TRUE, re_form = NA)  ggplot(p, aes(depth_scaled, exp(est),   ymin = exp(est - 1.96 * est_se),   ymax = exp(est + 1.96 * est_se),   group = as.factor(year) )) +   geom_line(aes(colour = year), lwd = 1) +   geom_ribbon(aes(fill = year), alpha = 0.1) +   scale_colour_viridis_c() +   scale_fill_viridis_c() +   scale_x_continuous(labels = function(x) round(exp(x * pcod$depth_sd[1] + pcod$depth_mean[1]))) +   coord_cartesian(expand = F) +   labs(x = \"Depth (m)\", y = \"Biomass density (kg/km2)\") #> Warning: Using `size` aesthetic for lines was deprecated in ggplot2 3.4.0. #> ℹ Please use `linewidth` instead."},{"path":"https://pbs-assess.github.io/sdmTMB/articles/web_only/bayesian.html","id":"simulating-data","dir":"Articles > Web_only","previous_headings":"","what":"Simulating data","title":"Bayesian estimation with sdmTMB","text":"demonstrate using simulated dataset. Visualize simulated data:","code":"set.seed(123) predictor_dat <- data.frame(   X = runif(500), Y = runif(500),   a1 = rnorm(500) ) mesh <- make_mesh(predictor_dat, xy_cols = c(\"X\", \"Y\"), cutoff = 0.1) # plot(mesh) # mesh$mesh$n sim_dat <- sdmTMB_simulate(   formula = ~a1,   data = predictor_dat,   mesh = mesh,   family = gaussian(),   range = 0.3,   phi = 0.2,   sigma_O = 0.2,   seed = 123,   B = c(0.8, -0.4) # B0 = intercept, B1 = a1 slope ) ggplot(sim_dat, aes(X, Y, colour = observed)) +   geom_point() +   scale_color_viridis_c()"},{"path":"https://pbs-assess.github.io/sdmTMB/articles/web_only/bayesian.html","id":"fitting-the-model-with-marginal-likelihood","dir":"Articles > Web_only","previous_headings":"","what":"Fitting the model with marginal likelihood","title":"Bayesian estimation with sdmTMB","text":"First, fit spatial random field GLMM maximum likelihood:","code":"fit <- sdmTMB(   observed ~ a1,   data = sim_dat,   mesh = mesh,   family = gaussian(),   spatial = \"on\" ) fit #> Spatial model fit by ML ['sdmTMB'] #> Formula: observed ~ a1 #> Mesh: mesh (isotropic covariance) #> Data: sim_dat #> Family: gaussian(link = 'identity') #>   #>             coef.est coef.se #> (Intercept)      0.8    0.06 #> a1              -0.4    0.01 #>  #> Dispersion parameter: 0.20 #> Matern range: 0.32 #> Spatial SD: 0.17 #> ML criterion at convergence: -65.939 #>  #> See ?tidy.sdmTMB to extract these values as a data frame."},{"path":"https://pbs-assess.github.io/sdmTMB/articles/web_only/bayesian.html","id":"adding-priors","dir":"Articles > Web_only","previous_headings":"","what":"Adding priors","title":"Bayesian estimation with sdmTMB","text":"first model fit use priors. case, priors implied uniform internal parameter space. However, sdmTMB provides option applying priors. show example applying Normal(0, 5) (mean, SD) prior intercept Normal(0, 1) prior slope parameter. guess model matrix structure based formula, can verify looking internal model matrix previous fit (using do_fit = FALSE save time didn’t want fit first time). column corresponds order b priors:","code":"head(fit$tmb_data$X_ij[[1]]) #>   (Intercept)          a1 #> 1           1 -0.60189285 #> 2           1 -0.99369859 #> 3           1  1.02678506 #> 4           1  0.75106130 #> 5           1 -1.50916654 #> 6           1 -0.09514745 fit <- sdmTMB(   observed ~ a1,   data = sim_dat,   mesh = mesh,   family = gaussian(),   spatial = \"on\",   priors = sdmTMBpriors(     # location = vector of means; scale = vector of standard deviations:     b = normal(location = c(0, 0), scale = c(5, 2)),   ) ) fit #> Spatial model fit by ML ['sdmTMB'] #> Formula: observed ~ a1 #> Mesh: mesh (isotropic covariance) #> Data: sim_dat #> Family: gaussian(link = 'identity') #>   #>             coef.est coef.se #> (Intercept)      0.8    0.06 #> a1              -0.4    0.01 #>  #> Dispersion parameter: 0.20 #> Matern range: 0.32 #> Spatial SD: 0.17 #> ML criterion at convergence: -62.846 #>  #> See ?tidy.sdmTMB to extract these values as a data frame."},{"path":"https://pbs-assess.github.io/sdmTMB/articles/web_only/bayesian.html","id":"fixing-a-spatial-correlation-parameter-to-improve-convergence","dir":"Articles > Web_only","previous_headings":"","what":"Fixing a spatial correlation parameter to improve convergence","title":"Bayesian estimation with sdmTMB","text":"Sometimes spatial correlation parameters can challenging estimate Stan. One option apply penalized complexity (PC) priors sdmTMBpriors() Matérn parameters. Another option, can also used conjunction priors, fix one parameters maximum likelihood estimate (MLE) values. Frequently, fixing parameter ln_kappa can help convergence (e.g., Monnahan et al. 2021). estimated parameter transformed range estimate, controls rate spatial correlation decay. Now rebuild fitted object fixed (‘mapped’) ln_kappa parameters using update() function. ’ll use do_fit = FALSE avoid actually fitting updated model since ’s necessary.","code":"# grab the internal parameter list at estimated values: pars <- sdmTMB::get_pars(fit) # create a 'map' vector for TMB # factor NA values cause TMB to fix or map the parameter at the starting value: kappa_map <- factor(rep(NA, length(pars$ln_kappa)))  # rebuild model updating some elements: fit_mle <- update(   fit,   control = sdmTMBcontrol(     start = list(       ln_kappa = pars$ln_kappa #<     ),     map = list(       ln_kappa = kappa_map #<     )   ),   do_fit = FALSE #< ) #> ℹ Initiating `ln_kappa` at specified starting value(s) of: #> 2.173, 2.173 #> ℹ Fixing (mapping) `ln_kappa` at specified starting value(s) of: #> 2.173, 2.173"},{"path":"https://pbs-assess.github.io/sdmTMB/articles/web_only/bayesian.html","id":"passing-the-model-to-tmbstan","dir":"Articles > Web_only","previous_headings":"","what":"Passing the model to tmbstan","title":"Bayesian estimation with sdmTMB","text":"Now can pass $tmb_obj element model tmbstan::tmbstan(). using 1000 iterations 2 chains vignette builds quickly. practice, likely want use (e.g., 2000 iterations, 4 chains). Sometimes may need adjust sampler settings : See Details section ?rstan::stan. can also ‘thin’ samples via thin argument working model predictions becomes cumbersome given large number required samples. can look model: Rhat values look reasonable (< 1.05). n_eff (number effective samples) values mostly look reasonable (> 100) inference mean parameters except intercept (b_j[1]). Furthermore, can see correlation MCMC samples b_j[1]. try running iterations chains /placing priors parameters described (highly recommended). Now can use various functions visualize posterior:","code":"fit_stan <- tmbstan::tmbstan(   fit_mle$tmb_obj,   iter = 1000, chains = 2,   seed = 8217 # ensures repeatability ) tmbstan::tmbstan(   ...,   control = list(adapt_delta = 0.9, max_treedepth = 12) ) fit_stan #> Inference for Stan model: sdmTMB. #> 2 chains, each with iter=1000; warmup=500; thin=1;  #> post-warmup draws per chain=500, total post-warmup draws=1000. #>  #>               mean se_mean   sd   2.5%    25%    50%    75%  97.5% n_eff Rhat #> b_j[1]        0.79    0.01 0.06   0.67   0.76   0.80   0.84   0.90    85 1.05 #> b_j[2]       -0.40    0.00 0.01  -0.41  -0.40  -0.40  -0.39  -0.38  1604 1.00 #> ln_tau_O     -1.66    0.01 0.14  -1.92  -1.75  -1.67  -1.57  -1.38   272 1.00 #> ln_phi       -1.63    0.00 0.03  -1.69  -1.65  -1.63  -1.61  -1.57  1144 1.00 #> omega_s[1]   -0.08    0.01 0.09  -0.24  -0.14  -0.08  -0.02   0.10   203 1.02 #> omega_s[2]   -0.05    0.01 0.09  -0.22  -0.11  -0.05   0.00   0.12   177 1.02 #> omega_s[3]    0.03    0.01 0.09  -0.15  -0.03   0.03   0.09   0.20   173 1.02 #> omega_s[4]   -0.20    0.01 0.09  -0.38  -0.26  -0.20  -0.14  -0.02   212 1.01 #> omega_s[5]   -0.32    0.01 0.10  -0.53  -0.39  -0.33  -0.26  -0.12   238 1.01 #> omega_s[6]   -0.07    0.01 0.11  -0.26  -0.14  -0.06   0.01   0.14   302 1.00 #> omega_s[7]   -0.01    0.01 0.08  -0.17  -0.07  -0.02   0.04   0.15   180 1.02 #> omega_s[8]   -0.22    0.01 0.09  -0.39  -0.28  -0.22  -0.16  -0.05   176 1.02 #> omega_s[9]   -0.31    0.01 0.09  -0.47  -0.37  -0.31  -0.25  -0.14   169 1.02 #> omega_s[10]   0.29    0.01 0.09   0.13   0.23   0.29   0.34   0.47   156 1.03 #> omega_s[11]  -0.14    0.01 0.09  -0.31  -0.21  -0.14  -0.08   0.04   214 1.01 #> omega_s[12]   0.01    0.01 0.10  -0.19  -0.06   0.01   0.08   0.21   236 1.02 #> omega_s[13]   0.20    0.01 0.09   0.04   0.14   0.20   0.26   0.37   184 1.02 #> omega_s[14]  -0.08    0.01 0.10  -0.28  -0.14  -0.08  -0.02   0.11   199 1.02 #> omega_s[15]   0.23    0.01 0.08   0.06   0.18   0.23   0.28   0.38   188 1.02 #> omega_s[16]  -0.01    0.01 0.09  -0.19  -0.06  -0.01   0.06   0.17   189 1.01 #> omega_s[17]  -0.14    0.01 0.09  -0.33  -0.20  -0.14  -0.07   0.05   189 1.02 #> omega_s[18]  -0.27    0.01 0.10  -0.46  -0.34  -0.27  -0.21  -0.08   290 1.01 #> omega_s[19]   0.01    0.01 0.09  -0.17  -0.05   0.01   0.07   0.20   203 1.02 #> omega_s[20]   0.03    0.01 0.09  -0.13  -0.03   0.04   0.09   0.21   143 1.02 #> omega_s[21]   0.09    0.01 0.09  -0.08   0.02   0.09   0.15   0.27   161 1.02 #> omega_s[22]  -0.01    0.01 0.10  -0.21  -0.07  -0.01   0.06   0.20   190 1.02 #> omega_s[23]   0.13    0.01 0.09  -0.04   0.07   0.12   0.18   0.31   190 1.02 #> omega_s[24]   0.20    0.01 0.10   0.02   0.13   0.20   0.27   0.41   237 1.02 #> omega_s[25]   0.08    0.01 0.09  -0.07   0.03   0.08   0.14   0.25   182 1.02 #> omega_s[26]   0.00    0.01 0.10  -0.20  -0.07   0.00   0.07   0.20   242 1.01 #> omega_s[27]  -0.10    0.01 0.09  -0.28  -0.16  -0.10  -0.04   0.07   168 1.02 #> omega_s[28]   0.13    0.01 0.10  -0.06   0.06   0.12   0.19   0.32   233 1.01 #> omega_s[29]   0.31    0.01 0.09   0.15   0.25   0.30   0.36   0.49    69 1.03 #> omega_s[30]  -0.04    0.01 0.09  -0.20  -0.10  -0.04   0.02   0.14   217 1.02 #> omega_s[31]   0.10    0.01 0.08  -0.06   0.05   0.10   0.16   0.27   172 1.02 #> omega_s[32]   0.06    0.01 0.11  -0.16  -0.01   0.07   0.15   0.28   316 1.01 #> omega_s[33]   0.09    0.01 0.10  -0.11   0.02   0.09   0.15   0.29   222 1.02 #> omega_s[34]   0.05    0.01 0.09  -0.11  -0.01   0.05   0.11   0.23   267 1.01 #> omega_s[35]   0.08    0.01 0.09  -0.10   0.02   0.08   0.14   0.27   214 1.01 #> omega_s[36]   0.15    0.01 0.09  -0.03   0.09   0.15   0.21   0.34   175 1.02 #> omega_s[37]   0.17    0.01 0.11  -0.05   0.10   0.17   0.25   0.38   298 1.01 #> omega_s[38]   0.13    0.01 0.09  -0.07   0.07   0.13   0.19   0.31   210 1.01 #> omega_s[39]  -0.21    0.01 0.09  -0.39  -0.27  -0.21  -0.14  -0.02   224 1.01 #> omega_s[40]  -0.02    0.01 0.09  -0.19  -0.08  -0.01   0.04   0.16   203 1.01 #> omega_s[41]   0.20    0.01 0.09   0.04   0.14   0.19   0.25   0.38   184 1.02 #> omega_s[42]   0.21    0.01 0.09   0.05   0.15   0.21   0.27   0.40   184 1.01 #> omega_s[43]   0.16    0.01 0.10  -0.04   0.09   0.15   0.22   0.36   319 1.01 #> omega_s[44]   0.15    0.01 0.09  -0.03   0.09   0.14   0.21   0.32   235 1.01 #> omega_s[45]   0.10    0.01 0.10  -0.08   0.03   0.10   0.17   0.32   310 1.01 #> omega_s[46]   0.06    0.01 0.10  -0.13   0.00   0.06   0.13   0.27   261 1.01 #> omega_s[47]   0.32    0.01 0.09   0.16   0.26   0.32   0.37   0.51   223 1.01 #> omega_s[48]  -0.24    0.01 0.09  -0.42  -0.30  -0.23  -0.17  -0.06   142 1.02 #> omega_s[49]   0.11    0.01 0.10  -0.09   0.04   0.12   0.17   0.30   226 1.01 #> omega_s[50]  -0.08    0.01 0.09  -0.25  -0.13  -0.08  -0.02   0.10   186 1.02 #> omega_s[51]   0.25    0.01 0.11   0.05   0.18   0.25   0.32   0.46   241 1.01 #> omega_s[52]  -0.20    0.01 0.11  -0.41  -0.28  -0.20  -0.13   0.01   258 1.01 #> omega_s[53]   0.04    0.01 0.09  -0.14  -0.02   0.04   0.10   0.23   137 1.02 #> omega_s[54]   0.04    0.01 0.09  -0.14  -0.02   0.04   0.10   0.23   245 1.01 #> omega_s[55]  -0.07    0.01 0.12  -0.28  -0.16  -0.08   0.00   0.16   306 1.01 #> omega_s[56]  -0.41    0.01 0.11  -0.62  -0.48  -0.41  -0.34  -0.19   210 1.01 #> omega_s[57]   0.01    0.01 0.11  -0.21  -0.06   0.01   0.08   0.22   280 1.01 #> omega_s[58]  -0.20    0.01 0.10  -0.39  -0.27  -0.21  -0.14  -0.01   224 1.02 #> omega_s[59]   0.05    0.01 0.23  -0.44  -0.10   0.05   0.20   0.48   954 1.00 #> omega_s[60]  -0.20    0.01 0.26  -0.72  -0.37  -0.19  -0.05   0.31  1245 1.00 #> omega_s[61]  -0.24    0.01 0.24  -0.73  -0.39  -0.23  -0.08   0.23   701 1.00 #> omega_s[62]  -0.24    0.01 0.23  -0.69  -0.40  -0.24  -0.09   0.20   638 1.00 #> omega_s[63]  -0.25    0.01 0.23  -0.70  -0.41  -0.25  -0.10   0.18   591 1.00 #> omega_s[64]   0.09    0.01 0.23  -0.35  -0.07   0.09   0.24   0.55   950 1.00 #> omega_s[65]   0.18    0.01 0.23  -0.27   0.04   0.17   0.32   0.63   432 1.01 #> omega_s[66]   0.17    0.01 0.22  -0.26   0.03   0.16   0.30   0.61   456 1.01 #> omega_s[67]  -0.02    0.01 0.23  -0.44  -0.17  -0.02   0.14   0.42  1140 1.00 #> omega_s[68]  -0.01    0.01 0.26  -0.52  -0.18  -0.01   0.17   0.49   749 1.00 #> omega_s[69]   0.01    0.01 0.21  -0.40  -0.13   0.00   0.15   0.42   690 1.00 #> omega_s[70]   0.01    0.01 0.21  -0.37  -0.13   0.00   0.15   0.43   569 1.01 #> omega_s[71]   0.17    0.01 0.22  -0.26   0.02   0.17   0.32   0.59  1017 1.00 #> omega_s[72]  -0.11    0.01 0.23  -0.60  -0.26  -0.11   0.05   0.34   560 1.00 #> omega_s[73]  -0.14    0.01 0.22  -0.60  -0.29  -0.13   0.00   0.27   388 1.00 #> omega_s[74]  -0.14    0.01 0.21  -0.57  -0.27  -0.14   0.00   0.26   341 1.00 #> omega_s[75]  -0.37    0.01 0.22  -0.76  -0.52  -0.37  -0.23   0.04   556 1.00 #> omega_s[76]   0.10    0.01 0.18  -0.25  -0.03   0.10   0.22   0.47   767 1.00 #> omega_s[77]   0.09    0.01 0.21  -0.33  -0.03   0.09   0.23   0.48   832 1.00 #> omega_s[78]  -0.06    0.01 0.23  -0.49  -0.21  -0.05   0.10   0.38   921 1.00 #> omega_s[79]   0.06    0.01 0.15  -0.24  -0.05   0.05   0.16   0.36   453 1.00 #> omega_s[80]  -0.17    0.01 0.22  -0.56  -0.32  -0.17  -0.02   0.27   626 1.00 #> omega_s[81]  -0.06    0.01 0.20  -0.42  -0.19  -0.06   0.06   0.32   760 1.00 #> omega_s[82]  -0.13    0.01 0.20  -0.51  -0.26  -0.13   0.01   0.27   672 1.00 #> omega_s[83]  -0.02    0.01 0.23  -0.46  -0.17  -0.02   0.13   0.42   705 1.00 #> omega_s[84]   0.13    0.01 0.19  -0.23   0.00   0.12   0.26   0.52   554 1.00 #> omega_s[85]  -0.29    0.01 0.20  -0.69  -0.42  -0.29  -0.16   0.13  1236 1.00 #> lp__        136.88    0.65 9.70 117.30 131.03 136.71 143.60 154.86   221 1.00 #>  #> Samples were drawn using NUTS(diag_e) at Thu Jan 19 22:34:49 2023. #> For each parameter, n_eff is a crude measure of effective sample size, #> and Rhat is the potential scale reduction factor on split chains (at  #> convergence, Rhat=1). plot(fit_stan) #> 'pars' not specified. Showing first 10 parameters by default. #> ci_level: 0.8 (80% intervals) #> outer_level: 0.95 (95% intervals) pars_plot <- c(\"b_j[1]\", \"b_j[2]\", \"ln_tau_O\", \"omega_s[1]\")  bayesplot::mcmc_trace(fit_stan, pars = pars_plot) bayesplot::mcmc_pairs(fit_stan, pars = pars_plot)"},{"path":"https://pbs-assess.github.io/sdmTMB/articles/web_only/bayesian.html","id":"posterior-predictive-checks","dir":"Articles > Web_only","previous_headings":"","what":"Posterior predictive checks","title":"Bayesian estimation with sdmTMB","text":"can perform posterior predictive checks assess whether model can generate predictive data consistent observations. , can make use simulate.sdmTMB() passing Stan model. simulate.sdmTMB() take draws joint parameter posterior add observation error.  See ?bayesplot::pp_check. solid line represents density observed data light blue lines represent density 50 posterior predictive simulations. case, simulated data seem consistent observed data.","code":"set.seed(19292) s <- simulate(fit_mle, tmbstan_model = fit_stan, nsim = 50) bayesplot::pp_check(   sim_dat$observed,   yrep = t(s),   fun = bayesplot::ppc_dens_overlay )"},{"path":"https://pbs-assess.github.io/sdmTMB/articles/web_only/bayesian.html","id":"plotting-predictions","dir":"Articles > Web_only","previous_headings":"","what":"Plotting predictions","title":"Bayesian estimation with sdmTMB","text":"can make predictions Bayesian model supplying tmbstan_model argument predict.sdmTMB(). output matrix row corresponds row predicted data column corresponds sample. can summarize draws various ways visualize :   predict grid given value a1:","code":"pred <- predict(fit_mle, tmbstan_model = fit_stan) dim(pred) #> [1]  500 1000 sim_dat$post_mean <- apply(pred, 1, mean) sim_dat$post_sd <- apply(pred, 1, sd)  ggplot(sim_dat, aes(X, Y, colour = post_mean)) +   geom_point() +   scale_color_viridis_c() ggplot(sim_dat, aes(X, Y, colour = post_sd)) +   geom_point() +   scale_color_viridis_c() nd <- expand.grid(   X = seq(0, 1, length.out = 70),   Y = seq(0, 1, length.out = 70),   a1 = 0 ) pred <- predict(fit_mle, newdata = nd, tmbstan_model = fit_stan)  nd$post_mean <- apply(pred, 1, mean) nd$post_sd <- apply(pred, 1, sd)  ggplot(nd, aes(X, Y, fill = post_mean)) +   geom_raster() +   scale_fill_viridis_c() +   coord_fixed() ggplot(nd, aes(X, Y, fill = post_sd)) +   geom_raster() +   scale_fill_viridis_c() +   coord_fixed()"},{"path":"https://pbs-assess.github.io/sdmTMB/articles/web_only/bayesian.html","id":"extracting-parameter-posterior-samples","dir":"Articles > Web_only","previous_headings":"","what":"Extracting parameter posterior samples","title":"Bayesian estimation with sdmTMB","text":"can extract posterior samples rstan::extract(), result list element corresponds parameter set parameters:  example calculating derived parameter, calculate marginal spatial random field standard deviation:","code":"post <- rstan::extract(fit_stan) names(post) #> [1] \"b_j\"      \"ln_tau_O\" \"ln_phi\"   \"omega_s\"  \"lp__\" hist(post$b_j[, 1]) ln_kappa <- get_pars(fit_mle)$ln_kappa[1] # 2 elements since 2nd would be for spatiotemporal ln_tau_O <- post$ln_tau_O sigma_O <- 1 / sqrt(4 * pi * exp(2 * ln_tau_O + 2 * ln_kappa)) hist(sigma_O)"},{"path":"https://pbs-assess.github.io/sdmTMB/articles/web_only/bayesian.html","id":"extracting-the-posterior-of-other-predicted-elements","dir":"Articles > Web_only","previous_headings":"","what":"Extracting the posterior of other predicted elements","title":"Bayesian estimation with sdmTMB","text":"default predict.sdmTMB() returns overall prediction link space tmbstan model passed . instead want element might find usual data frame returned predict.sdmTMB() applied regular sdmTMB model, can specify sims_var argument. example, let’s extract spatial random field values \"omega_s\". options documented ?predict.sdmTMB().","code":"fit_pred <- predict(   fit_mle,   newdata = nd,   tmbstan_model = fit_stan,   sims_var = \"omega_s\" #< )  nd$spatial_rf_mean <- apply(fit_pred, 1, mean) nd$spatial_rf_sd <- apply(fit_pred, 1, sd)  ggplot(nd, aes(X, Y, fill = spatial_rf_mean)) +   geom_raster() +   scale_fill_gradient2() +   coord_fixed() ggplot(nd, aes(X, Y, fill = spatial_rf_sd)) +   geom_raster() +   scale_fill_viridis_c() +   coord_fixed()"},{"path":[]},{"path":"https://pbs-assess.github.io/sdmTMB/articles/web_only/cross-validation.html","id":"overview","dir":"Articles > Web_only","previous_headings":"","what":"Overview","title":"Cross-validation for model evaluation and comparison","text":"Cross-validation one best approaches can used quantify model performance compare sdmTMB models different structures (unlike AIC, approach also factor uncertainty random effects). Arguably challenging decision implementing cross-validation specify folds (fold representing subset data turn held used test set). Folds may vary number data partitioned, likely slightly different application. goals sdmTMB applications may focused spatial prediction; include making prediction new spatial regions (e.g. unsampled areas areas sampled every year). types models recommend exploring folds using blockCV spatialsample packages (Valavi et al. 2019; Silge 2021). general, spatial sampling approaches assign observations spatially autocorrelated fold. Accounting spatial correlation can lead better estimates covariate effects, well prediction errors. Alternatively, goals analysis sdmTMB may evaluate predictive accuracy model time (e.g. missing survey year, prediction future years). retrospective analyses, points within year may assigned fold (groups years fold). contrast, models forward looking use Leave Future Cross-Validation (LFOCV). LFOCV, data year \\(t\\) used predict observations \\(t+1\\), etc.","code":""},{"path":"https://pbs-assess.github.io/sdmTMB/articles/web_only/cross-validation.html","id":"cross-validation-in-sdmtmb","dir":"Articles > Web_only","previous_headings":"","what":"Cross validation in sdmTMB","title":"Cross-validation for model evaluation and comparison","text":"Cross validation sdmTMB implemented using sdmTMB_cv() function, k_folds argument specifying number folds (defaults 8). function uses parallelization default future::plan() set, can turned parallel argument. example, folds assigned randomly—can modified specific spatial temporal applications. Without getting complexities blockCV spatialsample packages, simply use kmeans generate spatial clusters, e.g. similarly, clusters assigned time—, year unique fold. Note year included factor spatiotemporal fields turned estimated missing years.","code":"data(pcod) mesh <- make_mesh(pcod, c(\"X\", \"Y\"), cutoff = 25) pcod$fyear <- as.factor(pcod$year) # Set parallel processing if desired: # library(future) # plan(multisession) m_cv <- sdmTMB_cv(   density ~ 0 + s(depth_scaled) + fyear,   data = pcod,   mesh = mesh,   family = tweedie(link = \"log\"),   k_folds = 4 ) clust <- kmeans(pcod[, c(\"X\", \"Y\")], 20)$cluster  m_cv <- sdmTMB_cv(   density ~ 0 + s(depth_scaled) + fyear,   data = pcod,   mesh = mesh,   fold_ids = clust,   family = tweedie(link = \"log\"),   k_folds = length(unique(clust)) ) clust <- as.numeric(as.factor(pcod$year))  m_cv <- sdmTMB_cv(   density ~ 0 + s(depth_scaled),   data = pcod,   mesh = mesh,   fold_ids = clust,   spatiotemporal = \"off\",   family = tweedie(link = \"log\"),   k_folds = length(unique(clust)) )"},{"path":"https://pbs-assess.github.io/sdmTMB/articles/web_only/cross-validation.html","id":"measuring-model-performance","dir":"Articles > Web_only","previous_headings":"","what":"Measuring model performance","title":"Cross-validation for model evaluation and comparison","text":"Lots measures predictive accuracy can used evaluate model performance. default, sdmTMB_cv() returns list contains 2 measures: log likelihoods fold (total), expected log predictive density fold (total). latter (ELPD) measure predictive ability model new observations, log-likelihood hold data corresponds density particular observations. can accessed , inspecting quantities across folds may help elucidate whether particular folds difficult predict.","code":"m_cv <- sdmTMB_cv(   density ~ 0 + s(depth_scaled) + fyear,   data = pcod,   mesh = mesh,   family = tweedie(link = \"log\"),   k_folds = 4 )  m_cv$fold_elpd # fold ELPD m_cv$elpd # total ELPD  m_cv$fold_loglik # fold log-likelihood m_cv$sum_loglik # total log-likelihood"},{"path":"https://pbs-assess.github.io/sdmTMB/articles/web_only/cross-validation.html","id":"single-splits-and-leave-future-out-cross-validation","dir":"Articles > Web_only","previous_headings":"","what":"Single splits and Leave Future Out Cross-Validation","title":"Cross-validation for model evaluation and comparison","text":"cases single test set evaluated (e.g. 10% data), using sdmTMB_cv() function may overkill two sdmTMB() models fit, using function may worthwhile reduce coding errors (log-likelihood ELPD calculations). example, assign two folds, randomly holding 10% observations test set (test set given ID = 1, training set given ID = 2). can ignore total log-likelihood total ELPD, just focus first elements lists, e.g. wanted LFOCV, also use sdmTMB_cv() function—though either way, gets complicated need change data prediction. pcod dataset, years temporal folds, include year factor turn spatiotemporal fields . can use years 2011-2017 test years. Two things note specified time varying coefficients smooth year effects ~ s(year), ’d want specify missing years extra_time argument. Second, given ways folds set , extract log-likelihood values just years interest . Finally, ’s also possible procedure using sdmTMB() rather sdmTMB_cv(). Note: model, ’re using year factor make possible predict new years.","code":"clust <- sample(1:2, size = nrow(pcod), replace = T, prob = c(0.1, 0.9))  m_cv <- sdmTMB_cv(   density ~ 0 + s(depth_scaled) + fyear,   data = pcod,   mesh = mesh,   fold_ids = clust,   family = tweedie(link = \"log\"),   k_folds = length(unique(clust)) ) m_cv$fold_loglik[[1]] #> [1] -607.4197 unique(pcod$year) #> [1] 2003 2004 2005 2007 2009 2011 2013 2015 2017 test_years <- c(2011, 2013, 2015, 2017)  models <- list() log_lik <- list() for (i in 1:length(test_years)) {   clust <- rep(1, nrow(pcod))   clust[which(pcod$year < test_years[i])] <- 2    models[[i]] <- sdmTMB_cv(     density ~ 0 + s(depth_scaled),     data = pcod,     mesh = mesh,     spatiotemporal = \"off\",     fold_ids = clust,     family = tweedie(link = \"log\"),     k_folds = length(unique(clust))   )    log_lik[[i]] <- sum(m_cv$data$cv_loglik[which(m_cv$data$year == test_years[i])]) }"},{"path":"https://pbs-assess.github.io/sdmTMB/articles/web_only/cross-validation.html","id":"comparing-two-or-more-models","dir":"Articles > Web_only","previous_headings":"","what":"Comparing two or more models","title":"Cross-validation for model evaluation and comparison","text":"can use output sdmTMB_cv() compare two models. example, wanted evaluate support depth effect , 10-fold cross validation (’s important folds across two models). example, using either predictive log-likelihood ELPD lead one conclude including depth improves predictive accuracy model.","code":"clust <- sample(1:10, size = nrow(pcod), replace = T)  m1 <- sdmTMB_cv(   density ~ 0 + fyear,   data = pcod,   mesh = mesh,   fold_ids = clust,   family = tweedie(link = \"log\"),   k_folds = length(unique(clust)) )  m2 <- sdmTMB_cv(   density ~ 0 + fyear + s(depth_scaled),   data = pcod,   mesh = mesh,   fold_ids = clust,   family = tweedie(link = \"log\"),   k_folds = length(unique(clust)) )  # Compare log-likelihoods -- higher is better! m1$sum_loglik m2$sum_loglik  # Compare ELPD -- higher is better! m1$elpd m2$elpd"},{"path":"https://pbs-assess.github.io/sdmTMB/articles/web_only/cross-validation.html","id":"model-ensembling","dir":"Articles > Web_only","previous_headings":"","what":"Model ensembling","title":"Cross-validation for model evaluation and comparison","text":"Finally, instead identifying single “best” models, may interested model averaging. sdmTMB package, ’ve implemented model stacking procedure described (Yao et al. 2018) sdmTMB_stacking() function. procedure uses optimization find normalized weights maximize total log-likelihood across models (metrics may also used). Inputs function list models, list element output call sdmTMB_cv(): default calculation uses data fold. instead, split data 10/90 split (example ), wouldn’t want use 2nd model fit generate weights. just wanted use predictions first fold onto 10% test set, specify using include_folds argument.","code":"weights <- sdmTMB_stacking(model_list) weights <- sdmTMB_stacking(model_list, include_folds = 1)"},{"path":[]},{"path":"https://pbs-assess.github.io/sdmTMB/articles/web_only/delta-models.html","id":"example-with-built-in-delta-model","dir":"Articles > Web_only","previous_headings":"","what":"Example with built-in delta model","title":"Fitting delta (hurdle) models with sdmTMB","text":", show example fitting using built-delta functionality, well build model component separately combine. built-approach convenient, allows parameters shared across components, allows calculation derived quantities standardized indexes (get_index()) internally calculated standard errors. use dataset built sdmTMB package: trawl survey data Pacific Cod Queen Charlotte Sound, British Columbia, Canada. density units kg/km2. , X Y coordinates UTM zone 9. first create mesh use models. can fit model Pacific cod density using delta-gamma model, including smoothed effect depth. default built-delta models formula, spatial spatio-temporal structure, anisotropy shared two model components. However, elements (formula, spatial, spatiotemporal, share_range) can also specified independently model using list format within function argument (see examples ). first element list binomial component second element positive component (e.g., Gamma). elements must shared now (e.g., smoothers, spatially varying coefficients, time-varying coefficients). specify settings spatial spatio-temporal effects model component, create list settings within spatial spatiotemporal arguments. example, spatial = list(\"\", \"\"), spatiotemporal = list(\"\", \"rw\"). similarly specify different formula component model, using list(y ~ x1, y ~ x2) instance, include effect depth positive model, remove presence-absence model. However, currently limitations specifying separate formulas model component. two formulas : smoothers threshold effects random intercepts now, must specified single formula shared across two models. model component can similarly separate settings share_range, determines whether shared spatial spatiotemporal range parameter (TRUE) independent range parameters (FALSE), using list. Lastly, whether anisotropy included model determined logical argument anisotropy (.e., TRUE FALSE), separately specified model. anisotropy included, default shared across two model components. However can made unique model component using sdmTMBcontrol(map = ...) adding argument control fitting model. ‘maps’ anisotropy parameters unique across model components. fit delta model, can evaluate plot output, diagnostics, predictions similar sdmTMB models. printed model output show estimates standard errors parameters model separately. Using tidy() function turn sdmTMB model output data frame, argument model=1 model=2 specify model component extract dataframe. See tidy.sdmTMB() additional arguments options. built-delta models, default function return estimated response parameters grid cell model separately, notated 1 (presence/absence model) 2 (positive catch model) column name. See predict.sdmTMB() description values data frame. can use predictions built-delta model (making sure return_tmb_object=TRUE) get index values using get_index() function. can used predictions include first second models (.e., using default specifying model argument) predictions generated using model=NA. get_index() function automatically combine predictions first second model calculating index values. modelling purposes creating index see vignette Index standardization sdmTMB. can plot conditional effects covariates (depth example model) using package visreg specifying model component model=1 presence-absence model model=2 positive catch model. Currently, plotting effects built-delta models ggeffects supported. See vignette using visreg sdmTMB information.  built-delta models can also evaluated residuals() functions sdmTMB. Similarly generating predictions, can specify model components want return residuals using model argument specifying =1 =2. See residuals.sdmTMB() additional options evaluating residuals sdmTMB models. can also simulate new observations fitted delta model. functions, can specify model simulate using argument model=1 presence/absence, model=2 positive catches, model=NA combined predictions. See simulate.sdmTMB() details simulation options.","code":"pcod_mesh <- make_mesh(pcod, c(\"X\", \"Y\"), cutoff = 15) fit_dg <- sdmTMB(density ~ 1 + s(depth),   data = pcod,   mesh = pcod_mesh,   time = \"year\",   family = delta_gamma() ) print(fit_dg) #> Spatiotemporal model fit by ML ['sdmTMB'] #> Formula: density ~ 1 + s(depth) #> Mesh: pcod_mesh (isotropic covariance) #> Time column: year #> Data: pcod #> Family: delta_gamma(link1 = 'logit', link2 = 'log') #>  #> Delta/hurdle model 1: ----------------------------------- #> Family: binomial(link = 'logit')  #>             coef.est coef.se #> (Intercept)    -0.34    0.61 #> sdepth         12.77   29.02 #>  #> Smooth terms: #>            Std. Dev. #> sds(depth)     14.38 #>  #> Matern range: 61.41 #> Spatial SD: 1.71 #> Spatiotemporal SD: 0.81 #>  #> Delta/hurdle model 2: ----------------------------------- #> Family: Gamma(link = 'log')  #>             coef.est coef.se #> (Intercept)     3.67    0.12 #> sdepth          3.06   12.83 #>  #> Smooth terms: #>            Std. Dev. #> sds(depth)      5.41 #>  #> Dispersion parameter: 1.03 #> Matern range: 14.80 #> Spatial SD: 0.69 #> Spatiotemporal SD: 0.81 #>  #> ML criterion at convergence: 6126.400 #>  #> See ?tidy.sdmTMB to extract these values as a data frame. tidy(fit_dg) # model = 1 is default #> # A tibble: 1 × 3 #>   term        estimate std.error #>   <chr>          <dbl>     <dbl> #> 1 (Intercept)   -0.343     0.614 tidy(fit_dg, model = 1) #> # A tibble: 1 × 3 #>   term        estimate std.error #>   <chr>          <dbl>     <dbl> #> 1 (Intercept)   -0.343     0.614 tidy(fit_dg, model = 1, \"ran_pars\", conf.int = TRUE) #> Standard errors intentionally omitted because they have been calculated in log #> space. #> # A tibble: 3 × 5 #>   term    estimate std.error conf.low conf.high #>   <chr>      <dbl> <lgl>        <dbl>     <dbl> #> 1 range     61.4   NA          39.2       96.3  #> 2 sigma_O    1.71  NA           1.26       2.32 #> 3 sigma_E    0.806 NA           0.570      1.14 tidy(fit_dg, model = 2) #> # A tibble: 1 × 3 #>   term        estimate std.error #>   <chr>          <dbl>     <dbl> #> 1 (Intercept)     3.67     0.120 tidy(fit_dg, model = 2, \"ran_pars\", conf.int = TRUE) #> Standard errors intentionally omitted because they have been calculated in log #> space. #> # A tibble: 4 × 5 #>   term    estimate std.error conf.low conf.high #>   <chr>      <dbl> <lgl>        <dbl>     <dbl> #> 1 range     14.8   NA           7.62      28.8  #> 2 phi        1.03  NA           0.939      1.14 #> 3 sigma_O    0.691 NA           0.361      1.32 #> 4 sigma_E    0.806 NA           0.570      1.14 p <- predict(fit_dg, newdata = qcs_grid) str(p) #> 'data.frame':    65826 obs. of  16 variables: #>  $ X            : num  456 458 460 462 464 466 468 470 472 474 ... #>  $ Y            : num  5636 5636 5636 5636 5636 ... #>  $ depth        : num  347 223 204 183 183 ... #>  $ depth_scaled : num  1.561 0.57 0.363 0.126 0.122 ... #>  $ depth_scaled2: num  2.4361 0.3246 0.132 0.0158 0.0149 ... #>  $ year         : int  2003 2003 2003 2003 2003 2003 2003 2003 2003 2003 ... #>  $ est1         : num  -5.804 -0.796 0.021 0.87 0.98 ... #>  $ est2         : num  3.2 3.71 4.02 4.39 4.43 ... #>  $ est_non_rf1  : num  -5.508 -0.598 0.12 0.871 0.882 ... #>  $ est_non_rf2  : num  2.83 3.31 3.59 3.94 3.94 ... #>  $ est_rf1      : num  -0.296138 -0.197484 -0.098831 -0.000177 0.098476 ... #>  $ est_rf2      : num  0.368 0.398 0.428 0.459 0.489 ... #>  $ omega_s1     : num  -0.00543 0.09317 0.19178 0.29039 0.38899 ... #>  $ omega_s2     : num  0.108 0.119 0.129 0.139 0.15 ... #>  $ epsilon_st1  : num  -0.291 -0.291 -0.291 -0.291 -0.291 ... #>  $ epsilon_st2  : num  0.26 0.28 0.299 0.319 0.339 ... p2 <- predict(fit_dg, newdata = qcs_grid, return_tmb_object = TRUE) ind_dg <- get_index(p2, bias_correct = FALSE) visreg_delta(fit_dg, xvar = \"depth\", model = 1, gg = TRUE) visreg_delta(fit_dg, xvar = \"depth\", model = 2, gg = TRUE) simulations <- simulate(fit_dg, nsim = 5, seed = 5090, model = NA)"},{"path":"https://pbs-assess.github.io/sdmTMB/articles/web_only/delta-models.html","id":"delta-models-by-fitting-two-components-separately-and-combining-predictions","dir":"Articles > Web_only","previous_headings":"","what":"Delta models by fitting two components separately and combining predictions","title":"Fitting delta (hurdle) models with sdmTMB","text":"Next, show example implement delta-gamma model sdmTMB, component fit separately combined. approach gives maximum flexibility model lets develop time. limitations calculating index abundance want share parameters. necessary use mesh models, one can updating first mesh match reduced data frame shown : delta-gamma model similar Tweedie model Intro modelling sdmTMB vignette, except use s() depth effect. One can use different covariates model, case just let depth effect wiggly specifying k = 3. Next, need way combining predictions across two models. need point predictions, can just multiply predictions two models applying inverse link: measure uncertainty required, can simulate joint parameter precision matrix using predict() function number simulations selected (e.g., sims = 500). predictions come simulated draws parameter covariance matrix, predictions become consistent larger number draws. However, greater number draws takes longer calculate use memory (larger matrix), fewer draws (~100) may fine experimentation. larger number (say ~1000) may appropriate final model runs. p_combined_sim matrix row row data predicted width nsim. can process matrix however like. can save median predictions upper lower 95% confidence intervals:   can calculate spatial uncertainty:","code":"glimpse(pcod) #> Rows: 2,143 #> Columns: 12 #> $ year          <int> 2003, 2003, 2003, 2003, 2003, 2003, 2003, 2003, 2003, 20… #> $ X             <dbl> 446.4752, 446.4594, 448.5987, 436.9157, 420.6101, 417.71… #> $ Y             <dbl> 5793.426, 5800.136, 5801.687, 5802.305, 5771.055, 5772.2… #> $ depth         <dbl> 201, 212, 220, 197, 256, 293, 410, 387, 285, 270, 381, 1… #> $ density       <dbl> 113.138476, 41.704922, 0.000000, 15.706138, 0.000000, 0.… #> $ present       <dbl> 1, 1, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0,… #> $ lat           <dbl> 52.28858, 52.34890, 52.36305, 52.36738, 52.08437, 52.094… #> $ lon           <dbl> -129.7847, -129.7860, -129.7549, -129.9265, -130.1586, -… #> $ depth_mean    <dbl> 5.155194, 5.155194, 5.155194, 5.155194, 5.155194, 5.1551… #> $ depth_sd      <dbl> 0.4448783, 0.4448783, 0.4448783, 0.4448783, 0.4448783, 0… #> $ depth_scaled  <dbl> 0.3329252, 0.4526914, 0.5359529, 0.2877417, 0.8766077, 1… #> $ depth_scaled2 <dbl> 0.11083919, 0.20492947, 0.28724555, 0.08279527, 0.768440… mesh1 <- make_mesh(pcod, c(\"X\", \"Y\"), cutoff = 20) # coarse for vignette speed dat2 <- subset(pcod, density > 0) mesh2 <- make_mesh(dat2,   xy_cols = c(\"X\", \"Y\"),   mesh = mesh1$mesh ) m1 <- sdmTMB(   formula = present ~ 0 + as.factor(year) + s(depth, k = 3),   data = pcod,   mesh = mesh1,   time = \"year\", family = binomial(link = \"logit\"),   spatiotemporal = \"iid\",   spatial = \"on\" ) m1 #> Spatiotemporal model fit by ML ['sdmTMB'] #> Formula: present ~ 0 + as.factor(year) + s(depth, k = 3) #> Mesh: mesh1 (isotropic covariance) #> Time column: year #> Data: pcod #> Family: binomial(link = 'logit') #>   #>                     coef.est coef.se #> as.factor(year)2003    -0.76    0.42 #> as.factor(year)2004    -0.40    0.42 #> as.factor(year)2005    -0.42    0.42 #> as.factor(year)2007    -1.40    0.42 #> as.factor(year)2009    -1.16    0.42 #> as.factor(year)2011    -1.56    0.42 #> as.factor(year)2013    -0.38    0.42 #> as.factor(year)2015    -0.65    0.42 #> as.factor(year)2017    -1.56    0.42 #> sdepth                  5.66    0.50 #>  #> Smooth terms: #>            Std. Dev. #> sds(depth)      85.9 #>  #> Matern range: 28.70 #> Spatial SD: 1.89 #> Spatiotemporal SD: 0.90 #> ML criterion at convergence: 1054.414 #>  #> See ?tidy.sdmTMB to extract these values as a data frame. m2 <- sdmTMB(   formula = density ~ 0 + as.factor(year) + s(depth),   data = dat2,   mesh = mesh2,   time = \"year\",   family = Gamma(link = \"log\"),   spatiotemporal = \"iid\",   spatial = \"on\" ) m2 #> Spatiotemporal model fit by ML ['sdmTMB'] #> Formula: density ~ 0 + as.factor(year) + s(depth) #> Mesh: mesh2 (isotropic covariance) #> Time column: year #> Data: dat2 #> Family: Gamma(link = 'log') #>   #>                     coef.est coef.se #> as.factor(year)2003     4.06    0.20 #> as.factor(year)2004     4.22    0.20 #> as.factor(year)2005     4.19    0.20 #> as.factor(year)2007     3.38    0.20 #> as.factor(year)2009     3.71    0.21 #> as.factor(year)2011     4.51    0.21 #> as.factor(year)2013     4.02    0.19 #> as.factor(year)2015     4.13    0.20 #> as.factor(year)2017     3.84    0.22 #> sdepth                  2.50    3.21 #>  #> Smooth terms: #>            Std. Dev. #> sds(depth)      1.89 #>  #> Dispersion parameter: 0.94 #> Matern range: 0.02 #> Spatial SD: 453.59 #> Spatiotemporal SD: 1287.84 #> ML criterion at convergence: 5102.136 #>  #> See ?tidy.sdmTMB to extract these values as a data frame. pred <- qcs_grid # use the grid as template for saving our predictions p_bin <- predict(m1, newdata = qcs_grid) p_pos <- predict(m2, newdata = qcs_grid) p_bin_prob <- m1$family$linkinv(p_bin$est) p_pos_exp <- m2$family$linkinv(p_pos$est) pred$est_exp <- p_bin_prob * p_pos_exp set.seed(28239) p_bin_sim <- predict(m1, newdata = qcs_grid, nsim = 100) p_pos_sim <- predict(m2, newdata = qcs_grid, nsim = 100) p_bin_prob_sim <- m1$family$linkinv(p_bin_sim) p_pos_exp_sim <- m2$family$linkinv(p_pos_sim) p_combined_sim <- p_bin_prob_sim * p_pos_exp_sim pred$median <- apply(p_combined_sim, 1, median) plot(pred$est_exp, pred$median) ggplot(subset(pred, year == 2017), aes(X, Y, fill = median)) +   geom_raster() +   coord_fixed() +   scale_fill_viridis_c(trans = \"sqrt\") pred$cv <- apply(p_combined_sim, 1, function(x) sd(x) / mean(x)) ggplot(subset(pred, year == 2017), aes(X, Y, fill = cv)) + # 2017 as an example   geom_raster() +   coord_fixed() +   scale_fill_viridis_c(trans = \"log10\")"},{"path":"https://pbs-assess.github.io/sdmTMB/articles/web_only/ggeffects.html","id":"example-with-pacific-cod-presence","dir":"Articles > Web_only","previous_headings":"","what":"Example with Pacific cod presence","title":"Visualizing marginal effects in sdmTMB models with ggeffects","text":"start, use Pacific cod example data. fit model fish presence/absence covariates depth fixed effect year using Tweedie distribution. can use ggeffects::ggeffect() see effect depth probability Pacific cod present. can control range interval depths predicted within function (e.g. [0:500 =1]).  can also plot effects year.  can add data points  can also use ggeffect plot multiple variables listing terms = c(), first term listed indicating variable plotted x-axis, remaining listed terms (four total) indicating groups. Adding facet = TRUE show year separate plot, instead overlain one plot.  Adding facet = TRUE show year separate plot, instead overlain one plot.  can also use make ggplot plot calling ggeffects object dat data frame.  Plotting using continuous response (density) rather presence-similar. instance: can fit model interaction two continuous variables: plotting two continuous variables, ggeffect() make non-target (2nd) variable discrete selecting different levels.   specify levels rather letting ggeffect() choose , use brackets selected values within term list, instance","code":"pcod$fyear <- as.factor(pcod$year) mesh <- make_mesh(pcod, c(\"X\", \"Y\"), cutoff = 20) fit <- sdmTMB(present ~ poly(depth, 2) + fyear,   data = pcod,   mesh = mesh,   spatial = \"on\",   family = binomial() ) #> Warning in checkMatrixPackageVersion(): Package version inconsistency detected. #> TMB was built with Matrix version 1.5.3 #> Current Matrix version is 1.5.1 #> Please re-install 'TMB' from source using install.packages('TMB', type = 'source') or ask CRAN for a binary version of 'TMB' matching CRAN's 'Matrix' package g <- ggeffect(fit, \"depth [0:500 by=1]\") plot(g) g2 <- ggeffect(fit, \"fyear\") plot(g2) plot(g, add.data = TRUE) dat <- ggeffect(fit, terms = c(\"depth [0:350 by=5]\", \"fyear\")) plot(dat) plot(dat, facet = TRUE) ggplot(dat, aes(x, predicted, colour = group)) +   geom_line() g5 <- ggeffect(fit3, terms = c(\"depth_scaled [-3:2.7 by=0.01]\", \"numeric_year\")) plot(g5) plot(g5, facet = TRUE) g6 <- ggeffect(fit3, terms = c(\"depth_scaled [-3:2.7 by=0.01]\", \"numeric_year [1,7,15]\")) plot(g6)"},{"path":"https://pbs-assess.github.io/sdmTMB/articles/web_only/residual-checking.html","id":"references","dir":"Articles > Web_only","previous_headings":"","what":"References","title":"Residual checking with sdmTMB","text":"Dunn, P.K., Smyth, G.K. 1996. Randomized Quantile Residuals. Journal Computational Graphical Statistics 5(3): 236–244. Rufener, M.-C., Kristensen, K., Nielsen, J.R., Bastardie, F. 2021. Bridging gap commercial fisheries survey data model spatiotemporal dynamics marine species. Ecological Applications press: e02453. Thygesen, U.H., Albertsen, C.M., Berg, C.W., Kristensen, K., Nielsen, . 2017. Validation ecological state space models using Laplace approximation. Environ Ecol Stat 24(2): 317–339.","code":""},{"path":"https://pbs-assess.github.io/sdmTMB/articles/web_only/visreg.html","id":"delta-models","dir":"Articles > Web_only","previous_headings":"","what":"Delta models","title":"Visualizing sdmTMB conditional effects using visreg","text":"visreg() can also used plot output delta models sdmTMB() using similar code previous plots, using sdmTMB wrapper function visreg_delta() specifying model = 1 encounter (0 vs. non-zero) model model = 2 positive component model (e.g., Gamma, lognormal). example:   Note plotting visreg_delta(), categorical variables like year need designated factor data frame, example fyear, rather model formula (e.g., + .factor(year)).","code":"fit_dg <- sdmTMB(   density ~ s(depth_scaled, year, k = 8),   data = pcod_2011,   mesh = pcod_mesh_2011,   spatial = \"off\", # for vignette speed   family = delta_gamma() )  visreg_delta(fit_dg, xvar = \"depth_scaled\", model = 1, gg = TRUE) visreg_delta(fit_dg, xvar = \"depth_scaled\", model = 2, gg = TRUE)"},{"path":"https://pbs-assess.github.io/sdmTMB/authors.html","id":null,"dir":"","previous_headings":"","what":"Authors","title":"Authors and Citation","text":"Sean C. Anderson. Author, maintainer. Eric J. Ward. Author. Lewis . K. Barnett. Author. Philina . English. Author. James T. Thorson. Contributor, copyright holder.            VAST author Joe Watson. Contributor.            Censored Poisson Julia Indivero. Contributor.            Vignette writing Cole C. Monnahan. Contributor, copyright holder.            VAST contributor Mollie Brooks. Contributor, copyright holder.            glmmTMB author Ben Bolker. Contributor, copyright holder.            glmmTMB author Kasper Kristensen. Contributor, copyright holder.            TMB/glmmTMB author Martin Maechler. Contributor, copyright holder.            glmmTMB author Arni Magnusson. Contributor, copyright holder.            glmmTMB author Hans J. Skaug. Contributor, copyright holder.            glmmTMB author, SPDE barrier Anders Nielsen. Contributor, copyright holder.            glmmTMB author Casper Berg. Contributor, copyright holder.            glmmTMB author Koen van Bentham. Contributor, copyright holder.            glmmTMB author Olav Nikolai Breivik. Contributor, copyright holder.            SPDE barrier Simon Wood. Contributor, copyright holder.            mgcv: smoother prediction Paul-Christian Bürkner. Contributor, copyright holder.            brms: smoother matrix parsing Majesty King Right Canada, represented Minister Department Fisheries Oceans. Copyright holder.","code":""},{"path":"https://pbs-assess.github.io/sdmTMB/authors.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"Authors and Citation","text":"Anderson, S.C., E.J. Ward, P.. English, L..K. Barnett. 2022. sdmTMB: R package fast, flexible, user-friendly generalized linear mixed effects models spatial spatiotemporal random fields. bioRxiv 2022.03.24.485545; doi: https://doi.org/10.1101/2022.03.24.485545","code":"@Article{,   title = {sdmTMB: an R package for fast, flexible, and user-friendly generalized linear mixed effects models with spatial and spatiotemporal random fields},   author = {{Anderson} and Sean C. and {Ward} and Eric J. and {English} and Philina A. and {Barnett} and Lewis A.K.},   journal = {bioRxiv},   year = {2022},   volume = {2022.03.24.485545},   doi = {10.1101/2022.03.24.485545},   url = {https://doi.org/10.1101/2022.03.24.485545}, }"},{"path":"https://pbs-assess.github.io/sdmTMB/header.html","id":null,"dir":"","previous_headings":"","what":"sdmTMB ","title":"sdmTMB ","text":"Spatial spatiotemporal GLMMs TMB  sdmTMB R package fits spatial spatiotemporal predictive-process GLMMs (Generalized Linear Mixed Effects Models) using Template Model Builder (TMB), R-INLA, Gaussian Markov random fields. One common application species distribution models (SDMs). See also documentation site.","code":""},{"path":[]},{"path":"https://pbs-assess.github.io/sdmTMB/index.html","id":"sdmtmb-","dir":"","previous_headings":"","what":"Spatial and Spatiotemporal SPDE-Based GLMMs with TMB","title":"Spatial and Spatiotemporal SPDE-Based GLMMs with TMB","text":"Spatial spatiotemporal GLMMs TMB sdmTMB R package fits spatial spatiotemporal predictive-process GLMMs (Generalized Linear Mixed Effects Models) using Template Model Builder (TMB), R-INLA, Gaussian Markov random fields. One common application species distribution models (SDMs). See also documentation site.","code":""},{"path":"https://pbs-assess.github.io/sdmTMB/index.html","id":"table-of-contents","dir":"","previous_headings":"","what":"Table of contents","title":"Spatial and Spatiotemporal SPDE-Based GLMMs with TMB","text":"Installation Overview Getting help Citation Related software Basic use Time-varying coefficients Spatially varying coefficients (SVC) Random intercepts Breakpoint theshold effects Simulating data Sampling joint precision matrix Calculating uncertainty spatial predictions Cross validation Priors Bayesian MCMC sampling Stan Turning random fields Using custom INLA mesh Barrier meshes","code":""},{"path":"https://pbs-assess.github.io/sdmTMB/index.html","id":"installation","dir":"","previous_headings":"","what":"Installation","title":"Spatial and Spatiotemporal SPDE-Based GLMMs with TMB","text":"sdmTMB can installed CRAN: Assuming C++ compiler installed, development version can installed: problems installing INLA, try installing directly first.","code":"install.packages(\"sdmTMB\", dependencies = TRUE) # install.packages(\"remotes\") remotes::install_github(\"pbs-assess/sdmTMB\", dependencies = TRUE)"},{"path":"https://pbs-assess.github.io/sdmTMB/index.html","id":"overview","dir":"","previous_headings":"","what":"Overview","title":"Spatial and Spatiotemporal SPDE-Based GLMMs with TMB","text":"Analyzing geostatistical data (coordinate-referenced observations underlying spatial process) becoming increasingly common ecology. sdmTMB implements geostatistical spatial spatiotemporal GLMMs using TMB model fitting R-INLA set SPDE (stochastic partial differential equation) matrices. One common application species distribution models (SDMs), hence package name. goal sdmTMB provide fast, flexible, user-friendly interface—similar popular R package glmmTMB—focus spatial spatiotemporal models SPDE approach. extend generalized linear mixed models (GLMMs) familiar ecologists include following optional features: spatial random fields spatiotemporal random fields may independent year modelled random walks autoregressive processes smooth terms covariates, using familiar s() notation mgcv breakpoint (hockey-stick) logistic covariates time-varying covariates (coefficients modelled random walks) spatially varying coefficient models (SVCs) interpolation forecasting missing future time slices wide range families: standard R families plus tweedie(), nbinom1(), nbinom2(), lognormal(), student(), plus truncated censored families delta/hurdle models including delta_gamma(), delta_lognormal(), delta_truncated_nbinom2() Estimation performed sdmTMB via maximum marginal likelihood objective function calculated TMB minimized R via stats::nlminb() random effects integrated via Laplace approximation. sdmTMB package also allows models passed Stan via tmbstan, allowing Bayesian model estimation. See ?sdmTMB ?predict.sdmTMB complete examples. Also see vignettes (‘Articles’) documentation site preprint appendices linked .","code":""},{"path":"https://pbs-assess.github.io/sdmTMB/index.html","id":"getting-help","dir":"","previous_headings":"","what":"Getting help","title":"Spatial and Spatiotemporal SPDE-Based GLMMs with TMB","text":"questions use sdmTMB interpret models, please post discussion board. email question, likely respond discussion board anonymized version question (without data) think helpful others. Please let us know don’t want us . bugs feature requests, please post issue tracker. Slides recordings workshop sdmTMB.","code":""},{"path":"https://pbs-assess.github.io/sdmTMB/index.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"Spatial and Spatiotemporal SPDE-Based GLMMs with TMB","text":"cite sdmTMB publications use: Anderson, S.C., E.J. Ward, P.. English, L..K. Barnett. 2022. sdmTMB: R package fast, flexible, user-friendly generalized linear mixed effects models spatial spatiotemporal random fields. bioRxiv 2022.03.24.485545; doi: https://doi.org/10.1101/2022.03.24.485545","code":"citation(\"sdmTMB\")"},{"path":"https://pbs-assess.github.io/sdmTMB/index.html","id":"related-software","dir":"","previous_headings":"","what":"Related software","title":"Spatial and Spatiotemporal SPDE-Based GLMMs with TMB","text":"sdmTMB heavily inspired VAST R package: Thorson, J.T. 2019. Guidance decisions using Vector Autoregressive Spatio-Temporal (VAST) package stock, ecosystem, habitat climate assessments. Fisheries Research 210: 143–161. https://doi.org/10.1016/j.fishres.2018.10.013. glmmTMB R package: Brooks, M.E., Kristensen, K., van Benthem, K.J., Magnusson, ., Berg, C.W., Nielsen, ., Skaug, H.J., Maechler, M., Bolker, B.M. 2017. glmmTMB balances speed flexibility among packages zero-inflated generalized linear mixed modeling. R Journal 9(2): 378–400. https://doi.org/10.32614/rj-2017-066. INLA inlabru can fit many models sdmTMB (many ) approximate Bayesian inference framework. mgcv can fit similar SPDE-based Gaussian random field models code included Miller et al. (2019). table sdmTMB preprint describes functionality timing comparisons sdmTMB, VAST, INLA/inlabru, mgcv discussion makes suggestions might choose one package another.","code":""},{"path":"https://pbs-assess.github.io/sdmTMB/index.html","id":"basic-use","dir":"","previous_headings":"","what":"Basic use","title":"Spatial and Spatiotemporal SPDE-Based GLMMs with TMB","text":"sdmTMB model requires data frame contains response column, columns predictors, columns spatial coordinates. usually makes sense convert spatial coordinates equidistant projection UTMs distance remains constant throughout study region [e.g., using sf::st_transform()]. , illustrate spatial model fit Pacific cod (Gadus macrocephalus) trawl survey data Queen Charlotte Sound, BC, Canada. model contains main effect depth penalized smoother, spatial random field, Tweedie observation error. data frame pcod (built package) column year year survey, density density Pacific cod given survey tow, present whether density > 0, depth depth meters tow, spatial coordinates X Y, UTM coordinates kilometres. start creating mesh object contains matrices apply SPDE approach. , cutoff defines minimum allowed distance points units X Y (km). Alternatively, created mesh via INLA package supplied make_mesh(). can inspect mesh object associated plotting method plot(mesh). Fit spatial model smoother depth: Print model fit: output indicates model fit maximum (marginal) likelihood (ML). also see formula, mesh, fitted data, family. Next see estimated main effects including linear component smoother (sdepth), standard deviation smoother weights (sds(depth)), Tweedie dispersion power parameters, Matérn range distance (distance points effectively independent), marginal spatial field standard deviation, negative log likelihood convergence. can extract parameters data frame: Run basic sanity checks model: Use visreg package plot smoother effect link space randomized quantile partial residuals:  response scale:  Predict new data:  switch presence-absence model changing response column family: hurdle/delta model changing family: instead fit spatiotemporal model specifying time column spatiotemporal structure: wanted create area-weighted standardized population index, predict grid covering entire survey (qcs_grid) grid cell area 4 (2 x 2 km) pass predictions get_index():  center gravity:  basic features, see vignettes Intro modelling sdmTMB Index standardization sdmTMB.","code":"library(dplyr) library(ggplot2) library(sdmTMB) head(pcod) #> # A tibble: 3 × 6 #>    year density present depth     X     Y #>   <int>   <dbl>   <dbl> <dbl> <dbl> <dbl> #> 1  2003   113.        1   201  446. 5793. #> 2  2003    41.7       1   212  446. 5800. #> 3  2003     0         0   220  449. 5802. mesh <- make_mesh(pcod, xy_cols = c(\"X\", \"Y\"), cutoff = 10) fit <- sdmTMB(   density ~ s(depth),   data = pcod,   mesh = mesh,   family = tweedie(link = \"log\"),   spatial = \"on\" ) fit #> Spatial model fit by ML ['sdmTMB'] #> Formula: density ~ s(depth) #> Mesh: mesh #> Data: pcod #> Family: tweedie(link = 'log') #>   #>             coef.est coef.se #> (Intercept)     2.37    0.21 #> sdepth          6.17   25.17 #>  #> Smooth terms: #>            Std. Dev. #> sds(depth)     13.93 #>  #> Dispersion parameter: 12.69 #> Tweedie p: 1.58 #> Matern range: 16.39 #> Spatial SD: 1.86 #> ML criterion at convergence: 6402.136 #>  #> See ?tidy.sdmTMB to extract these values as a data frame. tidy(fit, conf.int = TRUE) #> # A tibble: 1 × 5 #>   term        estimate std.error conf.low conf.high #>   <chr>          <dbl>     <dbl>    <dbl>     <dbl> #> 1 (Intercept)     2.37     0.215     1.95      2.79 tidy(fit, effects = \"ran_pars\", conf.int = TRUE) #> # A tibble: 4 × 5 #>   term      estimate std.error conf.low conf.high #>   <chr>        <dbl> <lgl>        <dbl>     <dbl> #> 1 range        16.4  NA            9.60     28.0  #> 2 phi          12.7  NA           11.9      13.5  #> 3 sigma_O       1.86 NA            1.48      2.34 #> 4 tweedie_p     1.58 NA            1.56      1.60 sanity(fit) #> ✔ Non-linear minimizer suggests successful convergence #> ✔ Hessian matrix is positive definite #> ✔ No extreme or very small eigenvalues detected #> ✔ No gradients with respect to fixed effects are >= 0.001 #> ✔ No fixed-effect standard errors are NA #> ✔ No standard errors look unreasonably large #> ✔ No sigma parameters are < 0.01 #> ✔ No sigma parameters are > 100 #> ✔ Range parameter doesn't look unreasonably large visreg::visreg(fit, xvar = \"depth\", xlim = c(50, 500)) visreg::visreg(fit, xvar = \"depth\", scale = \"response\", xlim = c(50, 300), nn = 200) p <- predict(fit, newdata = qcs_grid) head(p) #> # A tibble: 3 × 7 #>       X     Y depth   est est_non_rf est_rf omega_s #>   <dbl> <dbl> <dbl> <dbl>      <dbl>  <dbl>   <dbl> #> 1   456  5636  347. -3.06      -3.08 0.0172  0.0172 #> 2   458  5636  223.  2.03       1.99 0.0459  0.0459 #> 3   460  5636  204.  2.89       2.82 0.0747  0.0747 ggplot(p, aes(X, Y, fill = exp(est))) + geom_raster() +   scale_fill_viridis_c(trans = \"sqrt\") fit <- sdmTMB(   present ~ s(depth),   data = pcod,    mesh = mesh,   family = binomial(link = \"logit\") ) fit <- sdmTMB(   density ~ s(depth),   data = pcod,   mesh = mesh,   family = delta_gamma(link1 = \"logit\", link2 = \"log\"), ) fit_spatiotemporal <- sdmTMB(   density ~ s(depth, k = 5),    data = pcod,    mesh = mesh,   time = \"year\",   family = tweedie(link = \"log\"),    spatial = \"off\",    spatiotemporal = \"ar1\" ) p_st <- predict(fit_spatiotemporal, newdata = qcs_grid,    return_tmb_object = TRUE) index <- get_index(p_st, area = rep(4, nrow(qcs_grid))) ggplot(index, aes(year, est)) +   geom_ribbon(aes(ymin = lwr, ymax = upr), fill = \"grey90\") +   geom_line(lwd = 1, colour = \"grey30\") +   labs(x = \"Year\", y = \"Biomass (kg)\") cog <- get_cog(p_st, format = \"wide\") ggplot(cog, aes(est_x, est_y, colour = year)) +   geom_pointrange(aes(xmin = lwr_x, xmax = upr_x)) +   geom_pointrange(aes(ymin = lwr_y, ymax = upr_y)) +   scale_colour_viridis_c()"},{"path":[]},{"path":"https://pbs-assess.github.io/sdmTMB/index.html","id":"time-varying-coefficients","dir":"","previous_headings":"Advanced functionality","what":"Time-varying coefficients","title":"Spatial and Spatiotemporal SPDE-Based GLMMs with TMB","text":"Time-varying intercept: Time-varying (random walk) effect depth: See vignette Intro modelling sdmTMB details.","code":"fit <- sdmTMB(   density ~ 0 + s(depth, k = 5),    time_varying = ~ 1,    data = pcod, mesh = mesh,   time = \"year\",     family = tweedie(link = \"log\"),   silent = FALSE # see progress ) fit <- sdmTMB(   density ~ 1,    time_varying = ~ 0 + depth_scaled + depth_scaled2,   data = pcod, mesh = mesh,   time = \"year\",   family = tweedie(link = \"log\"),   spatial = \"off\",   spatiotemporal = \"ar1\",   silent = FALSE )"},{"path":"https://pbs-assess.github.io/sdmTMB/index.html","id":"spatially-varying-coefficients-svc","dir":"","previous_headings":"Advanced functionality","what":"Spatially varying coefficients (SVC)","title":"Spatial and Spatiotemporal SPDE-Based GLMMs with TMB","text":"Spatially varying effect time: See zeta_s output, represents coefficient varying space. ’ll want ensure set model ballpark mean 0 (e.g., including formula ).  See vignette Fitting spatial trend models sdmTMB details.","code":"pcod$year_scaled <- as.numeric(scale(pcod$year)) fit <- sdmTMB(   density ~ s(depth, k = 5) + year_scaled,   spatial_varying = ~ year_scaled,    data = pcod, mesh = mesh,    time = \"year\",   family = tweedie(link = \"log\"),   spatiotemporal = \"off\" ) qcs_grid$year_scaled <- (qcs_grid$year - mean(pcod$year)) / sd(pcod$year) p <- predict(fit, newdata = qcs_grid) %>%    subset(year == 2011) # any year ggplot(p, aes(X, Y, fill = zeta_s_year_scaled)) + geom_raster() +   scale_fill_gradient2()"},{"path":"https://pbs-assess.github.io/sdmTMB/index.html","id":"random-intercepts","dir":"","previous_headings":"Advanced functionality","what":"Random intercepts","title":"Spatial and Spatiotemporal SPDE-Based GLMMs with TMB","text":"can use syntax (1 | group) lme4 glmmTMB fit random intercepts:","code":"pcod$year_factor <- as.factor(pcod$year) fit <- sdmTMB(   density ~ s(depth, k = 5) + (1 | year_factor),   data = pcod, mesh = mesh,   time = \"year\",   family = tweedie(link = \"log\") )"},{"path":"https://pbs-assess.github.io/sdmTMB/index.html","id":"breakpoint-and-theshold-effects","dir":"","previous_headings":"Advanced functionality","what":"Breakpoint and theshold effects","title":"Spatial and Spatiotemporal SPDE-Based GLMMs with TMB","text":"See vignette Threshold modeling sdmTMB details.","code":"fit <- sdmTMB(   present ~ 1 + breakpt(depth_scaled),    data = pcod, mesh = mesh,   family = binomial(link = \"logit\") ) fit <- sdmTMB(   present ~ 1 + logistic(depth_scaled),    data = pcod, mesh = mesh,   family = binomial(link = \"logit\") )"},{"path":[]},{"path":"https://pbs-assess.github.io/sdmTMB/index.html","id":"simulating-data-from-scratch","dir":"","previous_headings":"Advanced functionality > Simulating data","what":"Simulating data from scratch","title":"Spatial and Spatiotemporal SPDE-Based GLMMs with TMB","text":"Fit simulated data: See ?sdmTMB_simulate details.","code":"predictor_dat <- expand.grid(   X = seq(0, 1, length.out = 100), Y = seq(0, 1, length.out = 100) ) mesh <- make_mesh(predictor_dat, xy_cols = c(\"X\", \"Y\"), cutoff = 0.05) sim_dat <- sdmTMB_simulate(   formula = ~ 1,   data = predictor_dat,   mesh = mesh,   family = poisson(link = \"log\"),   range = 0.3,   sigma_O = 0.4,   seed = 1,   B = 1 # B0 = intercept ) head(sim_dat) #> # A tibble: 6 × 7 #>        X     Y omega_s    mu   eta observed `(Intercept)` #>    <dbl> <dbl>   <dbl> <dbl> <dbl>    <dbl>         <dbl> #> 1 0          0  -0.154  2.33 0.846        1             1 #> 2 0.0101     0  -0.197  2.23 0.803        0             1 #> 3 0.0202     0  -0.240  2.14 0.760        2             1 #> 4 0.0303     0  -0.282  2.05 0.718        2             1 #> 5 0.0404     0  -0.325  1.96 0.675        3             1 #> 6 0.0505     0  -0.367  1.88 0.633        2             1  # sample 200 points for fitting: set.seed(1) sim_dat_obs <- sim_dat[sample(seq_len(nrow(sim_dat)), 200), ] ggplot(sim_dat, aes(X, Y)) +   geom_raster(aes(fill = exp(eta))) + # mean without observation error   geom_point(aes(size = observed), data = sim_dat_obs, pch = 21) +   scale_fill_viridis_c() +   scale_size_area() +   coord_cartesian(expand = FALSE) mesh <- make_mesh(sim_dat_obs, xy_cols = c(\"X\", \"Y\"), cutoff = 0.05) fit <- sdmTMB(   observed ~ 1,   data = sim_dat_obs,   mesh = mesh,   family = poisson() )"},{"path":"https://pbs-assess.github.io/sdmTMB/index.html","id":"simulating-from-an-existing-fit","dir":"","previous_headings":"Advanced functionality > Simulating data","what":"Simulating from an existing fit","title":"Spatial and Spatiotemporal SPDE-Based GLMMs with TMB","text":"Using simulations check DHARMa residuals:  See vignette Residual checking sdmTMB, ?simulate.sdmTMB, ?dharma_residuals details.","code":"s <- simulate(fit, nsim = 500) dim(s) #> [1] 969 500 s[1:3,1:4] #>      [,1]     [,2]     [,3]     [,4] #> [1,]    0 59.40310 83.20888  0.00000 #> [2,]    0 34.56408  0.00000 19.99839 #> [3,]    0  0.00000  0.00000  0.00000 # dharma_residuals(s, fit) # or with the pipe, %>%: simulate(fit, nsim = 500) %>%    dharma_residuals(fit)"},{"path":"https://pbs-assess.github.io/sdmTMB/index.html","id":"sampling-from-the-joint-precision-matrix","dir":"","previous_headings":"Advanced functionality","what":"Sampling from the joint precision matrix","title":"Spatial and Spatiotemporal SPDE-Based GLMMs with TMB","text":"can take samples implied parameter distribution assuming MVN covariance matrix internal parameterization:  See ?gather_sims ?get_index_sims details.","code":"samps <- gather_sims(fit, nsim = 1000) ggplot(samps, aes(.value)) + geom_histogram() +   facet_wrap(~.variable, scales = \"free_x\") #> `stat_bin()` using `bins = 30`. Pick better value with `binwidth`."},{"path":"https://pbs-assess.github.io/sdmTMB/index.html","id":"calculating-uncertainty-on-spatial-predictions","dir":"","previous_headings":"Advanced functionality","what":"Calculating uncertainty on spatial predictions","title":"Spatial and Spatiotemporal SPDE-Based GLMMs with TMB","text":"fastest way get point-wise prediction uncertainty use MVN samples:","code":"p <- predict(fit, newdata = predictor_dat, nsim = 500) predictor_dat$se <- apply(p, 1, sd) ggplot(predictor_dat, aes(X, Y, fill = se)) +   geom_raster() +   scale_fill_viridis_c(option = \"A\") +   coord_cartesian(expand = FALSE)"},{"path":"https://pbs-assess.github.io/sdmTMB/index.html","id":"cross-validation","dir":"","previous_headings":"Advanced functionality","what":"Cross validation","title":"Spatial and Spatiotemporal SPDE-Based GLMMs with TMB","text":"sdmTMB built-functionality cross-validation. set future::plan(), folds fit parallel: See ?sdmTMB_cv details.","code":"mesh <- make_mesh(pcod, c(\"X\", \"Y\"), cutoff = 10) ## Set parallel processing if desired: # library(future) # plan(multisession) m_cv <- sdmTMB_cv(   density ~ s(depth, k = 5),   data = pcod, mesh = mesh,   family = tweedie(link = \"log\"), k_folds = 2 ) #> Running fits with `future.apply()`. #> Set a parallel `future::plan()` to use parallel processing. # Sum of log likelihoods of left-out data: m_cv$sum_loglik #> [1] -7122.779 # Expected log pointwise predictive density from left-out data: # (average likelihood density) m_cv$elpd #> [1] -1.005114"},{"path":"https://pbs-assess.github.io/sdmTMB/index.html","id":"priors","dir":"","previous_headings":"Advanced functionality","what":"Priors","title":"Spatial and Spatiotemporal SPDE-Based GLMMs with TMB","text":"Priors/penalties can placed parameters. example, place PC (penalized complexity) prior Matérn random field parameters, standard normal prior effect depth, Normal(0, 10^2) prior intercept, half-normal prior Tweedie dispersion parameter (phi): can visualize PC Matérn prior:  See ?sdmTMBpriors details.","code":"mesh <- make_mesh(pcod, c(\"X\", \"Y\"), cutoff = 10) fit <- sdmTMB(   density ~ depth_scaled,   data = pcod, mesh = mesh,   family = tweedie(),   priors = sdmTMBpriors(     matern_s = pc_matern(range_gt = 10, sigma_lt = 5),     b = normal(c(0, 0), c(1, 10)),     phi = halfnormal(0, 15)   ) ) plot_pc_matern(range_gt = 10, sigma_lt = 5)"},{"path":"https://pbs-assess.github.io/sdmTMB/index.html","id":"bayesian-mcmc-sampling-with-stan","dir":"","previous_headings":"Advanced functionality","what":"Bayesian MCMC sampling with Stan","title":"Spatial and Spatiotemporal SPDE-Based GLMMs with TMB","text":"fitted model can passed tmbstan package sample posterior Stan. Note can slow large poorly identified models. See examples fixing parameters ?extract_mcmc. Internal parameter posteriors: Predicting Stan/tmbstan model: See ?extract_mcmc details.","code":"# only 1 chain and 400 iterations for speed: fit_mcmc <- tmbstan::tmbstan(fit$tmb_obj, chains = 1, iter = 400) print(fit_mcmc, pars = c(\"b_j\", \"omega_s[1]\")) #> Inference for Stan model: sdmTMB. #> 1 chains, each with iter=400; warmup=200; thin=1;  #> post-warmup draws per chain=200, total post-warmup draws=200. #>  #>             mean se_mean   sd  2.5%   25%   50%  75% 97.5% n_eff Rhat #> b_j         0.99    0.03 0.15  0.62  0.93  1.00 1.06  1.27    35 1.00 #> omega_s[1] -0.07    0.03 0.23 -0.50 -0.23 -0.06 0.10  0.33    63 1.01 #>  #> Samples were drawn using NUTS(diag_e). #> For each parameter, n_eff is a crude measure of effective sample size, #> and Rhat is the potential scale reduction factor on split chains (at  #> convergence, Rhat=1). pred_mcmc <- predict(fit, newdata = qcs_grid, tmbstan_model = fit_mcmc) # Each row has 200 posterior samples for a row of the `newdata` data frame: dim(pred_mcmc) #> [1] 65826   200"},{"path":"https://pbs-assess.github.io/sdmTMB/index.html","id":"turning-off-random-fields","dir":"","previous_headings":"Advanced functionality","what":"Turning off random fields","title":"Spatial and Spatiotemporal SPDE-Based GLMMs with TMB","text":"can turn random fields model comparison:","code":"fit_sdmTMB <- sdmTMB(   present ~ poly(depth_scaled, 2),   data = pcod, mesh = mesh,   spatial = \"off\",   family = binomial() ) fit_glm <- glm(   present ~ poly(depth_scaled, 2),   data = pcod,   family = binomial() )  tidy(fit_sdmTMB) #> # A tibble: 3 × 3 #>   term                   estimate std.error #>   <chr>                     <dbl>     <dbl> #> 1 (Intercept)              -0.426    0.0573 #> 2 poly(depth_scaled, 2)1  -31.7      3.03   #> 3 poly(depth_scaled, 2)2  -66.9      4.09 broom::tidy(fit_glm) #> # A tibble: 3 × 5 #>   term                   estimate std.error statistic  p.value #>   <chr>                     <dbl>     <dbl>     <dbl>    <dbl> #> 1 (Intercept)              -0.426    0.0573     -7.44 1.03e-13 #> 2 poly(depth_scaled, 2)1  -31.7      3.03      -10.5  1.20e-25 #> 3 poly(depth_scaled, 2)2  -66.9      4.09      -16.4  3.50e-60"},{"path":"https://pbs-assess.github.io/sdmTMB/index.html","id":"using-a-custom-inla-mesh","dir":"","previous_headings":"Advanced functionality","what":"Using a custom INLA mesh","title":"Spatial and Spatiotemporal SPDE-Based GLMMs with TMB","text":"Defining mesh directly INLA:","code":"bnd <- INLA::inla.nonconvex.hull(cbind(pcod$X, pcod$Y), convex = -0.1) mesh_inla <- INLA::inla.mesh.2d(   boundary = bnd,   max.edge = c(25, 50) ) mesh <- make_mesh(pcod, c(\"X\", \"Y\"), mesh = mesh_inla) plot(mesh) fit <- sdmTMB(   density ~ s(depth, k = 5),   data = pcod, mesh = mesh,   family = tweedie(link = \"log\") )"},{"path":"https://pbs-assess.github.io/sdmTMB/index.html","id":"barrier-meshes","dir":"","previous_headings":"Advanced functionality","what":"Barrier meshes","title":"Spatial and Spatiotemporal SPDE-Based GLMMs with TMB","text":"barrier mesh limits correlation across barriers (e.g., land water). See example ?add_barrier_mesh.","code":""},{"path":"https://pbs-assess.github.io/sdmTMB/reference/Effect.sdmTMB.html","id":null,"dir":"Reference","previous_headings":"","what":"Calculate effects — Effect.sdmTMB","title":"Calculate effects — Effect.sdmTMB","text":"Used effects package","code":""},{"path":"https://pbs-assess.github.io/sdmTMB/reference/Effect.sdmTMB.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Calculate effects — Effect.sdmTMB","text":"","code":"Effect.sdmTMB(focal.predictors, mod, ...)"},{"path":"https://pbs-assess.github.io/sdmTMB/reference/Effect.sdmTMB.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Calculate effects — Effect.sdmTMB","text":"focal.predictors character vector one predictors model order. mod regression model object.  specific method exists class mod, Effect.default called. ... arguments passed .","code":""},{"path":"https://pbs-assess.github.io/sdmTMB/reference/Effect.sdmTMB.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Calculate effects — Effect.sdmTMB","text":"Output effects::effect(). Can plotted associated plot() method.","code":""},{"path":"https://pbs-assess.github.io/sdmTMB/reference/Effect.sdmTMB.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Calculate effects — Effect.sdmTMB","text":"","code":"fit <- sdmTMB(present ~ depth_scaled, data = pcod_2011, family = binomial(),   spatial = \"off\") effects::effect(\"depth_scaled\", fit) #>  #>  depth_scaled effect #> depth_scaled #>        -3        -2      -0.1         1         3  #> 0.7511653 0.6634551 0.4673280 0.3544370 0.1897236  plot(effects::effect(\"depth_scaled\", fit))"},{"path":"https://pbs-assess.github.io/sdmTMB/reference/add_barrier_mesh.html","id":null,"dir":"Reference","previous_headings":"","what":"Transform a mesh object into a mesh with correlation barriers — add_barrier_mesh","title":"Transform a mesh object into a mesh with correlation barriers — add_barrier_mesh","text":"Transform mesh object mesh correlation barriers","code":""},{"path":"https://pbs-assess.github.io/sdmTMB/reference/add_barrier_mesh.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Transform a mesh object into a mesh with correlation barriers — add_barrier_mesh","text":"","code":"add_barrier_mesh(   spde_obj,   barrier_sf,   range_fraction = 0.2,   proj_scaling = 1,   plot = FALSE )"},{"path":"https://pbs-assess.github.io/sdmTMB/reference/add_barrier_mesh.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Transform a mesh object into a mesh with correlation barriers — add_barrier_mesh","text":"spde_obj Output make_mesh(). barrier_sf sf object polygons defining barriers. example, coastline dataset ocean data. Note object must projection data used generate x y columns spde_obj. range_fraction fraction spatial range barrier triangles . proj_scaling spde_obj created scaling coordinates projection (e.g., dividing UTMs 1000 spatial range reasonable scale) x y values spde_obj multiplied scaling factor applying projection barrier_sf. plot Logical.","code":""},{"path":"https://pbs-assess.github.io/sdmTMB/reference/add_barrier_mesh.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Transform a mesh object into a mesh with correlation barriers — add_barrier_mesh","text":"list similar make_mesh() spde_barrier couple helper list elements added. plot = TRUE, basic plot created side effect. grey dot represents center \"normal\" mesh triangle. red cross represents center \"barrier\" mesh triangle.","code":""},{"path":"https://pbs-assess.github.io/sdmTMB/reference/add_barrier_mesh.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Transform a mesh object into a mesh with correlation barriers — add_barrier_mesh","text":"Bakka, H., Vanhatalo, J., Illian, J., Simpson, D., Rue, H. 2019. Non-stationary Gaussian models physical barriers. https://arxiv.org/abs/1608.03787 https://sites.google.com//r-inla.org/www/barrier-model https://haakonbakkagit.github.io/btopic107.html","code":""},{"path":"https://pbs-assess.github.io/sdmTMB/reference/add_barrier_mesh.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Transform a mesh object into a mesh with correlation barriers — add_barrier_mesh","text":"","code":"if (require(\"sf\", quietly = TRUE) &&   require(\"ggplot2\", quietly = TRUE) &&   require(\"dplyr\", quietly = TRUE) &&   require(\"INLA\", quietly = TRUE)) {  # First, download coastline data for our region. # We will use `bc_coast` from the package data, # but you can recreate it with the following.  # For applied situations on finer scales, you may with to use scale = \"large\". # For that, first: remotes::install_github(\"ropensci/rnaturalearthhires\") # map_data <- rnaturalearth::ne_countries( #   scale = \"medium\", #   returnclass = \"sf\", country = \"canada\") # # # Crop the polygon for plotting and efficiency: # st_bbox(map_data) # bc_coast <- suppressWarnings(suppressMessages( #   st_crop(map_data, #     c(xmin = -134, ymin = 46, xmax = -120, ymax = 57))))  crs_utm9 <- 3156 # Pick a projection, here UTM9  st_crs(bc_coast) <- 4326 # 'WGS84'; necessary on some installs bc_coast <- st_transform(bc_coast, crs_utm9)  # Project our survey data coordinates: survey <- pcod %>% select(lon, lat, density) %>%   st_as_sf(crs = 4326, coords = c(\"lon\", \"lat\")) %>%   st_transform(crs_utm9)  # Plot our coast and survey data: ggplot(bc_coast) +   geom_sf() +   geom_sf(data = survey, size = 0.5)  # Note that a barrier mesh won't do much here for this # example data set, but we nonetheless use it as an example.  # Prepare for making the mesh # First, we will extract the coordinates: surv_utm_coords <- st_coordinates(survey)  # Then we will scale coordinates to km so the range parameter # is on a reasonable scale for estimation: pcod$X1000 <- surv_utm_coords[,1] / 1000 pcod$Y1000 <- surv_utm_coords[,2] / 1000  spde <- make_mesh(pcod, xy_cols = c(\"X1000\", \"Y1000\"),   n_knots = 200, type = \"kmeans\") plot(spde)  # Add on the barrier mesh component: bspde <- add_barrier_mesh(   spde, bc_coast, range_fraction = 0.1,   proj_scaling = 1000, plot = TRUE )  # In the above, the grey dots are the centre of triangles that are in the # ocean. The red crosses are centres of triangles that are over land. The # spatial range will be assumed to be 0.1 (`range_fraction`) over land compared # to over water.  # We can make a more advanced plot if we want: mesh_df_water <- bspde$mesh_sf[bspde$normal_triangles, ] mesh_df_land <- bspde$mesh_sf[bspde$barrier_triangles, ] ggplot(bc_coast) +   geom_sf() +   geom_sf(data = mesh_df_water, size = 1, colour = \"blue\") +   geom_sf(data = mesh_df_land, size = 1, colour = \"green\")  # Now, when we fit our model with the new mesh, it will automatically # include a barrier structure in the spatial correlation: fit <- sdmTMB(density ~ s(depth, k = 3), data = pcod, mesh = bspde,   family = tweedie(link = \"log\")) fit } #> Linking to GEOS 3.10.2, GDAL 3.4.1, PROJ 8.2.1; sf_use_s2() is TRUE #>  #> Attaching package: ‘dplyr’ #> The following objects are masked from ‘package:stats’: #>  #>     filter, lag #> The following objects are masked from ‘package:base’: #>  #>     intersect, setdiff, setequal, union #> This is INLA_22.12.16 built 2022-12-23 13:24:10 UTC. #>  - See www.r-inla.org/contact-us for how to get help. #>  - To enable PARDISO sparse library; see inla.pardiso()   #> Spatial model fit by ML ['sdmTMB'] #> Formula: density ~ s(depth, k = 3) #> Mesh: bspde (isotropic covariance) #> Data: pcod #> Family: tweedie(link = 'log') #>   #>             coef.est coef.se #> (Intercept)     2.06    0.21 #> sdepth          4.09    0.30 #>  #> Smooth terms: #>            Std. Dev. #> sds(depth)      60.2 #>  #> Dispersion parameter: 12.59 #> Tweedie p: 1.57 #> Matern range: 16.69 #> Spatial SD: 2.67 #> ML criterion at convergence: 6400.432 #>  #> See ?tidy.sdmTMB to extract these values as a data frame."},{"path":"https://pbs-assess.github.io/sdmTMB/reference/add_utm_columns.html","id":null,"dir":"Reference","previous_headings":"","what":"Add UTM coordinates to a data frame — add_utm_columns","title":"Add UTM coordinates to a data frame — add_utm_columns","text":"Add UTM (Universal Transverse Mercator) coordinates data frame. useful since geostatistical modeling generally performed equal-distance projection. can separately sf::st_as_sf(), sf::st_transform(), sf::st_coordinates() functions sf package.","code":""},{"path":"https://pbs-assess.github.io/sdmTMB/reference/add_utm_columns.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Add UTM coordinates to a data frame — add_utm_columns","text":"","code":"add_utm_columns(   dat,   ll_names = c(\"longitude\", \"latitude\"),   ll_crs = 4326,   utm_names = c(\"X\", \"Y\"),   utm_crs = get_crs(dat, ll_names),   units = c(\"km\", \"m\") )  get_crs(dat, ll_names = c(\"longitude\", \"latitude\"))"},{"path":"https://pbs-assess.github.io/sdmTMB/reference/add_utm_columns.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Add UTM coordinates to a data frame — add_utm_columns","text":"dat Data frame contains longitude latitude columns. ll_names Longitude latitude column names. Note order. ll_crs Input CRS value ll_names. utm_names Output column names UTM columns. utm_crs Output CRS value UTM zone; tries detect get_crs() can specified manually. units UTM units.","code":""},{"path":"https://pbs-assess.github.io/sdmTMB/reference/add_utm_columns.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Add UTM coordinates to a data frame — add_utm_columns","text":"copy input data frame new columns UTM coordinates.","code":""},{"path":"https://pbs-assess.github.io/sdmTMB/reference/add_utm_columns.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Add UTM coordinates to a data frame — add_utm_columns","text":"Note longitudes west prime meridian encoded running -180 0 degrees. may wish work km's rather standard UTM meters range parameter estimate small, can cause computational issues. depends scale data.","code":""},{"path":"https://pbs-assess.github.io/sdmTMB/reference/add_utm_columns.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Add UTM coordinates to a data frame — add_utm_columns","text":"","code":"d <- data.frame(lat = c(52.1, 53.4), lon = c(-130.0, -131.4)) get_crs(d, c(\"lon\", \"lat\")) #> Detected UTM zone 9N; CRS = 32609. #> Visit https://epsg.io/32609 to verify. #> [1] 32609 add_utm_columns(d, c(\"lon\", \"lat\")) #> Detected UTM zone 9N; CRS = 32609. #> Visit https://epsg.io/32609 to verify. #>    lat    lon        X        Y #> 1 52.1 -130.0 431.5034 5772.632 #> 2 53.4 -131.4 340.4411 5919.452"},{"path":"https://pbs-assess.github.io/sdmTMB/reference/bc_coast.html","id":null,"dir":"Reference","previous_headings":"","what":"BC coastline data from ropensci/rnaturalearthhires — bc_coast","title":"BC coastline data from ropensci/rnaturalearthhires — bc_coast","text":"BC coastline data ropensci/rnaturalearthhires","code":""},{"path":"https://pbs-assess.github.io/sdmTMB/reference/bc_coast.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"BC coastline data from ropensci/rnaturalearthhires — bc_coast","text":"","code":"bc_coast"},{"path":"https://pbs-assess.github.io/sdmTMB/reference/bc_coast.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"BC coastline data from ropensci/rnaturalearthhires — bc_coast","text":"sf data frame.","code":""},{"path":"https://pbs-assess.github.io/sdmTMB/reference/dharma_residuals.html","id":null,"dir":"Reference","previous_headings":"","what":"DHARMa residuals — dharma_residuals","title":"DHARMa residuals — dharma_residuals","text":"Plot (possibly return) DHARMa residuals. wrapper function around DHARMa::createDHARMa() facilitate use sdmTMB() models. Note: simulation testing suggests DHARMa residuals can suggest problems model fit even properly specified models presumably due Laplace approximation /spatially correlated random effects. Consider slower residuals.sdmTMB() type = \"mle-mcmc\".","code":""},{"path":"https://pbs-assess.github.io/sdmTMB/reference/dharma_residuals.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"DHARMa residuals — dharma_residuals","text":"","code":"dharma_residuals(simulated_response, object, plot = TRUE, ...)"},{"path":"https://pbs-assess.github.io/sdmTMB/reference/dharma_residuals.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"DHARMa residuals — dharma_residuals","text":"simulated_response Output simulate.sdmTMB(). object Output sdmTMB(). plot Logical. ... arguments pass DHARMa::createDHARMa().","code":""},{"path":"https://pbs-assess.github.io/sdmTMB/reference/dharma_residuals.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"DHARMa residuals — dharma_residuals","text":"data frame observed expected values invisibly returned, can set plot = FALSE assign output object wish plot residuals . See examples.","code":""},{"path":[]},{"path":"https://pbs-assess.github.io/sdmTMB/reference/dharma_residuals.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"DHARMa residuals — dharma_residuals","text":"","code":"if (inla_installed()) { fit <- sdmTMB(density ~ as.factor(year) + s(depth, k = 3),   data = pcod_2011, time = \"year\", mesh = pcod_mesh_2011,   family = tweedie(link = \"log\"), spatial = \"off\",   spatiotemporal = \"off\")  # The `simulated_response` argument is first so the output from # simulate() can be piped to dharma_residuals(): # simulate(fit, nsim = 500) %>% dharma_residuals(fit)  s <- simulate(fit, nsim = 500) dharma_residuals(s, fit) r <- dharma_residuals(s, fit, plot = FALSE) head(r) plot(r$expected, r$observed) abline(a = 0, b = 1) }"},{"path":"https://pbs-assess.github.io/sdmTMB/reference/emmeans.sdmTMB.html","id":null,"dir":"Reference","previous_headings":"","what":"Estimated marginal means with the emmeans package with sdmTMB — emmeans.sdmTMB","title":"Estimated marginal means with the emmeans package with sdmTMB — emmeans.sdmTMB","text":"Methods using emmeans package sdmTMB. emmeans package computes estimated marginal means fixed effects.","code":""},{"path":"https://pbs-assess.github.io/sdmTMB/reference/emmeans.sdmTMB.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Estimated marginal means with the emmeans package with sdmTMB — emmeans.sdmTMB","text":"https://aosmith.rbind.io/2019/03/25/getting-started--emmeans/","code":""},{"path":"https://pbs-assess.github.io/sdmTMB/reference/emmeans.sdmTMB.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Estimated marginal means with the emmeans package with sdmTMB — emmeans.sdmTMB","text":"","code":"mesh <- make_mesh(pcod_2011, c(\"X\", \"Y\"), cutoff = 20) fit <- sdmTMB(   present ~ as.factor(year),   data = pcod_2011, mesh = mesh,   family = binomial() ) fit #> Spatial model fit by ML ['sdmTMB'] #> Formula: present ~ as.factor(year) #> Mesh: mesh (isotropic covariance) #> Data: pcod_2011 #> Family: binomial(link = 'logit') #>   #>                     coef.est coef.se #> (Intercept)            -0.61    0.55 #> as.factor(year)2013     0.99    0.22 #> as.factor(year)2015     0.75    0.22 #> as.factor(year)2017     0.01    0.22 #>  #> Matern range: 48.45 #> Spatial SD: 1.84 #> ML criterion at convergence: 564.495 #>  #> See ?tidy.sdmTMB to extract these values as a data frame. emmeans::emmeans(fit, ~ year) #>  year emmean    SE  df lower.CL upper.CL #>  2011 -0.606 0.551 963   -1.688    0.475 #>  2013  0.384 0.550 963   -0.695    1.463 #>  2015  0.143 0.551 963   -0.937    1.224 #>  2017 -0.594 0.551 963   -1.674    0.487 #>  #> Results are given on the logit (not the response) scale.  #> Confidence level used: 0.95  emmeans::emmeans(fit, pairwise ~ year) #> $emmeans #>  year emmean    SE  df lower.CL upper.CL #>  2011 -0.606 0.551 963   -1.688    0.475 #>  2013  0.384 0.550 963   -0.695    1.463 #>  2015  0.143 0.551 963   -0.937    1.224 #>  2017 -0.594 0.551 963   -1.674    0.487 #>  #> Results are given on the logit (not the response) scale.  #> Confidence level used: 0.95  #>  #> $contrasts #>  contrast            estimate    SE  df t.ratio p.value #>  year2011 - year2013  -0.9901 0.222 963  -4.467  0.0001 #>  year2011 - year2015  -0.7496 0.220 963  -3.404  0.0039 #>  year2011 - year2017  -0.0127 0.221 963  -0.057  0.9999 #>  year2013 - year2015   0.2405 0.217 963   1.110  0.6838 #>  year2013 - year2017   0.9774 0.223 963   4.390  0.0001 #>  year2015 - year2017   0.7369 0.222 963   3.320  0.0052 #>  #> Results are given on the log odds ratio (not the response) scale.  #> P value adjustment: tukey method for comparing a family of 4 estimates  #>  emmeans::emmeans(fit, pairwise ~ year, type = \"response\") #> $emmeans #>  year  prob    SE  df lower.CL upper.CL #>  2011 0.353 0.126 963    0.156    0.617 #>  2013 0.595 0.133 963    0.333    0.812 #>  2015 0.536 0.137 963    0.281    0.773 #>  2017 0.356 0.126 963    0.158    0.619 #>  #> Confidence level used: 0.95  #> Intervals are back-transformed from the logit scale  #>  #> $contrasts #>  contrast            odds.ratio     SE  df null t.ratio p.value #>  year2011 / year2013      0.372 0.0823 963    1  -4.467  0.0001 #>  year2011 / year2015      0.473 0.1041 963    1  -3.404  0.0039 #>  year2011 / year2017      0.987 0.2182 963    1  -0.057  0.9999 #>  year2013 / year2015      1.272 0.2757 963    1   1.110  0.6838 #>  year2013 / year2017      2.658 0.5917 963    1   4.390  0.0001 #>  year2015 / year2017      2.089 0.4638 963    1   3.320  0.0052 #>  #> P value adjustment: tukey method for comparing a family of 4 estimates  #> Tests are performed on the log odds ratio scale  #>  emmeans::emmeans(fit, pairwise ~ year, adjust = \"none\") #> $emmeans #>  year emmean    SE  df lower.CL upper.CL #>  2011 -0.606 0.551 963   -1.688    0.475 #>  2013  0.384 0.550 963   -0.695    1.463 #>  2015  0.143 0.551 963   -0.937    1.224 #>  2017 -0.594 0.551 963   -1.674    0.487 #>  #> Results are given on the logit (not the response) scale.  #> Confidence level used: 0.95  #>  #> $contrasts #>  contrast            estimate    SE  df t.ratio p.value #>  year2011 - year2013  -0.9901 0.222 963  -4.467  <.0001 #>  year2011 - year2015  -0.7496 0.220 963  -3.404  0.0007 #>  year2011 - year2017  -0.0127 0.221 963  -0.057  0.9542 #>  year2013 - year2015   0.2405 0.217 963   1.110  0.2675 #>  year2013 - year2017   0.9774 0.223 963   4.390  <.0001 #>  year2015 - year2017   0.7369 0.222 963   3.320  0.0009 #>  #> Results are given on the log odds ratio (not the response) scale.  #>   e <- emmeans::emmeans(fit, ~ year) plot(e)   e <- emmeans::emmeans(fit, pairwise ~ year) confint(e) #> $emmeans #>  year emmean    SE  df lower.CL upper.CL #>  2011 -0.606 0.551 963   -1.688    0.475 #>  2013  0.384 0.550 963   -0.695    1.463 #>  2015  0.143 0.551 963   -0.937    1.224 #>  2017 -0.594 0.551 963   -1.674    0.487 #>  #> Results are given on the logit (not the response) scale.  #> Confidence level used: 0.95  #>  #> $contrasts #>  contrast            estimate    SE  df lower.CL upper.CL #>  year2011 - year2013  -0.9901 0.222 963   -1.560   -0.420 #>  year2011 - year2015  -0.7496 0.220 963   -1.316   -0.183 #>  year2011 - year2017  -0.0127 0.221 963   -0.581    0.556 #>  year2013 - year2015   0.2405 0.217 963   -0.317    0.798 #>  year2013 - year2017   0.9774 0.223 963    0.404    1.550 #>  year2015 - year2017   0.7369 0.222 963    0.166    1.308 #>  #> Results are given on the log odds ratio (not the response) scale.  #> Confidence level used: 0.95  #> Conf-level adjustment: tukey method for comparing a family of 4 estimates  #>  summary(e, infer = TRUE) #> $emmeans #>  year emmean    SE  df lower.CL upper.CL t.ratio p.value #>  2011 -0.606 0.551 963   -1.688    0.475  -1.100  0.2715 #>  2013  0.384 0.550 963   -0.695    1.463   0.698  0.4854 #>  2015  0.143 0.551 963   -0.937    1.224   0.260  0.7948 #>  2017 -0.594 0.551 963   -1.674    0.487  -1.078  0.2812 #>  #> Results are given on the logit (not the response) scale.  #> Confidence level used: 0.95  #>  #> $contrasts #>  contrast            estimate    SE  df lower.CL upper.CL t.ratio p.value #>  year2011 - year2013  -0.9901 0.222 963   -1.560   -0.420  -4.467  0.0001 #>  year2011 - year2015  -0.7496 0.220 963   -1.316   -0.183  -3.404  0.0039 #>  year2011 - year2017  -0.0127 0.221 963   -0.581    0.556  -0.057  0.9999 #>  year2013 - year2015   0.2405 0.217 963   -0.317    0.798   1.110  0.6838 #>  year2013 - year2017   0.9774 0.223 963    0.404    1.550   4.390  0.0001 #>  year2015 - year2017   0.7369 0.222 963    0.166    1.308   3.320  0.0052 #>  #> Results are given on the log odds ratio (not the response) scale.  #> Confidence level used: 0.95  #> Conf-level adjustment: tukey method for comparing a family of 4 estimates  #> P value adjustment: tukey method for comparing a family of 4 estimates  #>  as.data.frame(e) #>  year contrast             emmean    SE  df lower.CL upper.CL #>  2011 .                   -0.6064 0.551 963   -2.157    0.944 #>  2013 .                    0.3837 0.550 963   -1.163    1.931 #>  2015 .                    0.1432 0.551 963   -1.406    1.692 #>  2017 .                   -0.5937 0.551 963   -2.143    0.956 #>  .    year2011 - year2013 -0.9901 0.222 963   -1.614   -0.367 #>  .    year2011 - year2015 -0.7496 0.220 963   -1.369   -0.130 #>  .    year2011 - year2017 -0.0127 0.221 963   -0.634    0.609 #>  .    year2013 - year2015  0.2405 0.217 963   -0.369    0.850 #>  .    year2013 - year2017  0.9774 0.223 963    0.351    1.604 #>  .    year2015 - year2017  0.7369 0.222 963    0.112    1.361 #>  #> Results are given on the logit (not the response) scale.  #> Confidence level used: 0.95  #> Conf-level adjustment: bonferroni method for 10 estimates   # interaction of factor with continuous predictor: fit2 <- sdmTMB(   present ~ depth_scaled * as.factor(year),   data = pcod_2011, mesh = mesh,   family = binomial() ) fit2 #> Spatial model fit by ML ['sdmTMB'] #> Formula: present ~ depth_scaled * as.factor(year) #> Mesh: mesh (isotropic covariance) #> Data: pcod_2011 #> Family: binomial(link = 'logit') #>   #>                                  coef.est coef.se #> (Intercept)                         -0.75    0.48 #> depth_scaled                        -0.98    0.25 #> as.factor(year)2013                  1.03    0.23 #> as.factor(year)2015                  0.79    0.23 #> as.factor(year)2017                  0.01    0.23 #> depth_scaled:as.factor(year)2013    -0.16    0.26 #> depth_scaled:as.factor(year)2015     0.03    0.26 #> depth_scaled:as.factor(year)2017    -0.01    0.26 #>  #> Matern range: 33.38 #> Spatial SD: 2.19 #> ML criterion at convergence: 546.074 #>  #> See ?tidy.sdmTMB to extract these values as a data frame. # slopes for each level: emmeans::emtrends(fit2, ~ year, var = \"depth_scaled\") #>  year depth_scaled.trend    SE  df lower.CL upper.CL #>  2011             -0.980 0.250 959    -1.47   -0.490 #>  2013             -1.140 0.247 959    -1.63   -0.655 #>  2015             -0.950 0.238 959    -1.42   -0.483 #>  2017             -0.987 0.244 959    -1.47   -0.507 #>  #> Confidence level used: 0.95  # test difference in slopes: emmeans::emtrends(fit2, pairwise ~ year, var = \"depth_scaled\") #> $emtrends #>  year depth_scaled.trend    SE  df lower.CL upper.CL #>  2011             -0.980 0.250 959    -1.47   -0.490 #>  2013             -1.140 0.247 959    -1.63   -0.655 #>  2015             -0.950 0.238 959    -1.42   -0.483 #>  2017             -0.987 0.244 959    -1.47   -0.507 #>  #> Confidence level used: 0.95  #>  #> $contrasts #>  contrast            estimate    SE  df t.ratio p.value #>  year2011 - year2013  0.16009 0.261 959   0.613  0.9281 #>  year2011 - year2015 -0.03054 0.265 959  -0.115  0.9995 #>  year2011 - year2017  0.00651 0.261 959   0.025  1.0000 #>  year2013 - year2015 -0.19063 0.258 959  -0.738  0.8817 #>  year2013 - year2017 -0.15358 0.259 959  -0.593  0.9342 #>  year2015 - year2017  0.03705 0.263 959   0.141  0.9990 #>  #> P value adjustment: tukey method for comparing a family of 4 estimates  #>  emmeans::emmip(fit2, year ~ depth_scaled,   at = list(depth_scaled = seq(-2.5, 2.5, length.out = 50)), CIs = TRUE)"},{"path":[]},{"path":"https://pbs-assess.github.io/sdmTMB/reference/extract_mcmc.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Extract MCMC samples from a model fit with tmbstan::tmbstan(). — extract_mcmc","text":"","code":"extract_mcmc(object)"},{"path":"https://pbs-assess.github.io/sdmTMB/reference/extract_mcmc.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Extract MCMC samples from a model fit with tmbstan::tmbstan(). — extract_mcmc","text":"object Output tmbstan::tmbstan() run tmb_obj element sdmTMB() model. E.g., tmbstan(your_model$tmb_obj).","code":""},{"path":"https://pbs-assess.github.io/sdmTMB/reference/extract_mcmc.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Extract MCMC samples from a model fit with tmbstan::tmbstan(). — extract_mcmc","text":"Returns matrix parameter samples. Rows correspond order your_model$tmb_obj$env$last.par.best. Columns correspond posterior samples. used internally predict.sdmTMB() make fully Bayesian predictions. See tmbstan_model argument predict.sdmTMB().","code":""},{"path":"https://pbs-assess.github.io/sdmTMB/reference/extract_mcmc.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Extract MCMC samples from a model fit with tmbstan::tmbstan(). — extract_mcmc","text":"","code":"# \\donttest{ mesh <- make_mesh(pcod_2011, c(\"X\", \"Y\"), cutoff = 35) # quite coarse  # Fit with marginal maximum likelihood first:  fit <- sdmTMB(   density ~ 0 + as.factor(year),   data = pcod_2011, mesh = mesh,   family = tweedie(link = \"log\"),   priors = sdmTMBpriors(     matern_s = pc_matern(range_gt = 10, sigma_lt = 5),     matern_st = pc_matern(range_gt = 10, sigma_lt = 5),     b = normal(rep(0, 4), scale = rep(10, 4)) # 4 main effects   ),   time = \"year\" ) fit #> Spatiotemporal model fit by ML ['sdmTMB'] #> Formula: density ~ 0 + as.factor(year) #> Mesh: mesh (isotropic covariance) #> Time column: year #> Data: pcod_2011 #> Family: tweedie(link = 'log') #>   #>                     coef.est coef.se #> as.factor(year)2011     3.17    0.38 #> as.factor(year)2013     3.20    0.40 #> as.factor(year)2015     3.23    0.40 #> as.factor(year)2017     2.52    0.41 #>  #> Dispersion parameter: 15.89 #> Tweedie p: 1.59 #> Matern range: 21.80 #> Spatial SD: 2.56 #> Spatiotemporal SD: 1.35 #> ML criterion at convergence: 3057.095 #>  #> See ?tidy.sdmTMB to extract these values as a data frame.  # Create a 'map' vector for TMB to 'fix' kappa at the MLE value # to improve speed of convergence. # Factor NA values cause TMB to fix or map the parameter # at the starting value.  pars <- sdmTMB::get_pars(fit) kappa_map <- factor(rep(NA, length(pars$ln_kappa)))  # Rebuild model updating some elements: fit_mle <- update(   fit,   control = sdmTMBcontrol(     start = list(       ln_kappa = pars$ln_kappa     ),     map = list(       ln_kappa = kappa_map     )   ),   do_fit = FALSE # no need to actually fit ) #> ℹ Initiating `ln_kappa` at specified starting value(s) of: #> -2.042, -2.042 #> ℹ Fixing (mapping) `ln_kappa` at specified starting value(s) of: #> -2.042, -2.042  # Will take a few minutes: library(tmbstan) m_stan <- tmbstan(fit_mle$tmb_obj, iter = 100, chains = 1) #>  #> SAMPLING FOR MODEL 'tmb_generic' NOW (CHAIN 1). #> Chain 1:  #> Chain 1: Gradient evaluation took 0.004488 seconds #> Chain 1: 1000 transitions using 10 leapfrog steps per transition would take 44.88 seconds. #> Chain 1: Adjust your expectations accordingly! #> Chain 1:  #> Chain 1:  #> Chain 1: WARNING: There aren't enough warmup iterations to fit the #> Chain 1:          three stages of adaptation as currently configured. #> Chain 1:          Reducing each adaptation stage to 15%/75%/10% of #> Chain 1:          the given number of warmup iterations: #> Chain 1:            init_buffer = 7 #> Chain 1:            adapt_window = 38 #> Chain 1:            term_buffer = 5 #> Chain 1:  #> Chain 1: Iteration:  1 / 100 [  1%]  (Warmup) #> Chain 1: Iteration: 10 / 100 [ 10%]  (Warmup) #> Chain 1: Iteration: 20 / 100 [ 20%]  (Warmup) #> Chain 1: Iteration: 30 / 100 [ 30%]  (Warmup) #> Chain 1: Iteration: 40 / 100 [ 40%]  (Warmup) #> Chain 1: Iteration: 50 / 100 [ 50%]  (Warmup) #> Chain 1: Iteration: 51 / 100 [ 51%]  (Sampling) #> Chain 1: Iteration: 60 / 100 [ 60%]  (Sampling) #> Chain 1: Iteration: 70 / 100 [ 70%]  (Sampling) #> Chain 1: Iteration: 80 / 100 [ 80%]  (Sampling) #> Chain 1: Iteration: 90 / 100 [ 90%]  (Sampling) #> Chain 1: Iteration: 100 / 100 [100%]  (Sampling) #> Chain 1:  #> Chain 1:  Elapsed Time: 32.9148 seconds (Warm-up) #> Chain 1:                34.186 seconds (Sampling) #> Chain 1:                67.1008 seconds (Total) #> Chain 1:  #> Warning: The largest R-hat is 1.19, indicating chains have not mixed. #> Running the chains for more iterations may help. See #> https://mc-stan.org/misc/warnings.html#r-hat #> Warning: Bulk Effective Samples Size (ESS) is too low, indicating posterior means and medians may be unreliable. #> Running the chains for more iterations may help. See #> https://mc-stan.org/misc/warnings.html#bulk-ess #> Warning: Tail Effective Samples Size (ESS) is too low, indicating posterior variances and tail quantiles may be unreliable. #> Running the chains for more iterations may help. See #> https://mc-stan.org/misc/warnings.html#tail-ess print(   m_stan,   pars = c(\"b_j\", \"thetaf\", \"ln_phi\", \"omega_s[1]\", \"epsilon_st[1]\") ) #> Inference for Stan model: sdmTMB. #> 1 chains, each with iter=100; warmup=50; thin=1;  #> post-warmup draws per chain=50, total post-warmup draws=50. #>  #>                mean se_mean   sd  2.5%   25%   50%   75% 97.5% n_eff Rhat #> b_j[1]         3.27    0.07 0.42  2.35  3.05  3.27  3.53  4.02    36 1.13 #> b_j[2]         3.24    0.08 0.41  2.57  2.94  3.25  3.46  3.96    28 1.12 #> b_j[3]         3.20    0.06 0.43  2.28  3.01  3.24  3.53  3.81    47 1.08 #> b_j[4]         2.55    0.06 0.42  1.66  2.38  2.54  2.79  3.26    48 1.04 #> thetaf         0.38    0.01 0.06  0.26  0.33  0.39  0.43  0.47    85 0.98 #> ln_phi         2.76    0.00 0.04  2.71  2.73  2.76  2.78  2.84    57 1.00 #> omega_s[1]    -0.40    0.06 0.59 -1.31 -0.70 -0.45 -0.09  0.82    85 1.04 #> epsilon_st[1]  0.30    0.07 0.53 -0.46 -0.08  0.21  0.56  1.50    64 1.11 #>  #> Samples were drawn using NUTS(diag_e) at Thu Jan 19 22:30:43 2023. #> For each parameter, n_eff is a crude measure of effective sample size, #> and Rhat is the potential scale reduction factor on split chains (at  #> convergence, Rhat=1).  post <- extract_mcmc(m_stan) dim(post) #> [1] 223  50  nd <- subset(qcs_grid, year >= 2011) p <- predict(fit_mle, newdata = nd, tmbstan_model = m_stan) p_last <- p[nd$year == max(nd$year), ] # just plot last year pred <- qcs_grid[qcs_grid$year == max(qcs_grid$year), ] pred$est <- apply(exp(p_last), 1, median) pred$lwr <- apply(exp(p_last), 1, quantile, probs = 0.1) pred$upr <- apply(exp(p_last), 1, quantile, probs = 0.9) pred$cv <- apply(exp(p_last), 1, function(x) sd(x) / mean(x))  library(ggplot2) ggplot(pred, aes(X, Y, fill = est)) + geom_raster() +   scale_fill_viridis_c(trans = \"log\")  ggplot(pred, aes(X, Y, fill = cv)) + geom_raster() +   scale_fill_viridis_c(trans = \"log\")   index_quantiles <- get_index_sims(p) #> We generally recommend using `get_index(..., bias_correct = TRUE)` #> rather than `get_index_sims()`. ggplot(index_quantiles, aes(year, est, ymin = lwr, ymax = upr)) +   geom_line() + geom_ribbon(alpha = 0.5)   index_samples <- get_index_sims(p, return_sims = TRUE) #> We generally recommend using `get_index(..., bias_correct = TRUE)` #> rather than `get_index_sims()`. ggplot(index_samples, aes(as.factor(year), .value)) +   geom_violin()  # }"},{"path":"https://pbs-assess.github.io/sdmTMB/reference/families.html","id":null,"dir":"Reference","previous_headings":"","what":"Additional families — Families","title":"Additional families — Families","text":"Additional families compatible sdmTMB().","code":""},{"path":"https://pbs-assess.github.io/sdmTMB/reference/families.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Additional families — Families","text":"","code":"Beta(link = \"logit\")  lognormal(link = \"log\")  gamma_mix(link = \"log\")  lognormal_mix(link = \"log\")  nbinom2(link = \"log\")  nbinom1(link = \"log\")  truncated_nbinom2(link = \"log\")  truncated_nbinom1(link = \"log\")  student(link = \"identity\", df = 3)  tweedie(link = \"log\")  censored_poisson(link = \"log\")  delta_gamma(link1 = \"logit\", link2 = \"log\")  delta_gamma_mix(link1 = \"logit\", link2 = \"log\")  delta_lognormal(link1 = \"logit\", link2 = \"log\")  delta_lognormal_mix(link1 = \"logit\", link2 = \"log\")  delta_truncated_nbinom2(link1 = \"logit\", link2 = \"log\")  delta_truncated_nbinom1(link1 = \"logit\", link2 = \"log\")  delta_poisson_link_gamma(link1 = \"log\", link2 = \"log\")  delta_poisson_link_lognormal(link1 = \"log\", link2 = \"log\")  delta_beta(link1 = \"logit\", link2 = \"logit\")"},{"path":"https://pbs-assess.github.io/sdmTMB/reference/families.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Additional families — Families","text":"link Link. df Student-t degrees freedom fixed value parameter. link1 Link first part delta/hurdle model. link2 Link second part delta/hurdle model.","code":""},{"path":"https://pbs-assess.github.io/sdmTMB/reference/families.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Additional families — Families","text":"list elements common standard R family objects including family, link, linkfun, linkinv.","code":""},{"path":"https://pbs-assess.github.io/sdmTMB/reference/families.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Additional families — Families","text":"families ending _mix() 2-component mixtures distribution mean shared scale parameter. nbinom2 negative binomial parameterization NB2 variance grows quadratically mean (Hilbe 2011). nbinom1 negative binomial parameterization lets variance grow linearly mean (Hilbe 2011). student(), degrees freedom parameter currently estimated fixed df. delta_poisson_link_gamma() Poisson-link (complementary log-log) delta model (Thorson 2018). delta_poisson_link_lognormal() Poisson-link (complementary log-log) delta model (Thorson 2018).","code":""},{"path":"https://pbs-assess.github.io/sdmTMB/reference/families.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Additional families — Families","text":"Hilbe, J. M. (2011). Negative binomial regression. Cambridge University Press. Thorson, J. T. (2018). Three problems conventional delta-model biomass sampling data, computationally efficient alternative. Canadian Journal Fisheries Aquatic Sciences, 75(9), 1369-1382. doi:10.1139/cjfas-2017-0266","code":""},{"path":"https://pbs-assess.github.io/sdmTMB/reference/families.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Additional families — Families","text":"","code":"Beta(link = \"logit\") #>  #> Family: Beta  #> Link function: logit  #>  lognormal(link = \"log\") #>  #> Family: lognormal  #> Link function: log  #>  gamma_mix(link = \"log\") #>  #> Family: gamma_mix  #> Link function: log  #>  lognormal_mix(link = \"log\") #>  #> Family: lognormal_mix  #> Link function: log  #>  nbinom2(link = \"log\") #>  #> Family: nbinom2  #> Link function: log  #>  nbinom1(link = \"log\") #>  #> Family: nbinom1  #> Link function: log  #>  truncated_nbinom2(link = \"log\") #>  #> Family: truncated_nbinom2  #> Link function: log  #>  truncated_nbinom1(link = \"log\") #>  #> Family: truncated_nbinom1  #> Link function: log  #>  student(link = \"identity\") #>  #> Family: student  #> Link function: identity  #>  tweedie(link = \"log\") #>  #> Family: tweedie  #> Link function: log  #>  censored_poisson(link = \"log\") #>  #> Family: censored_poisson  #> Link function: log  #>  delta_gamma() #>  #> Family: binomial Gamma  #> Link function: logit log  #>  delta_gamma_mix() #>  #> Family: binomial gamma_mix  #> Link function: logit log  #>  delta_lognormal() #>  #> Family: binomial lognormal  #> Link function: logit log  #>  delta_lognormal_mix() #>  #> Family: binomial lognormal_mix  #> Link function: logit log  #>  delta_truncated_nbinom2() #>  #> Family: binomial truncated_nbinom2  #> Link function: logit log  #>  delta_truncated_nbinom1() #>  #> Family: binomial truncated_nbinom1  #> Link function: logit log  #>  delta_poisson_link_gamma() #>  #> Family: binomial Gamma  #> Link function: log log  #>  delta_poisson_link_lognormal() #>  #> Family: binomial lognormal  #> Link function: log log  #>  delta_beta() #>  #> Family: binomial Beta  #> Link function: logit logit  #>"},{"path":"https://pbs-assess.github.io/sdmTMB/reference/gather_sims.html","id":null,"dir":"Reference","previous_headings":"","what":"Extract parameter simulations from the joint precision matrix — spread_sims","title":"Extract parameter simulations from the joint precision matrix — spread_sims","text":"spread_sims() returns wide-format data frame. gather_sims() returns long-format data frame. format matches format tidybayes spread_draws() gather_draws() functions.","code":""},{"path":"https://pbs-assess.github.io/sdmTMB/reference/gather_sims.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Extract parameter simulations from the joint precision matrix — spread_sims","text":"","code":"spread_sims(object, nsim = 200, n_sims = deprecated())  gather_sims(object, nsim = 200, n_sims = deprecated())"},{"path":"https://pbs-assess.github.io/sdmTMB/reference/gather_sims.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Extract parameter simulations from the joint precision matrix — spread_sims","text":"object Output sdmTMB(). nsim number simulation draws. n_sims Deprecated: please use nsim.","code":""},{"path":"https://pbs-assess.github.io/sdmTMB/reference/gather_sims.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Extract parameter simulations from the joint precision matrix — spread_sims","text":"data frame. gather_sims() returns long-format data frame: .iteration: sample ID .variable: parameter name .value: parameter sample value spread_sims() returns wide-format data frame: .iteration: sample ID columns parameter sample per row","code":""},{"path":"https://pbs-assess.github.io/sdmTMB/reference/gather_sims.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Extract parameter simulations from the joint precision matrix — spread_sims","text":"","code":"m <- sdmTMB(density ~ 0 + depth_scaled + depth_scaled2,   data = pcod_2011, mesh = pcod_mesh_2011, family = tweedie(),   spatiotemporal = \"AR1\", time = \"year\") head(spread_sims(m, nsim = 10)) #>   .iteration depth_scaled depth_scaled2    range      phi tweedie_p   ar1_rho #> 1          1    -1.853368     -1.112498 58.93430 13.14827  1.560257 0.9143472 #> 2          2    -1.748583     -1.214493 60.36433 13.03163  1.565090 0.8961654 #> 3          3    -1.667642     -1.243943 71.31743 12.53397  1.557068 0.9085065 #> 4          4    -2.066448     -1.292050 56.91780 13.00500  1.553739 0.8649357 #> 5          5    -1.480406     -1.215753 62.47297 12.62660  1.583245 0.9351529 #> 6          6    -1.850197     -1.251386 50.50230 12.18955  1.560707 0.9031239 #>         sigma_O  sigma_E #> 1           Inf 3.064918 #> 2  9.234117e-10 2.438492 #> 3 1.187967e+131 2.361526 #> 4           Inf 2.681569 #> 5 8.760458e-149 2.622513 #> 6           Inf 3.271738 head(gather_sims(m, nsim = 10)) #>   .iteration    .variable    .value #> 1          1 depth_scaled -1.762952 #> 2          2 depth_scaled -1.813336 #> 3          3 depth_scaled -1.800826 #> 4          4 depth_scaled -1.788979 #> 5          5 depth_scaled -1.772511 #> 6          6 depth_scaled -2.086623 samps <- gather_sims(m, nsim = 1000)  if (require(\"ggplot2\", quietly = TRUE)) {   ggplot(samps, aes(.value)) + geom_histogram() +     facet_wrap(~.variable, scales = \"free_x\") } #> `stat_bin()` using `bins = 30`. Pick better value with `binwidth`. #> Warning: Removed 328 rows containing non-finite values (`stat_bin()`)."},{"path":"https://pbs-assess.github.io/sdmTMB/reference/get_index.html","id":null,"dir":"Reference","previous_headings":"","what":"Extract a relative biomass/abundance index or a center of gravity — get_index","title":"Extract a relative biomass/abundance index or a center of gravity — get_index","text":"Extract relative biomass/abundance index center gravity","code":""},{"path":"https://pbs-assess.github.io/sdmTMB/reference/get_index.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Extract a relative biomass/abundance index or a center of gravity — get_index","text":"","code":"get_index(   obj,   bias_correct = FALSE,   level = 0.95,   area = 1,   silent = TRUE,   ... )  get_cog(   obj,   bias_correct = FALSE,   level = 0.95,   format = c(\"long\", \"wide\"),   area = 1,   silent = TRUE,   ... )"},{"path":"https://pbs-assess.github.io/sdmTMB/reference/get_index.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Extract a relative biomass/abundance index or a center of gravity — get_index","text":"obj Output predict.sdmTMB() return_tmb_object = TRUE. bias_correct bias correction implemented TMB::sdreport()? level confidence level. area Grid cell area. vector length newdata predict.sdmTMB() value length 1, repeated internally match. silent Silent? ... Passed TMB::sdreport(). format Long wide.","code":""},{"path":"https://pbs-assess.github.io/sdmTMB/reference/get_index.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Extract a relative biomass/abundance index or a center of gravity — get_index","text":"get_index(): data frame columns time, estimate, lower upper confidence intervals, log estimate, standard error log estimate. get_cog(): data frame columns time, estimate (center gravity x y coordinates), lower upper confidence intervals, standard error center gravity coordinates.","code":""},{"path":"https://pbs-assess.github.io/sdmTMB/reference/get_index.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Extract a relative biomass/abundance index or a center of gravity — get_index","text":"Geostatistical random-field model-based indices abundance (along many newer papers): Shelton, .O., Thorson, J.T., Ward, E.J., Feist, B.E. 2014. Spatial semiparametric models improve estimates species abundance distribution. Canadian Journal Fisheries Aquatic Sciences 71(11): 1655--1666. doi:10.1139/cjfas-2013-0508 Thorson, J.T., Shelton, .O., Ward, E.J., Skaug, H.J. 2015. Geostatistical delta-generalized linear mixed models improve precision estimated abundance indices West Coast groundfishes. ICES J. Mar. Sci. 72(5): 1297–1310. doi:10.1093/icesjms/fsu243 Geostatistical model-based centre gravity: Thorson, J.T., Pinsky, M.L., Ward, E.J. 2016. Model-based inference estimating shifts species distribution, area occupied centre gravity. Methods Ecol Evol 7(8): 990–1002. doi:10.1111/2041-210X.12567 Bias correction: Thorson, J.T., Kristensen, K. 2016. Implementing generic method bias correction statistical models using random effects, spatial population dynamics examples. Fisheries Research 175: 66–74. doi:10.1016/j.fishres.2015.11.016","code":""},{"path":[]},{"path":"https://pbs-assess.github.io/sdmTMB/reference/get_index.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Extract a relative biomass/abundance index or a center of gravity — get_index","text":"","code":"# \\donttest{ # Use a small number of knots for this example to make it fast: pcod_spde <- make_mesh(pcod, c(\"X\", \"Y\"), n_knots = 60, type = \"kmeans\") m <- sdmTMB(  data = pcod,  formula = density ~ 0 + as.factor(year),  time = \"year\", mesh = pcod_spde, family = tweedie(link = \"log\") ) # Note `return_tmb_object = TRUE` and the prediction grid: predictions <- predict(m, newdata = qcs_grid, return_tmb_object = TRUE) ind <- get_index(predictions) #> Bias correction is turned off. #> It is recommended to turn this on for final inference.  if (require(\"ggplot2\", quietly = TRUE)) { ggplot(ind, aes(year, est)) + geom_line() +   geom_ribbon(aes(ymin = lwr, ymax = upr), alpha = 0.4) }   cog <- get_cog(predictions) cog #>    year       est       lwr       upr        se coord #> 1  2003  463.5260  446.4141  480.6380  8.730751     X #> 2  2004  476.7402  466.4506  487.0298  5.249898     X #> 3  2005  470.6887  457.7493  483.6281  6.601835     X #> 4  2007  480.8949  464.5560  497.2338  8.336336     X #> 5  2009  477.2028  457.9182  496.4874  9.839267     X #> 6  2011  470.5112  457.6004  483.4221  6.587303     X #> 7  2013  471.9877  455.6076  488.3677  8.357328     X #> 8  2015  463.0289  449.6441  476.4136  6.829060     X #> 9  2017  470.5220  455.4189  485.6251  7.705796     X #> 10 2003 5757.8611 5739.8545 5775.8677  9.187187     Y #> 11 2004 5732.5035 5720.8786 5744.1284  5.931175     Y #> 12 2005 5763.0315 5750.1526 5775.9105  6.571025     Y #> 13 2007 5738.2312 5716.8425 5759.6200 10.912838     Y #> 14 2009 5734.0287 5713.3605 5754.6970 10.545220     Y #> 15 2011 5747.1037 5733.6282 5760.5793  6.875406     Y #> 16 2013 5747.6447 5728.9691 5766.3204  9.528583     Y #> 17 2015 5753.9699 5736.8439 5771.0958  8.737907     Y #> 18 2017 5755.9729 5739.6443 5772.3016  8.331093     Y # }"},{"path":"https://pbs-assess.github.io/sdmTMB/reference/get_index_sims.html","id":null,"dir":"Reference","previous_headings":"","what":"Calculate a population index via simulation from the joint precision matrix — get_index_sims","title":"Calculate a population index via simulation from the joint precision matrix — get_index_sims","text":"Calculate population index via simulation joint precision matrix. Compared get_index(), version can faster bias correction turned get_index() approximately equivalent. experimental function. function usually works reasonably well, make guarantees. recommended use get_index() bias_correct = TRUE final inference.","code":""},{"path":"https://pbs-assess.github.io/sdmTMB/reference/get_index_sims.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Calculate a population index via simulation from the joint precision matrix — get_index_sims","text":"","code":"get_index_sims(   obj,   level = 0.95,   return_sims = FALSE,   area = rep(1, nrow(obj)),   est_function = stats::median,   area_function = function(x, area) x + log(area),   agg_function = function(x) sum(exp(x)) )"},{"path":"https://pbs-assess.github.io/sdmTMB/reference/get_index_sims.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Calculate a population index via simulation from the joint precision matrix — get_index_sims","text":"obj predict.sdmTMB() output nsim > 0. level confidence level. return_sims Logical. Return simulation draws? default (FALSE) quantile summary simulation draws. area vector grid cell/polyon areas year-grid cell (row data) obj. Adjust cells unit area area (e.g., cells partially land/water). Note area vector added log(area) raw values obj. words, function assumes log link, typically makes sense. est_function Function summarize estimate (expected value). mean() alternative median(). area_function Function apply area weighting. Assuming log link, function(x, area) x + log(area) default makes sense. natural space, function(x, area) x * area makes sense. agg_function Function aggregate samples within time slice. Assuming log link, function(x) sum(exp(x)) default makes sense. natural space, function(x) sum(x) makes sense.","code":""},{"path":"https://pbs-assess.github.io/sdmTMB/reference/get_index_sims.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Calculate a population index via simulation from the joint precision matrix — get_index_sims","text":"data frame. return_sims = FALSE: name column (e.g. year) supplied sdmTMB() time argument est: estimate lwr: lower confidence interval value upr: upper confidence interval value log_est: log estimate se: standard error log estimate return_sims = TRUE, samples index values long-format data frame: name column (e.g. year) supplied sdmTMB() time argument .value: sample value .iteration: sample number","code":""},{"path":"https://pbs-assess.github.io/sdmTMB/reference/get_index_sims.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Calculate a population index via simulation from the joint precision matrix — get_index_sims","text":"Can also used produce index model fit tmbstan. function nothing summarize reshape matrix simulation draws data frame.","code":""},{"path":[]},{"path":"https://pbs-assess.github.io/sdmTMB/reference/get_index_sims.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Calculate a population index via simulation from the joint precision matrix — get_index_sims","text":"","code":"if (inla_installed()) {  m <- sdmTMB(density ~ 0 + as.factor(year) + depth_scaled + depth_scaled2,   data = pcod_2011, mesh = pcod_mesh_2011, family = tweedie(link = \"log\"),   time = \"year\" ) qcs_grid_2011 <- subset(qcs_grid, year >= 2011) p <- predict(m, newdata = qcs_grid_2011, nsim = 100) x <- get_index_sims(p) x_sims <- get_index_sims(p, return_sims = TRUE)  if (require(\"ggplot2\", quietly = TRUE)) {   ggplot(x, aes(year, est, ymin = lwr, ymax = upr)) +     geom_line() +     geom_ribbon(alpha = 0.4)   ggplot(x_sims, aes(as.factor(year), .value)) +     geom_violin() }  # Demo custom functions if working in natural space: ind <- get_index_sims(   exp(p),   agg_function = function(x) sum(x),   area_function = function(x, area) x * area ) } #> We generally recommend using `get_index(..., bias_correct = TRUE)` #> rather than `get_index_sims()`. #> We generally recommend using `get_index(..., bias_correct = TRUE)` #> rather than `get_index_sims()`. #> We generally recommend using `get_index(..., bias_correct = TRUE)` #> rather than `get_index_sims()`."},{"path":"https://pbs-assess.github.io/sdmTMB/reference/get_pars.html","id":null,"dir":"Reference","previous_headings":"","what":"Get TMB parameter list — get_pars","title":"Get TMB parameter list — get_pars","text":"Get TMB parameter list","code":""},{"path":"https://pbs-assess.github.io/sdmTMB/reference/get_pars.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Get TMB parameter list — get_pars","text":"","code":"get_pars(object)"},{"path":"https://pbs-assess.github.io/sdmTMB/reference/get_pars.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Get TMB parameter list — get_pars","text":"object Fit sdmTMB()","code":""},{"path":"https://pbs-assess.github.io/sdmTMB/reference/get_pars.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Get TMB parameter list — get_pars","text":"named list parameter values","code":""},{"path":"https://pbs-assess.github.io/sdmTMB/reference/get_pars.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Get TMB parameter list — get_pars","text":"","code":"fit <- sdmTMB(present ~ 1, data = pcod_2011, family = binomial(), spatial = \"off\") pars <- get_pars(fit) names(pars) #>  [1] \"ln_H_input\"          \"b_j\"                 \"b_j2\"                #>  [4] \"bs\"                  \"ln_tau_O\"            \"ln_tau_Z\"            #>  [7] \"ln_tau_E\"            \"ln_kappa\"            \"thetaf\"              #> [10] \"logit_p_mix\"         \"log_ratio_mix\"       \"ln_phi\"              #> [13] \"ln_tau_V\"            \"rho_time_unscaled\"   \"ar1_phi\"             #> [16] \"ln_tau_G\"            \"RE\"                  \"b_rw_t\"              #> [19] \"omega_s\"             \"zeta_s\"              \"epsilon_st\"          #> [22] \"b_threshold\"         \"b_epsilon\"           \"ln_epsilon_re_sigma\" #> [25] \"epsilon_re\"          \"b_smooth\"            \"ln_smooth_sigma\""},{"path":"https://pbs-assess.github.io/sdmTMB/reference/ggplot2_installed.html","id":null,"dir":"Reference","previous_headings":"","what":"Check if ggplot2 installed — ggplot2_installed","title":"Check if ggplot2 installed — ggplot2_installed","text":"Check ggplot2 installed","code":""},{"path":"https://pbs-assess.github.io/sdmTMB/reference/ggplot2_installed.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Check if ggplot2 installed — ggplot2_installed","text":"","code":"ggplot2_installed()"},{"path":"https://pbs-assess.github.io/sdmTMB/reference/ggplot2_installed.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Check if ggplot2 installed — ggplot2_installed","text":"Returns TRUE FALSE.","code":""},{"path":"https://pbs-assess.github.io/sdmTMB/reference/inla_installed.html","id":null,"dir":"Reference","previous_headings":"","what":"Check if INLA installed (i.e., not on CRAN) — inla_installed","title":"Check if INLA installed (i.e., not on CRAN) — inla_installed","text":"Check INLA installed (.e., CRAN)","code":""},{"path":"https://pbs-assess.github.io/sdmTMB/reference/inla_installed.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Check if INLA installed (i.e., not on CRAN) — inla_installed","text":"","code":"inla_installed()"},{"path":"https://pbs-assess.github.io/sdmTMB/reference/inla_installed.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Check if INLA installed (i.e., not on CRAN) — inla_installed","text":"Returns TRUE FALSE.","code":""},{"path":"https://pbs-assess.github.io/sdmTMB/reference/make_mesh.html","id":null,"dir":"Reference","previous_headings":"","what":"Construct an SPDE mesh for sdmTMB — make_mesh","title":"Construct an SPDE mesh for sdmTMB — make_mesh","text":"Construct SPDE mesh use sdmTMB.","code":""},{"path":"https://pbs-assess.github.io/sdmTMB/reference/make_mesh.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Construct an SPDE mesh for sdmTMB — make_mesh","text":"","code":"make_mesh(   data,   xy_cols,   type = c(\"kmeans\", \"cutoff\", \"cutoff_search\"),   cutoff,   n_knots,   seed = 42,   refine = list(min.angle = 21, max.edge = Inf, max.n.strict = -1, max.n = 1000),   mesh = NULL )  # S3 method for sdmTMBmesh plot(x, ...)"},{"path":"https://pbs-assess.github.io/sdmTMB/reference/make_mesh.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Construct an SPDE mesh for sdmTMB — make_mesh","text":"data data frame. xy_cols character vector x y column names contained data. likely equal distance projection. helper function convert UTMs, see add_utm_columns(). type Method create mesh. Also see mesh argument supply mesh. cutoff optional cutoff type \"cutoff\". \"minimum allowed distance points mesh\". See INLA::inla.mesh.create(). Smaller values create meshes knots. Points apart value receive separate vertex mesh mesh refinement. n_knots number desired knots type \"cutoff\". seed Random seed. Affects stats::kmeans() determination knot locations type = \"kmeans\". refine Logical list pass INLA::inla.mesh.create(). mesh optional mesh created via INLA instead using convenience options. x Output make_mesh(). ... Passed graphics::plot().","code":""},{"path":"https://pbs-assess.github.io/sdmTMB/reference/make_mesh.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Construct an SPDE mesh for sdmTMB — make_mesh","text":"make_mesh(): list class sdmTMBmesh. element mesh output INLA::inla.mesh.create() element spde output INLA::inla.spde2.matern(). plot.sdmTMB(): plot mesh data points.","code":""},{"path":"https://pbs-assess.github.io/sdmTMB/reference/make_mesh.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Construct an SPDE mesh for sdmTMB — make_mesh","text":"","code":"mesh <- make_mesh(pcod, c(\"X\", \"Y\"), cutoff = 30, type = \"cutoff\") plot(mesh)   # \\donttest{ mesh <- make_mesh(pcod, c(\"X\", \"Y\"), cutoff = 5, type = \"cutoff\") plot(mesh)   mesh <- make_mesh(pcod, c(\"X\", \"Y\"), n_knots = 50, type = \"cutoff_search\") #> cutoff = 1.00 | knots = 2641 | ↓  #> cutoff = 100.00 | knots = 26 | ↑  #> cutoff = 10.00 | knots = 205 | ↓  #> cutoff = 31.62 | knots = 49 | ↑  #> cutoff = 17.78 | knots = 89 | ↓  #> cutoff = 23.71 | knots = 61 | ↓  #> cutoff = 27.38 | knots = 53 | ↓  #> cutoff = 29.43 | knots = 50 | ✔  plot(mesh)   mesh <- make_mesh(pcod, c(\"X\", \"Y\"), n_knots = 50, type = \"kmeans\") plot(mesh)   # Defining a mesh directly with INLA: bnd <- INLA::inla.nonconvex.hull(cbind(pcod$X, pcod$Y), convex = -0.05) inla_mesh <- INLA::inla.mesh.2d(   boundary = bnd,   max.edge = c(20, 50),   offset = -0.05,   cutoff = c(2, 5),   min.angle = 10 ) mesh <- make_mesh(pcod, c(\"X\", \"Y\"), mesh = inla_mesh) plot(mesh)  # }"},{"path":"https://pbs-assess.github.io/sdmTMB/reference/pcod.html","id":null,"dir":"Reference","previous_headings":"","what":"Example data for Pacific Cod — pcod","title":"Example data for Pacific Cod — pcod","text":"Example data Pacific Cod","code":""},{"path":"https://pbs-assess.github.io/sdmTMB/reference/pcod.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Example data for Pacific Cod — pcod","text":"","code":"pcod"},{"path":"https://pbs-assess.github.io/sdmTMB/reference/pcod.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"Example data for Pacific Cod — pcod","text":"data frame.","code":""},{"path":"https://pbs-assess.github.io/sdmTMB/reference/pcod_2011.html","id":null,"dir":"Reference","previous_headings":"","what":"Example data for Pacific Cod (years 2011 and after) — pcod_2011","title":"Example data for Pacific Cod (years 2011 and after) — pcod_2011","text":"Example data Pacific Cod (years 2011 )","code":""},{"path":"https://pbs-assess.github.io/sdmTMB/reference/pcod_2011.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Example data for Pacific Cod (years 2011 and after) — pcod_2011","text":"","code":"pcod_2011"},{"path":"https://pbs-assess.github.io/sdmTMB/reference/pcod_2011.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"Example data for Pacific Cod (years 2011 and after) — pcod_2011","text":"data frame.","code":""},{"path":"https://pbs-assess.github.io/sdmTMB/reference/pcod_mesh_2011.html","id":null,"dir":"Reference","previous_headings":"","what":"Example SPDE mesh for the Pacific Cod data (years 2011 and after) — pcod_mesh_2011","title":"Example SPDE mesh for the Pacific Cod data (years 2011 and after) — pcod_mesh_2011","text":"Example SPDE mesh Pacific Cod data (years 2011 )","code":""},{"path":"https://pbs-assess.github.io/sdmTMB/reference/pcod_mesh_2011.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Example SPDE mesh for the Pacific Cod data (years 2011 and after) — pcod_mesh_2011","text":"","code":"pcod_mesh_2011"},{"path":"https://pbs-assess.github.io/sdmTMB/reference/pcod_mesh_2011.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"Example SPDE mesh for the Pacific Cod data (years 2011 and after) — pcod_mesh_2011","text":"list object class sdmTMBmesh.","code":""},{"path":"https://pbs-assess.github.io/sdmTMB/reference/plot_anisotropy.html","id":null,"dir":"Reference","previous_headings":"","what":"Plot anisotropy from an sdmTMB model — plot_anisotropy","title":"Plot anisotropy from an sdmTMB model — plot_anisotropy","text":"Anisotropy spatial correlation directionally dependent. sdmTMB(), default spatial correlation isotropic, anisotropy can enabled anisotropy = TRUE. plotting functions help visualize estimated anisotropy.","code":""},{"path":"https://pbs-assess.github.io/sdmTMB/reference/plot_anisotropy.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Plot anisotropy from an sdmTMB model — plot_anisotropy","text":"","code":"plot_anisotropy(object, return_data = FALSE)  plot_anisotropy2(object, model = 1)"},{"path":"https://pbs-assess.github.io/sdmTMB/reference/plot_anisotropy.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Plot anisotropy from an sdmTMB model — plot_anisotropy","text":"object object sdmTMB(). return_data Logical. Return data frame? plot_anisotropy() . model model delta model (plot_anisotropy2(); plot_anisotropy() always plots ).","code":""},{"path":"https://pbs-assess.github.io/sdmTMB/reference/plot_anisotropy.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Plot anisotropy from an sdmTMB model — plot_anisotropy","text":"plot_anisotropy(): One ellipses illustrating estimated anisotropy. ellipses centered coordinates zero space X-Y coordinates modeled. ellipses show spatial /spatiotemporal range (distance correlation effectively independent) direction zero. Uses ggplot2. plot_anisotropy2(): plot eigenvectors illustrating estimated anisotropy. list plotted data invisibly returned. Uses base graphics.","code":""},{"path":"https://pbs-assess.github.io/sdmTMB/reference/plot_anisotropy.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Plot anisotropy from an sdmTMB model — plot_anisotropy","text":"Code adapted VAST R package","code":""},{"path":"https://pbs-assess.github.io/sdmTMB/reference/plot_anisotropy.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Plot anisotropy from an sdmTMB model — plot_anisotropy","text":"","code":"mesh <- make_mesh(pcod_2011, c(\"X\", \"Y\"), n_knots = 80, type = \"kmeans\") fit <- sdmTMB(   data = pcod_2011,   formula = density ~ 1,   mesh = mesh,   family = tweedie(),   share_range = FALSE,   time = \"year\",   anisotropy = TRUE #< ) plot_anisotropy(fit)  plot_anisotropy2(fit)"},{"path":"https://pbs-assess.github.io/sdmTMB/reference/plot_pc_matern.html","id":null,"dir":"Reference","previous_headings":"","what":"Plot PC Matern priors — plot_pc_matern","title":"Plot PC Matern priors — plot_pc_matern","text":"Plot PC Matern priors","code":""},{"path":"https://pbs-assess.github.io/sdmTMB/reference/plot_pc_matern.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Plot PC Matern priors — plot_pc_matern","text":"","code":"plot_pc_matern(   range_gt,   sigma_lt,   range_prob = 0.05,   sigma_prob = 0.05,   range_lims = c(range_gt * 0.1, range_gt * 10),   sigma_lims = c(0, sigma_lt * 2),   plot = TRUE )"},{"path":"https://pbs-assess.github.io/sdmTMB/reference/plot_pc_matern.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Plot PC Matern priors — plot_pc_matern","text":"range_gt value one expects spatial spatiotemporal range greater 1 - range_prob probability. sigma_lt value one expects spatial spatiotemporal marginal standard deviation (sigma_O sigma_E internally) less 1 - sigma_prob probability. range_prob Probability. See description range_gt. sigma_prob Probability. See description sigma_lt. range_lims Plot range variable limits. sigma_lims Plot sigma variable limits. plot Logical controlling whether plot drawn (defaults TRUE).","code":""},{"path":"https://pbs-assess.github.io/sdmTMB/reference/plot_pc_matern.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Plot PC Matern priors — plot_pc_matern","text":"plot image(). Invisibly returns underlying matrix data. rows sigmas. columns ranges. Column row names provided.","code":""},{"path":[]},{"path":"https://pbs-assess.github.io/sdmTMB/reference/plot_pc_matern.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Plot PC Matern priors — plot_pc_matern","text":"","code":"plot_pc_matern(range_gt = 5, sigma_lt = 1)  plot_pc_matern(range_gt = 5, sigma_lt = 10)  plot_pc_matern(range_gt = 5, sigma_lt = 1, sigma_prob = 0.2)  plot_pc_matern(range_gt = 5, sigma_lt = 1, range_prob = 0.2)"},{"path":"https://pbs-assess.github.io/sdmTMB/reference/plot_smooth.html","id":null,"dir":"Reference","previous_headings":"","what":"Plot a smooth term from an sdmTMB model — plot_smooth","title":"Plot a smooth term from an sdmTMB model — plot_smooth","text":"Deprecated: use visreg::visreg(). See visreg_delta() examples.","code":""},{"path":"https://pbs-assess.github.io/sdmTMB/reference/plot_smooth.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Plot a smooth term from an sdmTMB model — plot_smooth","text":"","code":"plot_smooth(   object,   select = 1,   n = 100,   level = 0.95,   ggplot = FALSE,   rug = TRUE,   return_data = FALSE )"},{"path":"https://pbs-assess.github.io/sdmTMB/reference/plot_smooth.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Plot a smooth term from an sdmTMB model — plot_smooth","text":"object sdmTMB() model. select smoother term plot. n number equally spaced points evaluate smoother along. level confidence level. ggplot Logical: use ggplot2 package? rug Logical: add rug lines along lower axis? return_data Logical: return predicted data instead making plot?","code":""},{"path":"https://pbs-assess.github.io/sdmTMB/reference/plot_smooth.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Plot a smooth term from an sdmTMB model — plot_smooth","text":"plot smoother term.","code":""},{"path":"https://pbs-assess.github.io/sdmTMB/reference/plot_smooth.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Plot a smooth term from an sdmTMB model — plot_smooth","text":"Note: numeric predictor set mean factor predictor set first-level value time element (present) set minimum value x y coordinates set mean values","code":""},{"path":"https://pbs-assess.github.io/sdmTMB/reference/plot_smooth.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Plot a smooth term from an sdmTMB model — plot_smooth","text":"","code":"if (inla_installed()) {   d <- subset(pcod, year >= 2000 & density > 0)   pcod_spde <- make_mesh(d, c(\"X\", \"Y\"), cutoff = 30)   m <- sdmTMB(     data = d,     formula = log(density) ~ s(depth_scaled) + s(year, k = 5),     mesh = pcod_spde   )   plot_smooth(m) } #> This function may be deprecated. #> Consider using `visreg::visreg()` or `visreg_delta()`. #> See ?visreg_delta() for examples."},{"path":"https://pbs-assess.github.io/sdmTMB/reference/predict.sdmTMB.html","id":null,"dir":"Reference","previous_headings":"","what":"Predict from an sdmTMB model — predict.sdmTMB","title":"Predict from an sdmTMB model — predict.sdmTMB","text":"Make predictions sdmTMB model; can predict original new data.","code":""},{"path":"https://pbs-assess.github.io/sdmTMB/reference/predict.sdmTMB.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Predict from an sdmTMB model — predict.sdmTMB","text":"","code":"# S3 method for sdmTMB predict(   object,   newdata = object$data,   type = c(\"link\", \"response\"),   se_fit = FALSE,   re_form = NULL,   re_form_iid = NULL,   nsim = 0,   sims_var = \"est\",   model = c(NA, 1, 2),   offset = NULL,   tmbstan_model = NULL,   return_tmb_object = FALSE,   return_tmb_report = FALSE,   return_tmb_data = FALSE,   sims = deprecated(),   area = deprecated(),   ... )"},{"path":"https://pbs-assess.github.io/sdmTMB/reference/predict.sdmTMB.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Predict from an sdmTMB model — predict.sdmTMB","text":"object model fitted sdmTMB(). newdata data frame make predictions . data frame predictor columns fitted data time column (spatiotemporal model) name fitted data. type est column link (default) response space? se_fit standard errors predictions new locations given newdata calculated? Warning: current implementation can slow large data sets high-resolution projections unless re_form = NA (omitting random fields). faster option approximate point-wise uncertainty may use nsim argument. re_form NULL specify including spatial/spatiotemporal random effects predictions. ~0 NA population-level predictions. Likely used conjunction se_fit = TRUE. affect get_index() calculations. re_form_iid NULL specify including random intercepts predictions. ~0 NA population-level predictions. options (e.g., random intercepts) implemented yet. affects predictions newdata. affects get_index(). nsim Experimental: > 0, simulate joint precision matrix nsim draws. Returns matrix nrow(data) nsim representing estimates linear predictor (.e., link space). Can useful deriving uncertainty predictions (e.g., apply(x, 1, sd)) propagating uncertainty. currently fastest way characterize uncertainty predictions space sdmTMB. sims_var Experimental: TMB reported variable model extracted joint precision matrix simulation draws? Defaults link-space predictions. Options include: \"omega_s\", \"zeta_s\", \"epsilon_st\", \"est_rf\" (described ). options passed verbatim. model Type prediction delta/hurdle model nsim > 0 tmbstan_model supplied: NA returns combined prediction components link scale positive component; 1 2 return first second model component link response scale depending argument type. offset numeric vector optional offset values. left default NULL, offset implicitly left 0. tmbstan_model model fit tmbstan::tmbstan(). See extract_mcmc() details example. specified, predict function return matrix similar form nsim > 0 representing Bayesian posterior samples Stan model. return_tmb_object Logical. TRUE, include TMB object list format output. Necessary get_index() get_cog() functions. return_tmb_report Logical: return output TMB report? regular prediction reported variables MLE parameter values. nsim > 0 tmbstan_model supplied, list element sample contents element output report sample. return_tmb_data Logical: return formatted data TMB? Used internally. sims Deprecated. Please use nsim instead. area Deprecated. Please use area get_index(). ... implemented.","code":""},{"path":"https://pbs-assess.github.io/sdmTMB/reference/predict.sdmTMB.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Predict from an sdmTMB model — predict.sdmTMB","text":"return_tmb_object = FALSE (nsim = 0 tmbstan_model = NULL): data frame: est: Estimate link space (everything link space) est_non_rf: Estimate everything random field est_rf: Estimate random fields combined omega_s: Spatial (intercept) random field constant time zeta_s: Spatial slope random field epsilon_st: Spatiotemporal (intercept) random fields, (zero), IID, AR1, random walk return_tmb_object = TRUE (nsim = 0 tmbstan_model = NULL): list: data: data frame described report: TMB report parameter values obj: TMB object returned prediction run fit_obj: original TMB model object case, likely need data element end user. elements included functions. nsim > 0 tmbstan_model NULL: matrix: Columns represent samples Rows represent predictions one row per row newdata","code":""},{"path":"https://pbs-assess.github.io/sdmTMB/reference/predict.sdmTMB.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Predict from an sdmTMB model — predict.sdmTMB","text":"","code":"d <- pcod_2011 mesh <- make_mesh(d, c(\"X\", \"Y\"), cutoff = 30) # a coarse mesh for example speed m <- sdmTMB(  data = d, formula = density ~ 0 + as.factor(year) + depth_scaled + depth_scaled2,  time = \"year\", mesh = mesh, family = tweedie(link = \"log\") )  # Predictions at original data locations -------------------------------  predictions <- predict(m) head(predictions) #> # A tibble: 6 × 17 #>    year     X     Y depth density present   lat   lon depth_mean depth…¹ depth…² #>   <int> <dbl> <dbl> <dbl>   <dbl>   <dbl> <dbl> <dbl>      <dbl>   <dbl>   <dbl> #> 1  2011  435. 5718.   241    245.       1  51.6 -130.       5.16   0.445   0.741 #> 2  2011  487. 5719.    52      0        0  51.6 -129.       5.16   0.445  -2.71  #> 3  2011  490. 5717.    47      0        0  51.6 -129.       5.16   0.445  -2.93  #> 4  2011  545. 5717.   157      0        0  51.6 -128.       5.16   0.445  -0.222 #> 5  2011  404. 5720.   398      0        0  51.6 -130.       5.16   0.445   1.87  #> 6  2011  420. 5721.   486      0        0  51.6 -130.       5.16   0.445   2.32  #> # … with 6 more variables: depth_scaled2 <dbl>, est <dbl>, est_non_rf <dbl>, #> #   est_rf <dbl>, omega_s <dbl>, epsilon_st <dbl>, and abbreviated variable #> #   names ¹​depth_sd, ²​depth_scaled  predictions$resids <- residuals(m) # randomized quantile residuals  library(ggplot2) ggplot(predictions, aes(X, Y, col = resids)) + scale_colour_gradient2() +   geom_point() + facet_wrap(~year)  hist(predictions$resids)  qqnorm(predictions$resids);abline(a = 0, b = 1)   # Predictions onto new data --------------------------------------------  qcs_grid_2011 <- subset(qcs_grid, year >= min(pcod_2011$year)) predictions <- predict(m, newdata = qcs_grid_2011)  # A short function for plotting our predictions: plot_map <- function(dat, column = est) {   ggplot(dat, aes(X, Y, fill = {{ column }})) +     geom_raster() +     facet_wrap(~year) +     coord_fixed() }  plot_map(predictions, exp(est)) +   scale_fill_viridis_c(trans = \"sqrt\") +   ggtitle(\"Prediction (fixed effects + all random effects)\")   plot_map(predictions, exp(est_non_rf)) +   ggtitle(\"Prediction (fixed effects and any time-varying effects)\") +   scale_fill_viridis_c(trans = \"sqrt\")   plot_map(predictions, est_rf) +   ggtitle(\"All random field estimates\") +   scale_fill_gradient2()   plot_map(predictions, omega_s) +   ggtitle(\"Spatial random effects only\") +   scale_fill_gradient2()   plot_map(predictions, epsilon_st) +   ggtitle(\"Spatiotemporal random effects only\") +   scale_fill_gradient2()   # Visualizing a marginal effect ----------------------------------------  # See the visreg package or the ggeffects::ggeffect() function # To do this manually:  nd <- data.frame(depth_scaled =   seq(min(d$depth_scaled), max(d$depth_scaled), length.out = 100)) nd$depth_scaled2 <- nd$depth_scaled^2  # Because this is a spatiotemporal model, you'll need at least one time # element. If time isn't also a fixed effect then it doesn't matter what you pick: nd$year <- 2011L # L: integer to match original data p <- predict(m, newdata = nd, se_fit = TRUE, re_form = NA) ggplot(p, aes(depth_scaled, exp(est),   ymin = exp(est - 1.96 * est_se), ymax = exp(est + 1.96 * est_se))) +   geom_line() + geom_ribbon(alpha = 0.4)   # Plotting marginal effect of a spline ---------------------------------  m_gam <- sdmTMB(  data = d, formula = density ~ 0 + as.factor(year) + s(depth_scaled, k = 5),  time = \"year\", mesh = mesh, family = tweedie(link = \"log\") ) if (require(\"visreg\", quietly = TRUE)) { # just for help docs   visreg::visreg(m_gam, \"depth_scaled\") }   # or manually: nd <- data.frame(depth_scaled =   seq(min(d$depth_scaled), max(d$depth_scaled), length.out = 100)) nd$year <- 2011L p <- predict(m_gam, newdata = nd, se_fit = TRUE, re_form = NA) ggplot(p, aes(depth_scaled, exp(est),   ymin = exp(est - 1.96 * est_se), ymax = exp(est + 1.96 * est_se))) +   geom_line() + geom_ribbon(alpha = 0.4)   # Forecasting ---------------------------------------------------------- mesh <- make_mesh(d, c(\"X\", \"Y\"), cutoff = 15)  unique(d$year) #> [1] 2011 2013 2015 2017 m <- sdmTMB(   data = d, formula = density ~ 1,   spatiotemporal = \"AR1\", # using an AR1 to have something to forecast with   extra_time = 2019L, # `L` for integer to match our data   spatial = \"off\",   time = \"year\", mesh = mesh, family = tweedie(link = \"log\") )  # Add a year to our grid: grid2019 <- qcs_grid_2011[qcs_grid_2011$year == max(qcs_grid_2011$year), ] grid2019$year <- 2019L # `L` because `year` is an integer in the data qcsgrid_forecast <- rbind(qcs_grid_2011, grid2019)  predictions <- predict(m, newdata = qcsgrid_forecast) plot_map(predictions, exp(est)) +   scale_fill_viridis_c(trans = \"log10\")  plot_map(predictions, epsilon_st) +   scale_fill_gradient2()   # Estimating local trends ----------------------------------------------  d <- pcod d$year_scaled <- as.numeric(scale(d$year)) mesh <- make_mesh(pcod, c(\"X\", \"Y\"), cutoff = 25) m <- sdmTMB(data = d, formula = density ~ depth_scaled + depth_scaled2,   mesh = mesh, family = tweedie(link = \"log\"),   spatial_varying = ~ 0 + year_scaled, time = \"year\", spatiotemporal = \"off\") nd <- qcs_grid nd$year_scaled <- (nd$year - mean(d$year)) / sd(d$year) p <- predict(m, newdata = nd)  plot_map(subset(p, year == 2003), zeta_s_year_scaled) + # pick any year   ggtitle(\"Spatial slopes\") +   scale_fill_gradient2()   plot_map(p, est_rf) +   ggtitle(\"Random field estimates\") +   scale_fill_gradient2()   plot_map(p, exp(est_non_rf)) +   ggtitle(\"Prediction (fixed effects only)\") +   scale_fill_viridis_c(trans = \"sqrt\")   plot_map(p, exp(est)) +   ggtitle(\"Prediction (fixed effects + all random effects)\") +   scale_fill_viridis_c(trans = \"sqrt\")"},{"path":"https://pbs-assess.github.io/sdmTMB/reference/priors.html","id":null,"dir":"Reference","previous_headings":"","what":"Prior distributions — sdmTMBpriors","title":"Prior distributions — sdmTMBpriors","text":"Optional priors/penalties model parameters. results penalized likelihood within TMB can used priors model passed tmbstan (see example extract_mcmc()). Note Jacobian adjustments made bayesian = TRUE sdmTMB() model fit. .e., final model fit tmbstan priors specified bayesian set TRUE. Otherwise, leave bayesian = FALSE. pc_matern() Penalized Complexity prior Matern covariance function.","code":""},{"path":"https://pbs-assess.github.io/sdmTMB/reference/priors.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Prior distributions — sdmTMBpriors","text":"","code":"sdmTMBpriors(   matern_s = pc_matern(range_gt = NA, sigma_lt = NA),   matern_st = pc_matern(range_gt = NA, sigma_lt = NA),   phi = halfnormal(NA, NA),   ar1_rho = normal(NA, NA),   tweedie_p = normal(NA, NA),   b = normal(NA, NA) )  normal(location = 0, scale = 1)  halfnormal(location = 0, scale = 1)  mvnormal(location = 0, scale = diag(length(location)))  pc_matern(range_gt, sigma_lt, range_prob = 0.05, sigma_prob = 0.05)"},{"path":"https://pbs-assess.github.io/sdmTMB/reference/priors.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Prior distributions — sdmTMBpriors","text":"matern_s PC (Penalized Complexity) prior (pc_matern()) spatial random field Matern parameters. matern_st matern_s spatiotemporal random field. Note likely want set share_fields = FALSE choose set spatial spatiotemporal Matern PC prior since include prior spatial range parameter. phi halfnormal() prior dispersion parameter observation distribution. ar1_rho normal() prior AR1 random field parameter. Note parameter support -1 < ar1_rho < 1. tweedie_p normal() prior Tweedie power parameter. Note parameter support 1 < tweedie_p < 2 choose mean appropriately. b normal() priors main population-level 'beta' effects. location Location parameter(s). scale Scale parameter. normal()/halfnormal(): standard deviation(s). mvnormal(): variance-covariance matrix. range_gt value one expects spatial spatiotemporal range greater 1 - range_prob probability. sigma_lt value one expects spatial spatiotemporal marginal standard deviation (sigma_O sigma_E internally) less 1 - sigma_prob probability. range_prob Probability. See description range_gt. sigma_prob Probability. See description sigma_lt.","code":""},{"path":"https://pbs-assess.github.io/sdmTMB/reference/priors.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Prior distributions — sdmTMBpriors","text":"named list values specified priors.","code":""},{"path":"https://pbs-assess.github.io/sdmTMB/reference/priors.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Prior distributions — sdmTMBpriors","text":"Meant passed priors argument sdmTMB(). normal() halfnormal() define normal half-normal priors , point, must location (mean) parameter 0. halfnormal() normal() can used make syntax clearer. intended used parameters support > 0. See https://arxiv.org/abs/1503.00256 description PC prior Gaussian random fields. Quoting discussion (substituting argument names pc_matern()): \"simulation study observe good coverage equal-tailed 95% credible intervals prior satisfies P(sigma > sigma_lt) = 0.05 P(range < range_gt) = 0.05, sigma_lt 2.5 40 times true marginal standard deviation range_gt 1/10 1/2.5 true range.\" Also see INLA::inla.spde2.pcmatern(). Keep mind range dependent units scale coordinate system. practice, may choose try fitting model without PC prior constraining model . better option simulate model given range sigma choose reasonable values system base prior knowledge model fit similar system spatial information data.","code":""},{"path":"https://pbs-assess.github.io/sdmTMB/reference/priors.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Prior distributions — sdmTMBpriors","text":"Fuglstad, G.-., Simpson, D., Lindgren, F., Rue, H. (2016) Constructing Priors Penalize Complexity Gaussian Random Fields. arXiv:1503.00256 Simpson, D., Rue, H., Martins, T., Riebler, ., Sørbye, S. (2015) Penalising model component complexity: principled, practical approach constructing priors. arXiv:1403.4630","code":""},{"path":[]},{"path":"https://pbs-assess.github.io/sdmTMB/reference/priors.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Prior distributions — sdmTMBpriors","text":"","code":"normal(0, 1) #>      [,1] [,2] #> [1,]    0    1 #> attr(,\"dist\") #> [1] \"normal\" halfnormal(0, 1) #>      [,1] [,2] #> [1,]    0    1 #> attr(,\"dist\") #> [1] \"normal\" mvnormal(c(0, 0)) #>      [,1] [,2] [,3] #> [1,]    0    1    0 #> [2,]    0    0    1 #> attr(,\"dist\") #> [1] \"mvnormal\" pc_matern(range_gt = 5, sigma_lt = 1) #> [1] 5.00 1.00 0.05 0.05 #> attr(,\"dist\") #> [1] \"pc_matern\" plot_pc_matern(range_gt = 5, sigma_lt = 1)   if (inla_installed()) {  d <- subset(pcod, year > 2011) pcod_spde <- make_mesh(d, c(\"X\", \"Y\"), cutoff = 30)  # - no priors on population-level effects (`b`) # - halfnormal(0, 10) prior on dispersion parameter `phi` # - Matern PC priors on spatial `matern_s` and spatiotemporal #   `matern_st` random field parameters m <- sdmTMB(density ~ s(depth, k = 3),   data = d, mesh = pcod_spde, family = tweedie(),   share_range = FALSE, time = \"year\",   priors = sdmTMBpriors(     phi = halfnormal(0, 10),     matern_s = pc_matern(range_gt = 5, sigma_lt = 1),     matern_st = pc_matern(range_gt = 5, sigma_lt = 1)   ) )  # - no prior on intercept # - normal(0, 1) prior on depth coefficient # - no prior on the dispersion parameter `phi` # - Matern PC prior m <- sdmTMB(density ~ depth_scaled,   data = d, mesh = pcod_spde, family = tweedie(),   spatiotemporal = \"off\",   priors = sdmTMBpriors(     b = normal(c(NA, 0), c(NA, 1)),     matern_s = pc_matern(range_gt = 5, sigma_lt = 1)   ) )  # You get a prior, you get a prior, you get a prior! # (except on the annual means; see the `NA`s) m <- sdmTMB(density ~ 0 + depth_scaled + depth_scaled2 + as.factor(year),   data = d, time = \"year\", mesh = pcod_spde, family = tweedie(link = \"log\"),   share_range = FALSE, spatiotemporal = \"AR1\",   priors = sdmTMBpriors(     b = normal(c(0, 0, NA, NA, NA), c(2, 2, NA, NA, NA)),     phi = halfnormal(0, 10),     tweedie_p = normal(1.5, 2),     ar1_rho = normal(0, 1),     matern_s = pc_matern(range_gt = 5, sigma_lt = 1),     matern_st = pc_matern(range_gt = 5, sigma_lt = 1)) )  }"},{"path":"https://pbs-assess.github.io/sdmTMB/reference/qcs_grid.html","id":null,"dir":"Reference","previous_headings":"","what":"Example 2x2km prediction grid for Queen Charlotte Sound — qcs_grid","title":"Example 2x2km prediction grid for Queen Charlotte Sound — qcs_grid","text":"Example 2x2km prediction grid Queen Charlotte Sound","code":""},{"path":"https://pbs-assess.github.io/sdmTMB/reference/qcs_grid.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Example 2x2km prediction grid for Queen Charlotte Sound — qcs_grid","text":"","code":"qcs_grid"},{"path":"https://pbs-assess.github.io/sdmTMB/reference/qcs_grid.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"Example 2x2km prediction grid for Queen Charlotte Sound — qcs_grid","text":"data frame.","code":""},{"path":"https://pbs-assess.github.io/sdmTMB/reference/reexports.html","id":null,"dir":"Reference","previous_headings":"","what":"Objects exported from other packages — reexports","title":"Objects exported from other packages — reexports","text":"objects imported packages. Follow links see documentation. generics tidy","code":""},{"path":"https://pbs-assess.github.io/sdmTMB/reference/residuals.sdmTMB.html","id":null,"dir":"Reference","previous_headings":"","what":"Residuals method for sdmTMB models — residuals.sdmTMB","title":"Residuals method for sdmTMB models — residuals.sdmTMB","text":"See residual-checking vignette: browseVignettes(\"sdmTMB\") documentation site. See notes types residuals 'Details' section .","code":""},{"path":"https://pbs-assess.github.io/sdmTMB/reference/residuals.sdmTMB.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Residuals method for sdmTMB models — residuals.sdmTMB","text":"","code":"# S3 method for sdmTMB residuals(   object,   type = c(\"mle-laplace\", \"mle-mcmc\", \"mvn-laplace\", \"response\", \"pearson\"),   mcmc_iter = 500,   mcmc_warmup = 250,   print_stan_model = FALSE,   stan_args = NULL,   model = c(1, 2),   ... )"},{"path":"https://pbs-assess.github.io/sdmTMB/reference/residuals.sdmTMB.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Residuals method for sdmTMB models — residuals.sdmTMB","text":"object sdmTMB() model type Type residual. See details. mcmc_iter Iterations MCMC residuals. take last one. mcmc_warmup Warmup MCMC residuals. print_stan_model Print Stan model MCMC residuals? stan_args list arguments passed rstan::sampling(). model delta/hurdle model component? ... Passed residual function. n works binomial.","code":""},{"path":"https://pbs-assess.github.io/sdmTMB/reference/residuals.sdmTMB.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Residuals method for sdmTMB models — residuals.sdmTMB","text":"vector residuals.","code":""},{"path":"https://pbs-assess.github.io/sdmTMB/reference/residuals.sdmTMB.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Residuals method for sdmTMB models — residuals.sdmTMB","text":"Types residuals currently supported: \"mle-laplace\" refers randomized quantile residuals (Dunn & Smyth 1996), also known probability integral transform (PIT) residuals (Smith 1985). model assumptions, distributed standard normal following caveat: Laplace approximation used latent/random effects can cause residuals deviate standard normal assumption even model consistent data (Thygesen et al. 2017). Therefore, residuals fast calculate can unreliable. \"mle-mcmc\" refers randomized quantile residuals fixed effects fixed MLE (maximum likelihoood estimate) values random effects sampled MCMC via tmbstan/Stan. proposed Thygesen et al. (2017) used Rufener et al. (2021). model assumptions, distributed standard normal. residuals theoretically preferred regular Laplace approximated randomized-quantile residuals, considerably slower calculate. Ideally MCMC run convergence last iteration can used residuals. MCMC samples defined mcmc_iter - mcmc_warmup. Stan model can printed print_stan_model = TRUE check. defaults may sufficient many models. \"mvn-laplace\" \"mle-laplace\" except parameters based simulations drawn assumed multivariate normal distribution (using joint precision matrix). \"response\" refers response residuals: observed minus predicted.","code":""},{"path":"https://pbs-assess.github.io/sdmTMB/reference/residuals.sdmTMB.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Residuals method for sdmTMB models — residuals.sdmTMB","text":"Dunn, P.K. & Smyth, G.K. (1996). Randomized Quantile Residuals. Journal Computational Graphical Statistics, 5, 236–244. Smith, J.Q. (1985). Diagnostic checks non-standard time series models. Journal Forecasting, 4, 283–291. Rufener, M.-C., Kristensen, K., Nielsen, J.R., Bastardie, F. 2021. Bridging gap commercial fisheries survey data model spatiotemporal dynamics marine species. Ecological Applications. e02453. doi:10.1002/eap.2453 Thygesen, U.H., Albertsen, C.M., Berg, C.W., Kristensen, K., Nielsen, . 2017. Validation ecological state space models using Laplace approximation. Environ Ecol Stat 24(2): 317–339. doi:10.1007/s10651-017-0372-4","code":""},{"path":[]},{"path":"https://pbs-assess.github.io/sdmTMB/reference/residuals.sdmTMB.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Residuals method for sdmTMB models — residuals.sdmTMB","text":"","code":"if (inla_installed() &&     require(\"tmbstan\", quietly = TRUE) &&     require(\"rstan\", quietly = TRUE)) {    mesh <- make_mesh(pcod_2011, c(\"X\", \"Y\"), cutoff = 10)   fit <- sdmTMB(     present ~ as.factor(year) + poly(depth, 3),     data = pcod_2011, mesh = mesh,     family = binomial()   )    # response residuals will be not be normally distributed unless   # the family is Gaussian:   r0 <- residuals(fit, type = \"response\")   qqnorm(r0)   qqline(r0)    # quick but can have issues because of Laplace approximation:   r1 <- residuals(fit, type = \"mle-laplace\")   qqnorm(r1)   qqline(r1)    # MCMC-based with fixed effects at MLEs; best but slowest:   set.seed(2938)   r2 <- residuals(fit, type = \"mle-mcmc\", mcmc_iter = 101, mcmc_warmup = 100)   qqnorm(r2)   qqline(r2)    # Example of passing control arguments to rstan::sampling():   # 11 iterations used for a quick example; don't do this normally   stan_args <- list(control = list(adapt_delta = 0.9, max_treedepth = 12))   r3 <- residuals(     fit, type = \"mle-mcmc\", mcmc_iter = 11, mcmc_warmup = 10,     stan_args = stan_args   ) }   #>  #> SAMPLING FOR MODEL 'tmb_generic' NOW (CHAIN 1). #> Chain 1:  #> Chain 1: Gradient evaluation took 0.00148 seconds #> Chain 1: 1000 transitions using 10 leapfrog steps per transition would take 14.8 seconds. #> Chain 1: Adjust your expectations accordingly! #> Chain 1:  #> Chain 1:  #> Chain 1: WARNING: There aren't enough warmup iterations to fit the #> Chain 1:          three stages of adaptation as currently configured. #> Chain 1:          Reducing each adaptation stage to 15%/75%/10% of #> Chain 1:          the given number of warmup iterations: #> Chain 1:            init_buffer = 15 #> Chain 1:            adapt_window = 75 #> Chain 1:            term_buffer = 10 #> Chain 1:  #> Chain 1: Iteration:   1 / 101 [  0%]  (Warmup) #> Chain 1: Iteration:  10 / 101 [  9%]  (Warmup) #> Chain 1: Iteration:  20 / 101 [ 19%]  (Warmup) #> Chain 1: Iteration:  30 / 101 [ 29%]  (Warmup) #> Chain 1: Iteration:  40 / 101 [ 39%]  (Warmup) #> Chain 1: Iteration:  50 / 101 [ 49%]  (Warmup) #> Chain 1: Iteration:  60 / 101 [ 59%]  (Warmup) #> Chain 1: Iteration:  70 / 101 [ 69%]  (Warmup) #> Chain 1: Iteration:  80 / 101 [ 79%]  (Warmup) #> Chain 1: Iteration:  90 / 101 [ 89%]  (Warmup) #> Chain 1: Iteration: 100 / 101 [ 99%]  (Warmup) #> Chain 1: Iteration: 101 / 101 [100%]  (Sampling) #> Chain 1:  #> Chain 1:  Elapsed Time: 3.85757 seconds (Warm-up) #> Chain 1:                0.027541 seconds (Sampling) #> Chain 1:                3.88511 seconds (Total) #> Chain 1:   #>  #> SAMPLING FOR MODEL 'tmb_generic' NOW (CHAIN 1). #> Chain 1:  #> Chain 1: Gradient evaluation took 0.001376 seconds #> Chain 1: 1000 transitions using 10 leapfrog steps per transition would take 13.76 seconds. #> Chain 1: Adjust your expectations accordingly! #> Chain 1:  #> Chain 1:  #> Chain 1: WARNING: No variance estimation is #> Chain 1:          performed for num_warmup < 20 #> Chain 1:  #> Chain 1: Iteration:  1 / 11 [  9%]  (Warmup) #> Chain 1: Iteration:  2 / 11 [ 18%]  (Warmup) #> Chain 1: Iteration:  3 / 11 [ 27%]  (Warmup) #> Chain 1: Iteration:  4 / 11 [ 36%]  (Warmup) #> Chain 1: Iteration:  5 / 11 [ 45%]  (Warmup) #> Chain 1: Iteration:  6 / 11 [ 54%]  (Warmup) #> Chain 1: Iteration:  7 / 11 [ 63%]  (Warmup) #> Chain 1: Iteration:  8 / 11 [ 72%]  (Warmup) #> Chain 1: Iteration:  9 / 11 [ 81%]  (Warmup) #> Chain 1: Iteration: 10 / 11 [ 90%]  (Warmup) #> Chain 1: Iteration: 11 / 11 [100%]  (Sampling) #> Chain 1:  #> Chain 1:  Elapsed Time: 0.281815 seconds (Warm-up) #> Chain 1:                0.027633 seconds (Sampling) #> Chain 1:                0.309448 seconds (Total) #> Chain 1:"},{"path":[]},{"path":"https://pbs-assess.github.io/sdmTMB/reference/run_extra_optimization.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Run extra optimization on an already fitted object — run_extra_optimization","text":"","code":"run_extra_optimization(object, nlminb_loops = 0, newton_loops = 1)"},{"path":"https://pbs-assess.github.io/sdmTMB/reference/run_extra_optimization.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Run extra optimization on an already fitted object — run_extra_optimization","text":"object object sdmTMB(). nlminb_loops many extra times run stats::nlminb() optimization. Sometimes restarting optimizer previous best values aids convergence. newton_loops many extra Newton optimization loops try stats::optimHess(). Sometimes aids convergence.","code":""},{"path":"https://pbs-assess.github.io/sdmTMB/reference/run_extra_optimization.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Run extra optimization on an already fitted object — run_extra_optimization","text":"updated model fit class sdmTMB.","code":""},{"path":"https://pbs-assess.github.io/sdmTMB/reference/run_extra_optimization.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Run extra optimization on an already fitted object — run_extra_optimization","text":"","code":"# Run extra optimization steps to help convergence: # (Not typically needed) fit <- sdmTMB(density ~ 0 + poly(depth, 2) + as.factor(year),   data = pcod_2011, mesh = pcod_mesh_2011, family = tweedie()) fit_1 <- run_extra_optimization(fit, newton_loops = 1) max(fit$gradients) #> [1] 9.676174e-05 max(fit_1$gradients) #> [1] 5.792087e-09"},{"path":"https://pbs-assess.github.io/sdmTMB/reference/sanity.html","id":null,"dir":"Reference","previous_headings":"","what":"Sanity check of an sdmTMB model — sanity","title":"Sanity check of an sdmTMB model — sanity","text":"Sanity check sdmTMB model","code":""},{"path":"https://pbs-assess.github.io/sdmTMB/reference/sanity.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Sanity check of an sdmTMB model — sanity","text":"","code":"sanity(object, big_sd_log10 = 3, gradient_thresh = 0.001)"},{"path":"https://pbs-assess.github.io/sdmTMB/reference/sanity.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Sanity check of an sdmTMB model — sanity","text":"object Fitted model sdmTMB(). big_sd_log10 Value check size standard errors . value 3 indicate standard errors greater 10^3 flagged. gradient_thresh Gradient threshold issue warning.","code":""},{"path":"https://pbs-assess.github.io/sdmTMB/reference/sanity.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Sanity check of an sdmTMB model — sanity","text":"invisible named list checks.","code":""},{"path":"https://pbs-assess.github.io/sdmTMB/reference/sanity.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Sanity check of an sdmTMB model — sanity","text":"object NA, NULL, class \"try-error\", sanity() return FALSE. facilitate using sanity() models try() tryCatch(). See examples section.","code":""},{"path":"https://pbs-assess.github.io/sdmTMB/reference/sanity.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Sanity check of an sdmTMB model — sanity","text":"","code":"fit <- sdmTMB(   present ~ s(depth),   data = pcod_2011, mesh = pcod_mesh_2011,   family = binomial() ) sanity(fit) #> ✔ Non-linear minimizer suggests successful convergence #> ✔ Hessian matrix is positive definite #> ✔ No extreme or very small eigenvalues detected #> ✔ No gradients with respect to fixed effects are >= 0.001 #> ✔ No fixed-effect standard errors are NA #> ✔ No standard errors look unreasonably large #> Standard errors intentionally omitted because they have been calculated in log #> space. #> ✔ No sigma parameters are < 0.01 #> ✔ No sigma parameters are > 100 #> ✔ Range parameter doesn't look unreasonably large  s <- sanity(fit) #> ✔ Non-linear minimizer suggests successful convergence #> ✔ Hessian matrix is positive definite #> ✔ No extreme or very small eigenvalues detected #> ✔ No gradients with respect to fixed effects are >= 0.001 #> ✔ No fixed-effect standard errors are NA #> ✔ No standard errors look unreasonably large #> Standard errors intentionally omitted because they have been calculated in log #> space. #> ✔ No sigma parameters are < 0.01 #> ✔ No sigma parameters are > 100 #> ✔ Range parameter doesn't look unreasonably large s #> $hessian_ok #> [1] TRUE #>  #> $eigen_values_ok #> [1] TRUE #>  #> $nlminb_ok #> [1] TRUE #>  #> $range_ok #> [1] TRUE #>  #> $gradients_ok #> [1] TRUE #>  #> $se_magnitude_ok #> [1] TRUE #>  #> $se_na_ok #> [1] TRUE #>  #> $sigmas_ok #> [1] TRUE #>  #> $all_ok #> [1] TRUE #>   # If fitting many models in a loop, you may want to wrap # sdmTMB() in try() to handle errors. sanity() will take an object # of class \"try-error\" and return FALSE. # Here, we will use stop() to simulate a failed sdmTMB() fit: failed_fit <- try(stop()) #> Error in try(stop()) :  s2 <- sanity(failed_fit) all(unlist(s)) #> [1] TRUE all(unlist(s2)) #> [1] FALSE"},{"path":"https://pbs-assess.github.io/sdmTMB/reference/sdmTMB.html","id":null,"dir":"Reference","previous_headings":"","what":"Fit a spatial or spatiotemporal GLMM with TMB — sdmTMB","title":"Fit a spatial or spatiotemporal GLMM with TMB — sdmTMB","text":"Fit spatial spatiotemporal Gaussian random field generalized linear mixed effects model (GLMM) TMB (Template Model Builder) R package SPDE (stochastic partial differential equation) approach. can useful (dynamic) species distribution models relative abundance index standardization among many uses.","code":""},{"path":"https://pbs-assess.github.io/sdmTMB/reference/sdmTMB.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Fit a spatial or spatiotemporal GLMM with TMB — sdmTMB","text":"","code":"sdmTMB(   formula,   data,   mesh,   time = NULL,   family = gaussian(link = \"identity\"),   spatial = c(\"on\", \"off\"),   spatiotemporal = c(\"iid\", \"ar1\", \"rw\", \"off\"),   share_range = TRUE,   time_varying = NULL,   time_varying_type = c(\"rw\", \"ar1\"),   spatial_varying = NULL,   weights = NULL,   offset = NULL,   extra_time = NULL,   reml = FALSE,   silent = TRUE,   anisotropy = FALSE,   control = sdmTMBcontrol(),   priors = sdmTMBpriors(),   knots = NULL,   bayesian = FALSE,   previous_fit = NULL,   do_fit = TRUE,   do_index = FALSE,   predict_args = NULL,   index_args = NULL,   experimental = NULL )"},{"path":"https://pbs-assess.github.io/sdmTMB/reference/sdmTMB.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Fit a spatial or spatiotemporal GLMM with TMB — sdmTMB","text":"formula Model formula. IID random intercepts possible using lme4 syntax, e.g., + (1 | g) g column class character factor representing groups. Penalized splines possible via mgcv s(). Optionally list delta (hurdle) models.  See examples details . data data frame. mesh object make_mesh(). time optional time column name (character). Can left NULL model spatial random fields; however, data actually spatiotemporal wish use get_index() get_cog() downstream, supply time argument. family family link. Supports gaussian(), Gamma(), binomial(), poisson(), Beta(), nbinom2(), truncated_nbinom2(), nbinom1(), truncated_nbinom1(), censored_poisson(), gamma_mix(), lognormal_mix(), student(), tweedie(). Supports delta/hurdle models: delta_beta(), delta_gamma(), delta_gamma_mix(), delta_lognormal_mix(), delta_lognormal(), delta_truncated_nbinom2(), binomial family options, see 'Binomial families' Details section . spatial Estimate spatial random fields? Options '' / '' TRUE / FALSE. Optionally, list delta models, e.g. list('', ''). spatiotemporal Estimate spatiotemporal random fields 'iid' (independent identically distributed; default), stationary 'ar1' (first-order autoregressive), random walk ('rw'), fixed 0 ''. set '' time = NULL. delta model, can list. E.g., list('', 'ar1'). Note spatiotemporal standard deviation represents marginal steady-state standard deviation process case AR1. .e., scaled according correlation. See TMB documentation. AR1 correlation coefficient (rho) estimated close 1, say > 0.99, may wish switch random walk 'rw'. Capitalization ignored. TRUE gets converted 'iid' FALSE gets converted ''. share_range Logical: estimate shared spatial spatiotemporal range parameter (TRUE, default) independent range parameters (FALSE). delta model, can list. E.g., list(TRUE, FALSE). time_varying optional one-sided formula describing covariates modelled random walk time. careful include covariates (including intercept) main time-varying formula since first time step estimated independently. .e., least one ~ 0 ~ -1. Structure must currently shared delta models. time_varying_type Type time-varying process apply time_varying formula. spatial_varying optional one-sided formula coefficients vary space random fields. Note likely want include fixed effect variable improve interpretability since random field assumed mean 0. (scaled) time column used, represent local-time-trend model. See doi:10.1111/ecog.05176  spatial trends vignette. Note predictor centered mean zero standard deviation approximately 1 likely also included main effect. Structure must currently shared delta models. weights numeric vector representing optional likelihood weights conditional model. Implemented glmmTMB: weights sum one internally modified. Can also used trials binomial family; weights argument needs vector name variable data frame. See Details section . offset numeric vector representing model offset. delta/hurdle models, applies positive component. Usually log transformed variable. offset argument needs vector name variable data frame. extra_time Optional extra time slices (e.g., years) include interpolation forecasting predict function. See Details section . reml Logical: use REML (restricted maximum likelihood) estimation rather maximum likelihood? Internally, adds fixed effects list random effects integrate . silent Silent include optimization details? Helpful set FALSE models take fit. anisotropy Logical: allow anisotropy (spatial correlation directionally dependent)? See plot_anisotropy(). Must shared across delta models. control Optimization control options via sdmTMBcontrol(). priors Optional penalties/priors via sdmTMBpriors(). Must currently shared across delta models. knots Optional named list containing knot values used basis construction smoothing terms. See mgcv::gam() mgcv::gamm(). E.g., s(x, bs = 'cc', k = 4), knots = list(x = c(1, 2, 3, 4)) bayesian Logical indicating model passed tmbstan. TRUE, Jacobian adjustments applied account parameter transformations priors applied. previous_fit previously fitted sdmTMB model initialize optimization . Can greatly speed fitting. Note model must set exactly way. However, data weights arguments can change, can useful cross-validation. do_fit Fit model (TRUE) return processed data without fitting (FALSE)? do_index index standardization calculations fitting? Saves memory time working large datasets projection grids since TMB object rebuilt predict.sdmTMB() get_index(). TRUE, predict_args must newdata element supplied area can supplied index_args. predict_args list arguments pass predict.sdmTMB() do_index = TRUE. index_args list arguments pass get_index() do_index = TRUE. Currently, area supported. Bias correction can done calling get_index() resulting fitted object. experimental named list esoteric -development options. dragons.","code":""},{"path":"https://pbs-assess.github.io/sdmTMB/reference/sdmTMB.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Fit a spatial or spatiotemporal GLMM with TMB — sdmTMB","text":"object (list) class sdmTMB. Useful elements include: sd_report: output TMB::sdreport() gradients: log likelihood gradients respect fixed effect model: output stats::nlminb() data: fitted data mesh: object supplied mesh argmument family: family object, includes inverse link function family$linkinv() tmb_params: parameters list passed TMB::MakeADFun() tmb_map: 'map' list passed TMB::MakeADFun() tmb_data: data list passed TMB::MakeADFun() tmb_obj: TMB object created TMB::MakeADFun()","code":""},{"path":"https://pbs-assess.github.io/sdmTMB/reference/sdmTMB.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Fit a spatial or spatiotemporal GLMM with TMB — sdmTMB","text":"Model description See model description vignette relevant appendix preprint sdmTMB: doi:10.1101/2022.03.24.485545 Binomial families Following structure stats::glm() glmmTMB, binomial family can specified one 4 ways: (1) response may factor (model classifies first level versus others), (2) response may binomial (0/1), (3) response can matrix form cbind(success, failure), (4) response may observed proportions, 'weights' argument used specify Binomial size (N) parameter (prob ~ ..., weights = N). Smooth terms Smooth terms can included following GAMs (generalized additive models) using + s(x), implements smooth mgcv::s(). sdmTMB uses penalized smooths, constructed via mgcv::smooth2random(). similar approach implemented gamm4 brms, among packages. Within smooths, syntax commonly used mgcv::s() mgcv::t2() can applied, e.g. 2-dimensional smooths may constructed + s(x, y) + t2(x, y); smooths can specific various factor levels, + s(x, = group); basis function dimensions may specified, e.g. + s(x, k = 4); various types splines may constructed cyclic splines model seasonality, + s(month, bs = \"cc\", k = 12) (perhaps knots argument also supplied). Threshold models linear break-point relationship covariate can included via + breakpt(variable) formula, variable single covariate corresponding column data. case, relationship linear point constant (hockey-stick shaped). Similarly, logistic-function threshold model can included via + logistic(variable). option models relationship logistic function 50% 95% values. similar length- size-based selectivity fisheries, parameterized points f(x) = 0.5 0.95. See threshold vignette. Note single threshold covariate can included covariate included components delta families. Extra time: forecasting interpolating Extra time slices (e.g., years) can included interpolation forecasting predict function via extra_time argument. predict function requires time slices defined fitting model ensure various time indices set correctly. careful including extra time slices model remains identifiable. example, including + .factor(year) formula render model data inform expected value missing year. sdmTMB() makes attempt determine model makes sense forecasting interpolation. options time_varying, spatiotemporal = \"rw\", spatiotemporal = \"ar1\", smoother time column provide mechanisms predict missing time slices process error. extra_time can also used fill missing time steps purposes random walk AR(1) process inclusion makes gaps time steps even. Index standardization index standardization, may wish include 0 + .factor(year) (whatever time column called) formula. See basic example index standardization relevant package vignette. need specify time argument. See get_index(). Regularization priors can achieve regularization via penalties (priors) fixed effect parameters. See sdmTMBpriors(). can fit model without penalties look output print(your_model) tidy(your_model) fit model do_fit = FALSE inspect head(your_model$tmb_data$X_ij[[1]]) want see formula translated fixed effect model matrix. Also see Bayesian vignette. Delta/hurdle models Delta models (also known hurdle models) can fit two separate models time using appropriate delta family. E.g.: delta_gamma(), delta_beta(), delta_lognormal(), delta_truncated_nbinom2(). fit delta family, default formula, spatial, spatiotemporal components shared. elements can specified independently two models using list format. include formula, spatial, spatiotemporal, share_range. first element list binomial component second element positive component (e.g., Gamma). elements must shared now (e.g., spatially varying coefficients, time-varying coefficients). Furthermore, currently limitations specifying two formulas list: two formulas smoothers, threshold effects, random intercepts. now, must specified single formula shared across two models. main advantage specifying models using delta family (compared fitting two separate models) (1) coding simplicity (2) calculation uncertainty derived quantities index abundance get_index() using generalized delta method within TMB. Also, parameters can shared across models. See delta-model vignette.","code":""},{"path":"https://pbs-assess.github.io/sdmTMB/reference/sdmTMB.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Fit a spatial or spatiotemporal GLMM with TMB — sdmTMB","text":"Main reference introducing package cite using sdmTMB: Anderson, S.C., E.J. Ward, P.. English, L..K. Barnett. 2022. sdmTMB: R package fast, flexible, user-friendly generalized linear mixed effects models spatial spatiotemporal random fields. bioRxiv 2022.03.24.485545; doi:10.1101/2022.03.24.485545 . Reference local trends: Barnett, L..K., E.J. Ward, S.C. Anderson. Improving estimates species distribution change incorporating local trends. Ecography. 44(3):427-439. doi:10.1111/ecog.05176 . explanation model application calculating climate velocities: English, P., E.J. Ward, C.N. Rooper, R.E. Forrest, L.. Rogers, K.L. Hunter, .M. Edwards, B.M. Connors, S.C. Anderson. 2021. Contrasting climate velocity impacts warm cool locations show effects marine warming worse already warmer temperate waters. press Fish Fisheries. doi:10.1111/faf.12613 . Discussion illustration decision points fitting models: Commander, C.J.C., Barnett, L..K., Ward, E.J., Anderson, S.C., Essington, T.E. 2022. shadow model: small choices spatially explicit species distribution models affect predictions. PeerJ 10: e12783. doi:10.7717/peerj.12783 . Application description threshold/break-point models: Essington, T.E. S.C. Anderson, L..K. Barnett, H.M. Berger, S.. Siedlecki, E.J. Ward. Advancing statistical models reveal effect dissolved oxygen spatial distribution marine taxa using thresholds physiologically based index. press Ecography. doi:10.1111/ecog.06249 . Application fish body condition: Lindmark, M., S.C. Anderson, M. Gogina, M. Casini. Evaluating drivers spatiotemporal individual condition bottom-associated marine fish. bioRxiv 2022.04.19.488709. doi:10.1101/2022.04.19.488709 . number sections original TMB model code adapted VAST R package: Thorson, J.T., 2019. Guidance decisions using Vector Autoregressive Spatio-Temporal (VAST) package stock, ecosystem, habitat climate assessments. Fish. Res. 210:143–161. doi:10.1016/j.fishres.2018.10.013 . Code family R--TMB implementation, selected parameterizations observation likelihoods, general package structure inspiration, idea behind TMB prediction approach adapted glmmTMB R package: Mollie E. Brooks, Kasper Kristensen, Koen J. van Benthem, Arni Magnusson, Casper W. Berg, Anders Nielsen, Hans J. Skaug, Martin Maechler Benjamin M. Bolker (2017). glmmTMB Balances Speed Flexibility Among Packages Zero-inflated Generalized Linear Mixed Modeling. R Journal, 9(2):378-400. doi:10.32614/rj-2017-066 . Implementation geometric anisotropy SPDE use random field GLMMs index standardization: Thorson, J.T., Shelton, .O., Ward, E.J., Skaug, H.J. 2015. Geostatistical delta-generalized linear mixed models improve precision estimated abundance indices West Coast groundfishes. ICES J. Mar. Sci. 72(5): 1297–1310. doi:10.1093/icesjms/fsu243 .","code":""},{"path":"https://pbs-assess.github.io/sdmTMB/reference/sdmTMB.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Fit a spatial or spatiotemporal GLMM with TMB — sdmTMB","text":"","code":"library(sdmTMB)  # Build an SPDE mesh with INLA: mesh <- make_mesh(pcod_2011, c(\"X\", \"Y\"), cutoff = 20) # * this example uses a fairly coarse mesh so these examples run quickly # * `cutoff` is the minimum distance between mesh vertices in units of the #   x and y coordinates # * `cutoff = 10` or `cutoff = 15` might make more sense in applied situations #   for this dataset # * or build any mesh in INLA and pass it to the `mesh` argument in `make_mesh()` # * not needed if you will be turning off all spatial/spatiotemporal random fields  # Quick mesh plot: plot(mesh)   # Fit a Tweedie spatial random field GLMM with a smoother for depth: fit <- sdmTMB(   density ~ s(depth),   data = pcod_2011, mesh = mesh,   family = tweedie(link = \"log\") ) fit #> Spatial model fit by ML ['sdmTMB'] #> Formula: density ~ s(depth) #> Mesh: mesh (isotropic covariance) #> Data: pcod_2011 #> Family: tweedie(link = 'log') #>   #>             coef.est coef.se #> (Intercept)     2.16    0.34 #> sdepth        -20.26   32.63 #>  #> Smooth terms: #>            Std. Dev. #> sds(depth)     13.07 #>  #> Dispersion parameter: 13.68 #> Tweedie p: 1.58 #> Matern range: 16.84 #> Spatial SD: 2.20 #> ML criterion at convergence: 2937.789 #>  #> See ?tidy.sdmTMB to extract these values as a data frame.  # Extract coefficients: tidy(fit, conf.int = TRUE) #> # A tibble: 1 × 5 #>   term        estimate std.error conf.low conf.high #>   <chr>          <dbl>     <dbl>    <dbl>     <dbl> #> 1 (Intercept)     2.16     0.340     1.50      2.83 tidy(fit, effects = \"ran_par\", conf.int = TRUE) #> Standard errors intentionally omitted because they have been calculated in log #> space. #> # A tibble: 4 × 5 #>   term      estimate std.error conf.low conf.high #>   <chr>        <dbl> <lgl>        <dbl>     <dbl> #> 1 range        16.8  NA           3.40      83.3  #> 2 phi          13.7  NA          12.4       15.0  #> 3 sigma_O       2.20 NA           0.735      6.59 #> 4 tweedie_p     1.58 NA           1.55       1.61  # Perform several 'sanity' checks: sanity(fit) #> ✔ Non-linear minimizer suggests successful convergence #> ✔ Hessian matrix is positive definite #> ✔ No extreme or very small eigenvalues detected #> ✔ No gradients with respect to fixed effects are >= 0.001 #> ✔ No fixed-effect standard errors are NA #> ✔ No standard errors look unreasonably large #> Standard errors intentionally omitted because they have been calculated in log #> space. #> ✔ No sigma parameters are < 0.01 #> ✔ No sigma parameters are > 100 #> ✔ Range parameter doesn't look unreasonably large  # Visualize depth effect: (see ?visreg_delta) visreg::visreg(fit, xvar = \"depth\") # link space; randomized quantile residuals  visreg::visreg(fit, xvar = \"depth\", scale = \"response\")  visreg::visreg(fit, xvar = \"depth\", scale = \"response\", gg = TRUE, rug = FALSE)   # Predict on the fitted data; see ?predict.sdmTMB p <- predict(fit)  # Predict on new data: nd <- subset(qcs_grid, year == 2017) p <- predict(fit, newdata = nd) head(p) #>     X    Y    depth depth_scaled depth_scaled2 year       est est_non_rf #> 1 456 5636 347.0834    1.5608122    2.43613479 2017 -4.726672  -4.567419 #> 2 458 5636 223.3348    0.5697699    0.32463771 2017  2.342465   2.368309 #> 3 460 5636 203.7408    0.3633693    0.13203724 2017  3.087509   2.979943 #> 4 462 5636 183.2987    0.1257046    0.01580166 2017  3.878558   3.637582 #> 5 464 5636 182.9998    0.1220368    0.01489297 2017  4.020912   3.646527 #> 6 466 5636 186.3892    0.1632882    0.02666303 2017  4.050893   3.543100 #>        est_rf     omega_s #> 1 -0.15925278 -0.15925278 #> 2 -0.02584346 -0.02584346 #> 3  0.10756586  0.10756586 #> 4  0.24097517  0.24097517 #> 5  0.37438449  0.37438449 #> 6  0.50779380  0.50779380  # Add spatiotemporal random fields: fit <- sdmTMB(   density ~ 0 + as.factor(year),   time = \"year\", #<   data = pcod_2011, mesh = mesh,   family = tweedie(link = \"log\") ) fit #> Spatiotemporal model fit by ML ['sdmTMB'] #> Formula: density ~ 0 + as.factor(year) #> Mesh: mesh (isotropic covariance) #> Time column: year #> Data: pcod_2011 #> Family: tweedie(link = 'log') #>   #>                     coef.est coef.se #> as.factor(year)2011     2.76    0.36 #> as.factor(year)2013     3.10    0.35 #> as.factor(year)2015     3.21    0.35 #> as.factor(year)2017     2.47    0.36 #>  #> Dispersion parameter: 14.83 #> Tweedie p: 1.57 #> Matern range: 13.31 #> Spatial SD: 3.17 #> Spatiotemporal SD: 1.79 #> ML criterion at convergence: 3007.552 #>  #> See ?tidy.sdmTMB to extract these values as a data frame.  # Make the fields AR1: fit <- sdmTMB(   density ~ s(depth),   time = \"year\",   spatial = \"off\",   spatiotemporal = \"ar1\", #<   data = pcod_2011, mesh = mesh,   family = tweedie(link = \"log\") ) fit #> Spatiotemporal model fit by ML ['sdmTMB'] #> Formula: density ~ s(depth) #> Mesh: mesh (isotropic covariance) #> Time column: year #> Data: pcod_2011 #> Family: tweedie(link = 'log') #>   #>             coef.est coef.se #> (Intercept)     1.84    0.33 #> sdepth        -20.49   34.07 #>  #> Smooth terms: #>            Std. Dev. #> sds(depth)      13.6 #>  #> Dispersion parameter: 12.84 #> Tweedie p: 1.55 #> Spatiotemporal AR1 correlation (rho): 0.67 #> Matern range: 12.22 #> Spatiotemporal SD: 3.28 #> ML criterion at convergence: 2914.393 #>  #> See ?tidy.sdmTMB to extract these values as a data frame.  # Make the fields a random walk: fit <- sdmTMB(   density ~ s(depth),   time = \"year\",   spatial = \"off\",   spatiotemporal = \"rw\", #<   data = pcod_2011, mesh = mesh,   family = tweedie(link = \"log\") ) fit #> Spatiotemporal model fit by ML ['sdmTMB'] #> Formula: density ~ s(depth) #> Mesh: mesh (isotropic covariance) #> Time column: year #> Data: pcod_2011 #> Family: tweedie(link = 'log') #>   #>             coef.est coef.se #> (Intercept)     1.95    0.34 #> sdepth        -20.46   33.21 #>  #> Smooth terms: #>            Std. Dev. #> sds(depth)     13.22 #>  #> Dispersion parameter: 12.84 #> Tweedie p: 1.56 #> Matern range: 14.66 #> Spatiotemporal SD: 2.17 #> ML criterion at convergence: 2919.181 #>  #> See ?tidy.sdmTMB to extract these values as a data frame.  # Depth smoothers by year: fit <- sdmTMB(   density ~ s(depth, by = as.factor(year)), #<   time = \"year\",   spatial = \"off\",   spatiotemporal = \"rw\",   data = pcod_2011, mesh = mesh,   family = tweedie(link = \"log\") ) fit #> Spatiotemporal model fit by ML ['sdmTMB'] #> Formula: density ~ s(depth, by = as.factor(year)) #> Mesh: mesh (isotropic covariance) #> Time column: year #> Data: pcod_2011 #> Family: tweedie(link = 'log') #>   #>                             coef.est coef.se #> (Intercept)                     1.76    0.34 #> sdepth):as.factor(year)2011    -0.81   42.80 #> sdepth):as.factor(year)2013   -48.98   35.01 #> sdepth):as.factor(year)2015   -63.68   64.10 #> sdepth):as.factor(year)2017    21.04   34.33 #>  #> Smooth terms: #>                                 Std. Dev. #> sds(depth):as.factor(year)2011)     16.62 #> sds(depth):as.factor(year)2013)     13.57 #> sds(depth):as.factor(year)2015)     28.24 #> sds(depth):as.factor(year)2017)     18.65 #>  #> Dispersion parameter: 12.70 #> Tweedie p: 1.55 #> Matern range: 8.62 #> Spatiotemporal SD: 3.14 #> ML criterion at convergence: 2924.193 #>  #> See ?tidy.sdmTMB to extract these values as a data frame.  # 2D depth-year smoother: fit <- sdmTMB(   density ~ s(depth, year), #<   spatial = \"off\",   data = pcod_2011, mesh = mesh,   family = tweedie(link = \"log\") ) fit #> Model fit by ML ['sdmTMB'] #> Formula: density ~ s(depth, year) #> Mesh: mesh (isotropic covariance) #> Data: pcod_2011 #> Family: tweedie(link = 'log') #>   #>              coef.est coef.se #> (Intercept)      2.55    0.24 #> sdepthyear_1    34.28   24.22 #> sdepthyear_2     1.79    1.07 #>  #> Smooth terms: #>                 Std. Dev. #> sds(depth,year)      6.08 #>  #> Dispersion parameter: 14.95 #> Tweedie p: 1.60 #> ML criterion at convergence: 2974.143 #>  #> See ?tidy.sdmTMB to extract these values as a data frame.  # Turn off spatial random fields: fit <- sdmTMB(   present ~ poly(log(depth)),   spatial = \"off\", #<   data = pcod_2011, mesh = mesh,   family = binomial() ) fit #> Model fit by ML ['sdmTMB'] #> Formula: present ~ poly(log(depth)) #> Mesh: mesh (isotropic covariance) #> Data: pcod_2011 #> Family: binomial(link = 'logit') #>   #>                  coef.est coef.se #> (Intercept)         -0.16    0.07 #> poly(log(depth))   -13.19    2.14 #>  #> ML criterion at convergence: 648.334 #>  #> See ?tidy.sdmTMB to extract these values as a data frame.  # Which, matches glm(): fit_glm <- glm(   present ~ poly(log(depth)),   data = pcod_2011,   family = binomial() ) summary(fit_glm) #>  #> Call: #> glm(formula = present ~ poly(log(depth)), family = binomial(),  #>     data = pcod_2011) #>  #> Deviance Residuals:  #>     Min       1Q   Median       3Q      Max   #> -1.6551  -1.0607  -0.8424   1.1975   1.4785   #>  #> Coefficients: #>                   Estimate Std. Error z value Pr(>|z|)     #> (Intercept)       -0.16433    0.06583  -2.496   0.0126 *   #> poly(log(depth)) -13.18981    2.14179  -6.158 7.35e-10 *** #> --- #> Signif. codes:  0 ‘***’ 0.001 ‘**’ 0.01 ‘*’ 0.05 ‘.’ 0.1 ‘ ’ 1 #>  #> (Dispersion parameter for binomial family taken to be 1) #>  #>     Null deviance: 1337.2  on 968  degrees of freedom #> Residual deviance: 1296.7  on 967  degrees of freedom #> AIC: 1300.7 #>  #> Number of Fisher Scoring iterations: 4 #>  AIC(fit, fit_glm) #>         df      AIC #> fit      2 1300.668 #> fit_glm  2 1300.668  # Delta/hurdle binomial-Gamma model: fit_dg <- sdmTMB(   density ~ poly(log(depth), 2),   data = pcod_2011, mesh = mesh,   spatial = \"off\",   family = delta_gamma() #< ) fit_dg #> Model fit by ML ['sdmTMB'] #> Formula: density ~ poly(log(depth), 2) #> Mesh: mesh (isotropic covariance) #> Data: pcod_2011 #> Family: delta_gamma(link1 = 'logit', link2 = 'log') #>  #> Delta/hurdle model 1: ----------------------------------- #> Family: binomial(link = 'logit')  #>                      coef.est coef.se #> (Intercept)             -0.48    0.09 #> poly(log(depth), 2)1   -23.06    3.15 #> poly(log(depth), 2)2   -48.79    4.45 #>  #>  #> Delta/hurdle model 2: ----------------------------------- #> Family: Gamma(link = 'log')  #>                      coef.est coef.se #> (Intercept)              4.24    0.08 #> poly(log(depth), 2)1    -5.49    3.50 #> poly(log(depth), 2)2   -13.26    3.23 #>  #> Dispersion parameter: 0.64 #>  #> ML criterion at convergence: 2936.579 #>  #> See ?tidy.sdmTMB to extract these values as a data frame.  # Delta model with different formulas and spatial structure: fit_dg <- sdmTMB(   list(density ~ depth_scaled, density ~ poly(depth_scaled, 2)), #<   data = pcod_2011, mesh = mesh,   spatial = list(\"off\", \"on\"), #<   family = delta_gamma() ) fit_dg #> Spatial model fit by ML ['sdmTMB'] #> Formula: list(density ~ depth_scaled, density ~ poly(depth_scaled, 2)) #> Mesh: mesh (isotropic covariance) #> Data: pcod_2011 #> Family: delta_gamma(link1 = 'logit', link2 = 'log') #>  #> Delta/hurdle model 1: ----------------------------------- #> Family: binomial(link = 'logit')  #>              coef.est coef.se #> (Intercept)     -0.17    0.07 #> depth_scaled    -0.43    0.07 #>  #>  #> Delta/hurdle model 2: ----------------------------------- #> Family: Gamma(link = 'log')  #>                        coef.est coef.se #> (Intercept)                4.08    0.14 #> poly(depth_scaled, 2)1    -6.15    4.52 #> poly(depth_scaled, 2)2   -12.58    4.14 #>  #> Dispersion parameter: 0.72 #> Matern range: 0.01 #> Spatial SD: 1303.43 #>  #> ML criterion at convergence: 2861.783 #>  #> See ?tidy.sdmTMB to extract these values as a data frame.  # Delta/hurdle truncated NB2: pcod_2011$count <- round(pcod_2011$density) fit_nb2 <- sdmTMB(   count ~ s(depth),   data = pcod_2011, mesh = mesh,   spatial = \"off\",   family = delta_truncated_nbinom2() #< ) fit_nb2 #> Model fit by ML ['sdmTMB'] #> Formula: count ~ s(depth) #> Mesh: mesh (isotropic covariance) #> Data: pcod_2011 #> Family: delta_truncated_nbinom2(link1 = 'logit', link2 = 'log') #>  #> Delta/hurdle model 1: ----------------------------------- #> Family: binomial(link = 'logit')  #>             coef.est coef.se #> (Intercept)    -0.69    0.21 #> sdepth         -2.98   24.71 #>  #> Smooth terms: #>            Std. Dev. #> sds(depth)       9.6 #>  #>  #> Delta/hurdle model 2: ----------------------------------- #> Family: truncated_nbinom2(link = 'log')  #>             coef.est coef.se #> (Intercept)     4.18    0.22 #> sdepth          3.83   18.43 #>  #> Smooth terms: #>            Std. Dev. #> sds(depth)      6.73 #>  #> Dispersion parameter: 0.49 #>  #> ML criterion at convergence: 2915.733 #>  #> See ?tidy.sdmTMB to extract these values as a data frame.  # Regular NB2: fit_nb2 <- sdmTMB(   count ~ s(depth),   data = pcod_2011, mesh = mesh,   spatial = \"off\",   family = nbinom2() #< ) fit_nb2 #> Model fit by ML ['sdmTMB'] #> Formula: count ~ s(depth) #> Mesh: mesh (isotropic covariance) #> Data: pcod_2011 #> Family: nbinom2(link = 'log') #>   #>             coef.est coef.se #> (Intercept)     2.49    0.27 #> sdepth        -37.71   41.31 #>  #> Smooth terms: #>            Std. Dev. #> sds(depth)      16.4 #>  #> Dispersion parameter: 0.14 #> ML criterion at convergence: 3006.939 #>  #> See ?tidy.sdmTMB to extract these values as a data frame.  # IID random intercepts by year: pcod_2011$fyear <- as.factor(pcod_2011$year) fit <- sdmTMB(   density ~ s(depth) + (1 | fyear), #<   data = pcod_2011, mesh = mesh,   family = tweedie(link = \"log\") ) fit #> Spatial model fit by ML ['sdmTMB'] #> Formula: density ~ s(depth) + (1 | fyear) #> Mesh: mesh (isotropic covariance) #> Data: pcod_2011 #> Family: tweedie(link = 'log') #>   #>             coef.est coef.se #> (Intercept)     2.13    0.37 #> sdepth        -18.95   31.24 #>  #> Smooth terms: #>            Std. Dev. #> sds(depth)     12.51 #>  #> Random intercepts: #>       Std. Dev. #> fyear       0.3 #>  #> Dispersion parameter: 13.55 #> Tweedie p: 1.58 #> Matern range: 16.66 #> Spatial SD: 2.21 #> ML criterion at convergence: 2933.138 #>  #> See ?tidy.sdmTMB to extract these values as a data frame.  # Spatially varying coefficient of year: pcod_2011$year_scaled <- as.numeric(scale(pcod_2011$year)) fit <- sdmTMB(   density ~ year_scaled,   spatial_varying = ~ 0 + year_scaled, #<   data = pcod_2011, mesh = mesh, family = tweedie(), time = \"year\" ) fit #> Spatiotemporal model fit by ML ['sdmTMB'] #> Formula: density ~ year_scaled #> Mesh: mesh (isotropic covariance) #> Time column: year #> Data: pcod_2011 #> Family: tweedie(link = 'log') #>   #>             coef.est coef.se #> (Intercept)     2.86    0.33 #> year_scaled    -0.06    0.15 #>  #> Dispersion parameter: 14.79 #> Tweedie p: 1.56 #> Matern range: 20.56 #> Spatial SD: 2.38 #> Spatially varying coefficient SD (year_scaled): 0.81 #> Spatiotemporal SD: 1.11 #> ML criterion at convergence: 3008.886 #>  #> See ?tidy.sdmTMB to extract these values as a data frame.  # Time-varying effects of depth and depth squared: fit <- sdmTMB(   density ~ 0 + as.factor(year),   time_varying = ~ 0 + depth_scaled + depth_scaled2, #<   data = pcod_2011, time = \"year\", mesh = mesh,   family = tweedie() ) print(fit) #> Spatiotemporal model fit by ML ['sdmTMB'] #> Formula: density ~ 0 + as.factor(year) #> Mesh: mesh (isotropic covariance) #> Time column: year #> Data: pcod_2011 #> Family: tweedie(link = 'log') #>   #>                     coef.est coef.se #> as.factor(year)2011     3.73    0.30 #> as.factor(year)2013     3.64    0.28 #> as.factor(year)2015     4.00    0.29 #> as.factor(year)2017     3.31    0.32 #>  #> Time-varying parameters: #>                    coef.est coef.se #> depth_scaled-2011     -0.87    0.16 #> depth_scaled-2013     -0.81    0.13 #> depth_scaled-2015     -0.75    0.13 #> depth_scaled-2017     -1.11    0.23 #> depth_scaled2-2011    -1.92    0.29 #> depth_scaled2-2013    -0.92    0.14 #> depth_scaled2-2015    -1.59    0.22 #> depth_scaled2-2017    -2.20    0.35 #>  #> Dispersion parameter: 12.80 #> Tweedie p: 1.56 #> Matern range: 0.02 #> Spatial SD: 1560.43 #> Spatiotemporal SD: 1266.29 #> ML criterion at convergence: 2911.371 #>  #> See ?tidy.sdmTMB to extract these values as a data frame. # Extract values: est <- as.list(fit$sd_report, \"Estimate\") se <- as.list(fit$sd_report, \"Std. Error\") est$b_rw_t[, , 1] #>            [,1]       [,2] #> [1,] -0.8738039 -1.9199724 #> [2,] -0.8115162 -0.9195934 #> [3,] -0.7514767 -1.5858305 #> [4,] -1.1064061 -2.1992576 se$b_rw_t[, , 1] #>           [,1]      [,2] #> [1,] 0.1619744 0.2944086 #> [2,] 0.1287059 0.1386946 #> [3,] 0.1346181 0.2197914 #> [4,] 0.2305926 0.3514650  # Linear break-point effect of depth: fit <- sdmTMB(   density ~ breakpt(depth_scaled), #<   data = pcod_2011,   mesh = mesh,   family = tweedie() ) fit #> Spatial model fit by ML ['sdmTMB'] #> Formula: density ~ breakpt(depth_scaled) #> Mesh: mesh (isotropic covariance) #> Data: pcod_2011 #> Family: tweedie(link = 'log') #>   #>                      coef.est coef.se #> (Intercept)              4.11    0.33 #> depth_scaled-slope       1.07    0.22 #> depth_scaled-breakpt    -1.30    0.25 #>  #> Dispersion parameter: 15.19 #> Tweedie p: 1.58 #> Matern range: 23.57 #> Spatial SD: 1.92 #> ML criterion at convergence: 2997.241 #>  #> See ?tidy.sdmTMB to extract these values as a data frame."},{"path":"https://pbs-assess.github.io/sdmTMB/reference/sdmTMB_cv.html","id":null,"dir":"Reference","previous_headings":"","what":"Cross validation with sdmTMB models — sdmTMB_cv","title":"Cross validation with sdmTMB models — sdmTMB_cv","text":"Save log likelihoods k-fold cross-validation sdmTMB models.","code":""},{"path":"https://pbs-assess.github.io/sdmTMB/reference/sdmTMB_cv.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Cross validation with sdmTMB models — sdmTMB_cv","text":"","code":"sdmTMB_cv(   formula,   data,   mesh_args,   mesh = NULL,   time = NULL,   k_folds = 8,   fold_ids = NULL,   parallel = TRUE,   use_initial_fit = FALSE,   spde = deprecated(),   ... )"},{"path":"https://pbs-assess.github.io/sdmTMB/reference/sdmTMB_cv.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Cross validation with sdmTMB models — sdmTMB_cv","text":"formula Model formula. data data frame. mesh_args Arguments make_mesh(). supplied, mesh reconstructed fold. mesh Output make_mesh(). supplied, mesh constant across folds. time name time column. Leave NULL spatial data. k_folds Number folds. fold_ids Optional vector containing user fold IDs. Can also single string, e.g. \"fold_id\" representing name variable data. parallel TRUE future::plan() supplied, run parallel. use_initial_fit Fit first fold use parameter values starting values subsequent folds? Can faster many folds. spde Depreciated. Use mesh instead. ... arguments required run sdmTMB() model exception weights, used define folds.","code":""},{"path":"https://pbs-assess.github.io/sdmTMB/reference/sdmTMB_cv.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Cross validation with sdmTMB models — sdmTMB_cv","text":"list: data: Original data plus columns fold ID, CV predicted value, CV log likelihood. models: list models; one per fold. fold_loglik: Sum left-log likelihoods per fold. fold_elpd: Expected log predictive density per fold left-data. sum_loglik: Sum fold_loglik across left-data. elpd: Expected log predictive density across left-data. pdHess: Logical vector: Hessian invertible fold? converged: Logical: pdHess TRUE? max_gradients: Max gradient per fold.","code":""},{"path":"https://pbs-assess.github.io/sdmTMB/reference/sdmTMB_cv.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Cross validation with sdmTMB models — sdmTMB_cv","text":"Parallel processing can used setting future::plan(). example:","code":"library(future) plan(multisession) # now use sdmTMB_cv() ..."},{"path":"https://pbs-assess.github.io/sdmTMB/reference/sdmTMB_cv.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Cross validation with sdmTMB models — sdmTMB_cv","text":"","code":"mesh <- make_mesh(pcod, c(\"X\", \"Y\"), cutoff = 25)  # Set parallel processing first if desired with the future package. # See the Details section above.  m_cv <- sdmTMB_cv(   density ~ 0 + depth_scaled + depth_scaled2,   data = pcod, mesh = mesh,   family = tweedie(link = \"log\"), k_folds = 2 ) #> Running fits with `future.apply()`. #> Set a parallel `future::plan()` to use parallel processing.  m_cv$fold_elpd #> [1] -1.058983 -1.035476 m_cv$elpd #> [1] -1.046859  m_cv$fold_loglik #> [1] -3288.382 -3326.460 m_cv$sum_loglik #> [1] -6614.843  head(m_cv$data) #> # A tibble: 6 × 15 #>    year     X     Y depth density present   lat   lon depth_mean depth…¹ depth…² #>   <int> <dbl> <dbl> <dbl>   <dbl>   <dbl> <dbl> <dbl>      <dbl>   <dbl>   <dbl> #> 1  2003  446. 5793.   201   113.        1  52.3 -130.       5.16   0.445   0.333 #> 2  2003  446. 5800.   212    41.7       1  52.3 -130.       5.16   0.445   0.453 #> 3  2003  449. 5802.   220     0         0  52.4 -130.       5.16   0.445   0.536 #> 4  2003  437. 5802.   197    15.7       1  52.4 -130.       5.16   0.445   0.288 #> 5  2003  421. 5771.   256     0         0  52.1 -130.       5.16   0.445   0.877 #> 6  2003  418. 5772.   293     0         0  52.1 -130.       5.16   0.445   1.18  #> # … with 4 more variables: depth_scaled2 <dbl>, cv_fold <int>, #> #   cv_predicted <dbl>, cv_loglik <dbl>, and abbreviated variable names #> #   ¹​depth_sd, ²​depth_scaled m_cv$models[[1]] #> Spatial model fit by ML ['sdmTMB'] #> Formula: density ~ 0 + depth_scaled + depth_scaled2 #> Family: tweedie(link = 'log') #>   #>               coef.est coef.se #> depth_scaled     -1.81    0.19 #> depth_scaled2    -1.28    0.10 #>  #> Dispersion parameter: 14.03 #> Tweedie p: 1.60 #> Matern range: 117.49 #> Spatial SD: 2.61 #> ML criterion at convergence: 3282.890 #>  #> See ?tidy.sdmTMB to extract these values as a data frame. m_cv$max_gradients #> [1] 0.0003465449 0.0008065475  # \\donttest{ # Create mesh each fold: m_cv2 <- sdmTMB_cv(   density ~ 0 + depth_scaled + depth_scaled2,   data = pcod, mesh_args = list(xy_cols = c(\"X\", \"Y\"), cutoff = 20),   family = tweedie(link = \"log\"), k_folds = 2 ) #> Running fits with `future.apply()`. #> Set a parallel `future::plan()` to use parallel processing.  # Use fold_ids: m_cv3 <- sdmTMB_cv(   density ~ 0 + depth_scaled + depth_scaled2,   data = pcod, mesh = mesh,   family = tweedie(link = \"log\"),   fold_ids = rep(seq(1, 3), nrow(pcod))[seq(1, nrow(pcod))] ) #> Running fits with `future.apply()`. #> Set a parallel `future::plan()` to use parallel processing. # }"},{"path":"https://pbs-assess.github.io/sdmTMB/reference/sdmTMB_simulate.html","id":null,"dir":"Reference","previous_headings":"","what":"Simulate from a spatial/spatiotemporal model — sdmTMB_simulate","title":"Simulate from a spatial/spatiotemporal model — sdmTMB_simulate","text":"sdmTMB_simulate() uses TMB simulate new data given specified parameter values. simulate.sdmTMB(), hand, takes existing model fit simulates new observations optionally new random effects.","code":""},{"path":"https://pbs-assess.github.io/sdmTMB/reference/sdmTMB_simulate.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Simulate from a spatial/spatiotemporal model — sdmTMB_simulate","text":"","code":"sdmTMB_simulate(   formula,   data,   mesh,   family = gaussian(link = \"identity\"),   time = NULL,   B = NULL,   range = NULL,   rho = NULL,   sigma_O = NULL,   sigma_E = NULL,   sigma_Z = NULL,   phi = NULL,   tweedie_p = NULL,   df = NULL,   threshold_coefs = NULL,   fixed_re = list(omega_s = NULL, epsilon_st = NULL, zeta_s = NULL),   previous_fit = NULL,   seed = sample.int(1e+06, 1),   ... )"},{"path":"https://pbs-assess.github.io/sdmTMB/reference/sdmTMB_simulate.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Simulate from a spatial/spatiotemporal model — sdmTMB_simulate","text":"formula one-sided formula describing fixed-effect structure. Random intercepts (yet) supported. Fixed effects match corresponding B argument vector coefficient values. data data frame containing predictors described formula time column time specified. mesh Output make_mesh(). family Family sdmTMB(). Delta families supported. Instead, simulate two component models separately combine. time time column name. B vector beta values (fixed-effect coefficient values). range Parameter controls decay spatial correlation. vector length 2, share_range set FALSE spatial spatiotemporal ranges unique. rho Spatiotemporal correlation years; -1 1. sigma_O SD spatial process (Omega). sigma_E SD spatiotemporal process (Epsilon). sigma_Z SD spatially varying coefficient field (Zeta). phi Observation error scale parameter (e.g., SD Gaussian). tweedie_p Tweedie p (power) parameter; 1 2. df Student-t degrees freedom. threshold_coefs optional vector threshold coefficient values formula includes breakpt() logistic(). breakpt(), slope cut values. logistic(), threshold function 50% maximum, threshold function 95% maximum, maximum. See model description vignette details. fixed_re list optional random effects fix specified (e.g., previously estimated) values. Values NULL result random effects simulated. previous_fit (Deprecated; please use simulate.sdmTMB()). optional previous sdmTMB() fit pull parameter values. -ruled non-NULL specified parameter arguments. seed Seed number. ... arguments pass sdmTMB().","code":""},{"path":"https://pbs-assess.github.io/sdmTMB/reference/sdmTMB_simulate.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Simulate from a spatial/spatiotemporal model — sdmTMB_simulate","text":"data frame : 1st column time variable (present). 2nd 3rd columns spatial coordinates. omega_s represents simulated spatial random effects (present). zeta_s represents simulated spatial varying covariate field (present). epsilon_st represents simulated spatiotemporal random effects (present). eta true value link space mu true value inverse link space. observed represents simulated process observation error. remaining columns fixed-effect model matrix.","code":""},{"path":[]},{"path":"https://pbs-assess.github.io/sdmTMB/reference/sdmTMB_simulate.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Simulate from a spatial/spatiotemporal model — sdmTMB_simulate","text":"","code":"if (inla_installed()) {   set.seed(123)    # make fake predictor(s) (a1) and sampling locations:   predictor_dat <- data.frame(     X = runif(300), Y = runif(300),     a1 = rnorm(300), year = rep(1:6, each = 50)   )   mesh <- make_mesh(predictor_dat, xy_cols = c(\"X\", \"Y\"), cutoff = 0.1)    sim_dat <- sdmTMB_simulate(     formula = ~ 1 + a1,     data = predictor_dat,     time = \"year\",     mesh = mesh,     family = gaussian(),     range = 0.5,     sigma_E = 0.1,     phi = 0.1,     sigma_O = 0.2,     seed = 42,     B = c(0.2, -0.4) # B0 = intercept, B1 = a1 slope   )   head(sim_dat)    if (require(\"ggplot2\", quietly = TRUE)) {     ggplot(sim_dat, aes(X, Y, colour = observed)) +       geom_point() +       facet_wrap(~year) +       scale_color_gradient2()   }    # fit to the simulated data:   fit <- sdmTMB(observed ~ a1, data = sim_dat, mesh = mesh, time = \"year\")   fit } #> Spatiotemporal model fit by ML ['sdmTMB'] #> Formula: observed ~ a1 #> Mesh: mesh (isotropic covariance) #> Time column: year #> Data: sim_dat #> Family: gaussian(link = 'identity') #>   #>             coef.est coef.se #> (Intercept)     0.23    0.09 #> a1             -0.39    0.01 #>  #> Dispersion parameter: 0.09 #> Matern range: 0.40 #> Spatial SD: 0.21 #> Spatiotemporal SD: 0.11 #> ML criterion at convergence: -162.527 #>  #> See ?tidy.sdmTMB to extract these values as a data frame."},{"path":"https://pbs-assess.github.io/sdmTMB/reference/sdmTMB_stacking.html","id":null,"dir":"Reference","previous_headings":"","what":"Perform stacking with log scores on sdmTMB_cv() output — sdmTMB_stacking","title":"Perform stacking with log scores on sdmTMB_cv() output — sdmTMB_stacking","text":"approach described Yao et al. (2018) doi:10.1214/17-BA1091 . general method minimizes (maximizes) quantity across models. simple models normal error, may root mean squared error (RMSE), approaches include log score. adopt latter , log scores used generate stacking predictive distributions","code":""},{"path":"https://pbs-assess.github.io/sdmTMB/reference/sdmTMB_stacking.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Perform stacking with log scores on sdmTMB_cv() output — sdmTMB_stacking","text":"","code":"sdmTMB_stacking(model_list, include_folds = NULL)"},{"path":"https://pbs-assess.github.io/sdmTMB/reference/sdmTMB_stacking.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Perform stacking with log scores on sdmTMB_cv() output — sdmTMB_stacking","text":"model_list list models fit sdmTMB_cv() generate estimates predictive densities. want set seed value fitting model manually construct fold IDs across models. include_folds optional numeric vector specifying folds include calculations. example, 5 folds used k-fold cross validation, first 4 needed generate weights, include_folds = 1:4.","code":""},{"path":"https://pbs-assess.github.io/sdmTMB/reference/sdmTMB_stacking.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Perform stacking with log scores on sdmTMB_cv() output — sdmTMB_stacking","text":"vector model weights.","code":""},{"path":"https://pbs-assess.github.io/sdmTMB/reference/sdmTMB_stacking.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Perform stacking with log scores on sdmTMB_cv() output — sdmTMB_stacking","text":"Yao, Y., Vehtari, ., Simpson, D., Gelman, . 2018. Using Stacking Average Bayesian Predictive Distributions (Discussion). Bayesian Analysis 13(3): 917–1007. International Society Bayesian Analysis. doi:10.1214/17-BA1091","code":""},{"path":"https://pbs-assess.github.io/sdmTMB/reference/sdmTMB_stacking.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Perform stacking with log scores on sdmTMB_cv() output — sdmTMB_stacking","text":"","code":"# Set parallel processing if desired. See 'Details' in ?sdmTMB_cv  # Depth as quadratic: set.seed(1) m_cv_1 <- sdmTMB_cv(   density ~ 0 + depth_scaled + depth_scaled2,   data = pcod_2011, mesh = pcod_mesh_2011,   family = tweedie(link = \"log\"), k_folds = 2 ) #> Running fits with `future.apply()`. #> Set a parallel `future::plan()` to use parallel processing. # Depth as linear: set.seed(1) m_cv_2 <- sdmTMB_cv(   density ~ 0 + depth_scaled,   data = pcod_2011, mesh = pcod_mesh_2011,   family = tweedie(link = \"log\"), k_folds = 2 ) #> Running fits with `future.apply()`. #> Set a parallel `future::plan()` to use parallel processing.  # Only an intercept: set.seed(1) m_cv_3 <- sdmTMB_cv(   density ~ 1,   data = pcod_2011, mesh = pcod_mesh_2011,   family = tweedie(link = \"log\"), k_folds = 2 ) #> Running fits with `future.apply()`. #> Set a parallel `future::plan()` to use parallel processing.  models <- list(m_cv_1, m_cv_2, m_cv_3) weights <- sdmTMB_stacking(models) weights #> [1] 0.9038042 0.0182349 0.0779609"},{"path":"https://pbs-assess.github.io/sdmTMB/reference/sdmTMBcontrol.html","id":null,"dir":"Reference","previous_headings":"","what":"Optimization control options — sdmTMBcontrol","title":"Optimization control options — sdmTMBcontrol","text":"sdmTMB() stats::nlminb() control options.","code":""},{"path":"https://pbs-assess.github.io/sdmTMB/reference/sdmTMBcontrol.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Optimization control options — sdmTMBcontrol","text":"","code":"sdmTMBcontrol(   eval.max = 2000L,   iter.max = 1000L,   normalize = FALSE,   nlminb_loops = 1L,   newton_loops = 0L,   mgcv = deprecated(),   quadratic_roots = FALSE,   start = NULL,   map_rf = deprecated(),   map = NULL,   lower = NULL,   upper = NULL,   multiphase = TRUE,   profile = FALSE,   get_joint_precision = TRUE,   parallel = getOption(\"sdmTMB.cores\", 1L),   ... )"},{"path":"https://pbs-assess.github.io/sdmTMB/reference/sdmTMBcontrol.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Optimization control options — sdmTMBcontrol","text":"eval.max Maximum number evaluations objective function allowed. iter.max Maximum number iterations allowed. normalize Logical: use TMB::normalize() normalize process likelihood using Laplace approximation? Can result substantial speed boost cases. used default FALSE prior May 2021. Currently working models fit REML random intercepts. nlminb_loops many times run stats::nlminb() optimization. Sometimes restarting optimizer previous best values aids convergence. maximum gradient still large, try increasing 2. newton_loops many Newton optimization steps try stats::optimHess() running stats::nlminb(). Sometimes aids convergence. mgcv Deprecated Parse formula mgcv::gam()? quadratic_roots Experimental feature internal use right now; may moved branch. Logical: quadratic roots calculated? Note: sdmTMB side, first two coefficients used generate quadratic parameters. means want generate quadratic profile depth, depth depth^2 part formula, need make sure listed first intercept included. example, formula = cpue ~ 0 + depth + depth2 + .factor(year). start named list specifying starting values parameters. can see necessary structure fitting model inspecting your_model$tmb_obj$env$parList(). Elements start specified replace default starting values. map_rf Deprecated use spatial = '', spatiotemporal = '' sdmTMB(). map named list factor NAs specifying parameter values fixed constant value. See documentation TMB::MakeADFun(). usually used start specify fixed value. lower optional named list lower bounds within optimization. Parameter vectors name (e.g., b_j ln_kappa cases) can specified numeric vector. E.g. lower = list(b_j = c(-5, -5)). upper optional named list upper bounds within optimization. multiphase Logical: estimate fixed random effects phases? Phases usually faster stable. profile Logical: population-level/fixed effects profiled likelihood? appended random effects vector without Laplace approximation. See TMB::MakeADFun(). can dramatically speed model fit many fixed effects experimental stage. get_joint_precision Logical. Passed getJointPrecision TMB::sdreport(). Must TRUE use simulation-based methods predict.sdmTMB() [get_index_sims()]. needed, setting FALSE reduce object size. parallel Argument currently ignored. parallel processing 3 cores, example, use TMB::openmp(n = 3, DLL = \"sdmTMB\"). careful, always faster cores definitely upper limit. ... Anything else. See 'Control parameters' section stats::nlminb().","code":""},{"path":"https://pbs-assess.github.io/sdmTMB/reference/sdmTMBcontrol.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Optimization control options — sdmTMBcontrol","text":"list control arguments","code":""},{"path":"https://pbs-assess.github.io/sdmTMB/reference/sdmTMBcontrol.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Optimization control options — sdmTMBcontrol","text":"Usually used within sdmTMB(). example:","code":"sdmTMB(..., control = sdmTMBcontrol(newton_loops = 1))"},{"path":"https://pbs-assess.github.io/sdmTMB/reference/sdmTMBcontrol.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Optimization control options — sdmTMBcontrol","text":"","code":"sdmTMBcontrol() #> $eval.max #> [1] 2000 #>  #> $iter.max #> [1] 1000 #>  #> $normalize #> [1] FALSE #>  #> $nlminb_loops #> [1] 1 #>  #> $newton_loops #> [1] 0 #>  #> $profile #> [1] FALSE #>  #> $quadratic_roots #> [1] FALSE #>  #> $start #> NULL #>  #> $map #> NULL #>  #> $lower #> NULL #>  #> $upper #> NULL #>  #> $multiphase #> [1] TRUE #>  #> $parallel #> [1] 1 #>  #> $get_joint_precision #> [1] TRUE #>"},{"path":"https://pbs-assess.github.io/sdmTMB/reference/simulate.sdmTMB.html","id":null,"dir":"Reference","previous_headings":"","what":"Simulate from a fitted sdmTMB model — simulate.sdmTMB","title":"Simulate from a fitted sdmTMB model — simulate.sdmTMB","text":"simulate.sdmTMB S3 method producing matrix simulations fitted model. similar lme4::simulate.merMod() glmmTMB::simulate.glmmTMB(). can used DHARMa package among uses.","code":""},{"path":"https://pbs-assess.github.io/sdmTMB/reference/simulate.sdmTMB.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Simulate from a fitted sdmTMB model — simulate.sdmTMB","text":"","code":"# S3 method for sdmTMB simulate(   object,   nsim = 1L,   seed = sample.int(1e+06, 1L),   params = c(\"mle\", \"mvn\"),   model = c(NA, 1, 2),   re_form = NULL,   tmbstan_model = NULL,   ... )"},{"path":"https://pbs-assess.github.io/sdmTMB/reference/simulate.sdmTMB.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Simulate from a fitted sdmTMB model — simulate.sdmTMB","text":"object sdmTMB model nsim Number response lists simulate. Defaults 1. seed Random number seed params Whether parameters used simulation come Maximum Likelihood Estimate (\"mle\") new draws joint precision matrix assuming multivariate normal distributed (\"mvn\"). model delta/hurdle model, model simulate ? NA = combined, 1 = first model, 2 = second mdoel. re_form NULL specify simulation conditional fitted random effects (simulates observation error). ~0 NA simulate new random affects (smoothers, internally random effects, simulated new). tmbstan_model optional model fit via tmbstan::tmbstan(). provided parameters drawn MCMC samples new observation error added. See example extract_mcmc(). ... Extra arguments (used)","code":""},{"path":"https://pbs-assess.github.io/sdmTMB/reference/simulate.sdmTMB.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Simulate from a fitted sdmTMB model — simulate.sdmTMB","text":"Returns matrix; number columns nsim.","code":""},{"path":[]},{"path":"https://pbs-assess.github.io/sdmTMB/reference/simulate.sdmTMB.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Simulate from a fitted sdmTMB model — simulate.sdmTMB","text":"","code":"if (inla_installed()) {  # start with some data simulated from scratch: set.seed(1) predictor_dat <- data.frame(X = runif(300), Y = runif(300), a1 = rnorm(300)) mesh <- make_mesh(predictor_dat, xy_cols = c(\"X\", \"Y\"), cutoff = 0.1) dat <- sdmTMB_simulate(   formula = ~ 1 + a1,   data = predictor_dat,   mesh = mesh,   family = poisson(),   range = 0.5,   sigma_O = 0.2,   seed = 42,   B = c(0.2, -0.4) # B0 = intercept, B1 = a1 slope ) fit <- sdmTMB(observed ~ 1 + a1, data = dat, family = poisson(), mesh = mesh)  # simulate from the model: s1 <- simulate(fit, nsim = 300) dim(s1)  # test whether fitted models are consistent with the observed number of zeros: sum(s1 == 0)/length(s1) sum(dat$observed == 0) / length(dat$observed)  # use the residuals with DHARMa: if (require(\"DHARMa\", quietly = TRUE)) {   pred_fixed <- fit$family$linkinv(predict(fit)$est_non_rf)   r <- DHARMa::createDHARMa(     simulatedResponse = s1,     observedResponse = dat$observed,     fittedPredictedResponse = pred_fixed   )   plot(r)   DHARMa::testResiduals(r)   DHARMa::testSpatialAutocorrelation(r, x = dat$X, y = dat$Y)   DHARMa::testZeroInflation(r) }  # simulate with the parameters drawn from the joint precision matrix: s2 <- simulate(fit, nsim = 1, params = \"MVN\")  # simulate with new random fields: s3 <- simulate(fit, nsim = 1, re_form = ~ 0)  # simulate with new random fields and new parameter draws: s3 <- simulate(fit, nsim = 1, params = \"MVN\", re_form = ~ 0)  # simulate from a Stan model fit with new observation error: # \\donttest{ if (require(\"tmbstan\", quietly = TRUE)) {   stan_fit <- tmbstan::tmbstan(fit$tmb_obj, iter = 110, warmup = 100, chains = 1)   # make sure `nsim` is <= number of samples from rstan   s3 <- simulate(fit, nsim = 10, tmbstan_model = stan_fit) } # } } #> This is DHARMa 0.4.6. For overview type '?DHARMa'. For recent changes, type news(package = 'DHARMa')   #> $uniformity #>  #> \tAsymptotic one-sample Kolmogorov-Smirnov test #>  #> data:  simulationOutput$scaledResiduals #> D = 0.025868, p-value = 0.988 #> alternative hypothesis: two-sided #>  #>  #> $dispersion #>  #> \tDHARMa nonparametric dispersion test via sd of residuals fitted vs. #> \tsimulated #>  #> data:  simulationOutput #> dispersion = 1.1336, p-value = 0.2133 #> alternative hypothesis: two.sided #>  #>  #> $outliers #>  #> \tDHARMa outlier test based on exact binomial test with approximate #> \texpectations #>  #> data:  simulationOutput #> outliers at both margin(s) = 1, observations = 300, p-value = 1 #> alternative hypothesis: true probability of success is not equal to 0.006644518 #> 95 percent confidence interval: #>  8.438913e-05 1.843125e-02 #> sample estimates: #> frequency of outliers (expected: 0.00664451827242525 )  #>                                            0.003333333  #>  #>   #>  #> SAMPLING FOR MODEL 'tmb_generic' NOW (CHAIN 1). #> Chain 1:  #> Chain 1: Gradient evaluation took 0.000291 seconds #> Chain 1: 1000 transitions using 10 leapfrog steps per transition would take 2.91 seconds. #> Chain 1: Adjust your expectations accordingly! #> Chain 1:  #> Chain 1:  #> Chain 1: WARNING: There aren't enough warmup iterations to fit the #> Chain 1:          three stages of adaptation as currently configured. #> Chain 1:          Reducing each adaptation stage to 15%/75%/10% of #> Chain 1:          the given number of warmup iterations: #> Chain 1:            init_buffer = 15 #> Chain 1:            adapt_window = 75 #> Chain 1:            term_buffer = 10 #> Chain 1:  #> Chain 1: Iteration:   1 / 110 [  0%]  (Warmup) #> Chain 1: Iteration:  11 / 110 [ 10%]  (Warmup) #> Chain 1: Iteration:  22 / 110 [ 20%]  (Warmup) #> Chain 1: Iteration:  33 / 110 [ 30%]  (Warmup) #> Chain 1: Iteration:  44 / 110 [ 40%]  (Warmup) #> Chain 1: Iteration:  55 / 110 [ 50%]  (Warmup) #> Chain 1: Iteration:  66 / 110 [ 60%]  (Warmup) #> Chain 1: Iteration:  77 / 110 [ 70%]  (Warmup) #> Chain 1: Iteration:  88 / 110 [ 80%]  (Warmup) #> Chain 1: Iteration:  99 / 110 [ 90%]  (Warmup) #> Chain 1: Iteration: 101 / 110 [ 91%]  (Sampling) #> Chain 1: Iteration: 110 / 110 [100%]  (Sampling) #> Chain 1:  #> Chain 1:  Elapsed Time: 1.38382 seconds (Warm-up) #> Chain 1:                0.102842 seconds (Sampling) #> Chain 1:                1.48666 seconds (Total) #> Chain 1:  #> Warning: There were 1 chains where the estimated Bayesian Fraction of Missing Information was low. See #> https://mc-stan.org/misc/warnings.html#bfmi-low #> Warning: Examine the pairs() plot to diagnose sampling problems #> Warning: The largest R-hat is 2.05, indicating chains have not mixed. #> Running the chains for more iterations may help. See #> https://mc-stan.org/misc/warnings.html#r-hat #> Warning: Bulk Effective Samples Size (ESS) is too low, indicating posterior means and medians may be unreliable. #> Running the chains for more iterations may help. See #> https://mc-stan.org/misc/warnings.html#bulk-ess #> Warning: Tail Effective Samples Size (ESS) is too low, indicating posterior variances and tail quantiles may be unreliable. #> Running the chains for more iterations may help. See #> https://mc-stan.org/misc/warnings.html#tail-ess"},{"path":"https://pbs-assess.github.io/sdmTMB/reference/tidy.sdmTMB.html","id":null,"dir":"Reference","previous_headings":"","what":"Turn sdmTMB model output into a tidy data frame — tidy.sdmTMB","title":"Turn sdmTMB model output into a tidy data frame — tidy.sdmTMB","text":"Turn sdmTMB model output tidy data frame","code":""},{"path":"https://pbs-assess.github.io/sdmTMB/reference/tidy.sdmTMB.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Turn sdmTMB model output into a tidy data frame — tidy.sdmTMB","text":"","code":"# S3 method for sdmTMB tidy(   x,   effects = c(\"fixed\", \"ran_pars\", \"ran_vals\"),   model = 1,   conf.int = FALSE,   conf.level = 0.95,   exponentiate = FALSE,   silent = FALSE,   ... )"},{"path":"https://pbs-assess.github.io/sdmTMB/reference/tidy.sdmTMB.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Turn sdmTMB model output into a tidy data frame — tidy.sdmTMB","text":"x Output sdmTMB(). effects character value. One \"fixed\" ('fixed' main-effect parameters), \"ran_pars\" (standard deviations, spatial range, random effect dispersion-related terms), \"ran_vals\" (individual random intercepts, included; behaves like ranef()). model model tidy delta model (1 2). conf.int Include confidence interval? conf.level Confidence level CI. exponentiate Whether exponentiate fixed-effect coefficient estimates confidence intervals. silent Omit messages? ... Extra arguments (used).","code":""},{"path":"https://pbs-assess.github.io/sdmTMB/reference/tidy.sdmTMB.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Turn sdmTMB model output into a tidy data frame — tidy.sdmTMB","text":"data frame","code":""},{"path":"https://pbs-assess.github.io/sdmTMB/reference/tidy.sdmTMB.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Turn sdmTMB model output into a tidy data frame — tidy.sdmTMB","text":"Follows conventions broom broom.mixed packages. Currently, effects = \"ran_pars\" also includes dispersion-related terms (e.g., phi), actually associated random effects. Standard errors spatial variance terms fit log space (e.g., variance terms, range, parameters associated observation error) omitted avoid confusion. Confidence intervals still available.","code":""},{"path":"https://pbs-assess.github.io/sdmTMB/reference/tidy.sdmTMB.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Turn sdmTMB model output into a tidy data frame — tidy.sdmTMB","text":"","code":"fit <- sdmTMB(density ~ poly(depth_scaled, 2, raw = TRUE),   data = pcod_2011, mesh = pcod_mesh_2011,   family = tweedie() ) tidy(fit) #> # A tibble: 3 × 3 #>   term                               estimate std.error #>   <chr>                                 <dbl>     <dbl> #> 1 (Intercept)                            3.65     0.281 #> 2 poly(depth_scaled, 2, raw = TRUE)1    -1.54     0.186 #> 3 poly(depth_scaled, 2, raw = TRUE)2    -1.11     0.101 tidy(fit, conf.int = TRUE) #> # A tibble: 3 × 5 #>   term                               estimate std.error conf.low conf.high #>   <chr>                                 <dbl>     <dbl>    <dbl>     <dbl> #> 1 (Intercept)                            3.65     0.281     3.10     4.20  #> 2 poly(depth_scaled, 2, raw = TRUE)1    -1.54     0.186    -1.90    -1.17  #> 3 poly(depth_scaled, 2, raw = TRUE)2    -1.11     0.101    -1.31    -0.913 tidy(fit, \"ran_pars\", conf.int = TRUE) #> Standard errors intentionally omitted because they have been calculated in log #> space. #> # A tibble: 4 × 5 #>   term      estimate std.error conf.low conf.high #>   <chr>        <dbl> <lgl>        <dbl>     <dbl> #> 1 range        19.1  NA           4.58      80.0  #> 2 phi          14.0  NA          12.8       15.4  #> 3 sigma_O       2.14 NA           0.906      5.07 #> 4 tweedie_p     1.58 NA           1.55       1.61  pcod_2011$fyear <- as.factor(pcod_2011$year) fit <- sdmTMB(density ~ poly(depth_scaled, 2, raw = TRUE) + (1 | fyear),   data = pcod_2011, mesh = pcod_mesh_2011,   family = tweedie() ) tidy(fit, \"ran_vals\") #> # A tibble: 4 × 3 #>   term       estimate std.error #>   <chr>         <dbl>     <dbl> #> 1 fyear_2011   0.0163     0.187 #> 2 fyear_2013   0.177      0.188 #> 3 fyear_2015   0.232      0.189 #> 4 fyear_2017  -0.431      0.205"},{"path":"https://pbs-assess.github.io/sdmTMB/reference/visreg_delta.html","id":null,"dir":"Reference","previous_headings":"","what":"Plot sdmTMB models with the visreg package — visreg_delta","title":"Plot sdmTMB models with the visreg package — visreg_delta","text":"sdmTMB models fit regular (non-delta) families can passed visreg::visreg() visreg::visreg2d() directly. Examples shown . Delta models can use helper functions visreg_delta() visreg2d_delta() described .","code":""},{"path":"https://pbs-assess.github.io/sdmTMB/reference/visreg_delta.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Plot sdmTMB models with the visreg package — visreg_delta","text":"","code":"visreg_delta(object, ..., model = c(1, 2))  visreg2d_delta(object, ..., model = c(1, 2))"},{"path":"https://pbs-assess.github.io/sdmTMB/reference/visreg_delta.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Plot sdmTMB models with the visreg package — visreg_delta","text":"object Fit sdmTMB() ... arguments passed visreg::visreg() visreg::visreg2d() model 1st 2nd delta model","code":""},{"path":"https://pbs-assess.github.io/sdmTMB/reference/visreg_delta.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Plot sdmTMB models with the visreg package — visreg_delta","text":"plot visreg package. Optionally, data plotted invisibly plot = FALSE. useful want make plot .","code":""},{"path":"https://pbs-assess.github.io/sdmTMB/reference/visreg_delta.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Plot sdmTMB models with the visreg package — visreg_delta","text":"Note residuals currently randomized quantile residuals, deviance residuals usual GLMs visreg.","code":""},{"path":"https://pbs-assess.github.io/sdmTMB/reference/visreg_delta.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Plot sdmTMB models with the visreg package — visreg_delta","text":"","code":"if (inla_installed() &&   require(\"ggplot2\", quietly = TRUE) &&   require(\"visreg\", quietly = TRUE)) {    pcod_2011$fyear <- as.factor(pcod_2011$year)   fit <- sdmTMB(     density ~ s(depth_scaled) + fyear,     data = pcod_2011, mesh = pcod_mesh_2011,     spatial = \"off\",     family = tweedie()   )   visreg::visreg(fit, xvar = \"depth_scaled\")   visreg::visreg(fit, xvar = \"fyear\")   visreg::visreg2d(fit, xvar = \"fyear\", yvar = \"depth_scaled\")    # \\donttest{   visreg::visreg(fit, xvar = \"depth_scaled\", scale = \"response\")   v <- visreg::visreg(fit, xvar = \"depth_scaled\")   head(v$fit)   # now use ggplot2 etc. if desired    # Delta model example:   fit_dg <- sdmTMB(     density ~ s(depth_scaled, year, k = 8),     data = pcod_2011, mesh = pcod_mesh_2011,     spatial = \"off\",     family = delta_gamma()   )   visreg_delta(fit_dg, xvar = \"depth_scaled\", model = 1, gg = TRUE)   visreg_delta(fit_dg, xvar = \"depth_scaled\", model = 2, gg = TRUE)   visreg_delta(fit_dg,     xvar = \"depth_scaled\", model = 1,     scale = \"response\", gg = TRUE   )   visreg_delta(fit_dg,     xvar = \"depth_scaled\", model = 2,     scale = \"response\"   )   visreg_delta(fit_dg,     xvar = \"depth_scaled\", model = 2,     scale = \"response\", gg = TRUE, rug = FALSE   )   visreg2d_delta(fit_dg,     xvar = \"depth_scaled\", yvar = \"year\",     model = 2, scale = \"response\"   )   visreg2d_delta(fit_dg,     xvar = \"depth_scaled\", yvar = \"year\",     model = 1, scale = \"response\", plot.type = \"persp\"   )   visreg2d_delta(fit_dg,     xvar = \"depth_scaled\", yvar = \"year\",     model = 2, scale = \"response\", plot.type = \"gg\"   )   # } }"},{"path":"https://pbs-assess.github.io/sdmTMB/news/index.html","id":"sdmtmb-0219000","dir":"Changelog","previous_headings":"","what":"sdmTMB 0.2.1.9000","title":"sdmTMB 0.2.1.9000","text":"Add anisotropy print() #157 Fix predict(…, type = “response”, se_fit = TRUE), involves issuing warning sticking link space. #140 Fixes resubmission CRAN.","code":""},{"path":"https://pbs-assess.github.io/sdmTMB/news/index.html","id":"sdmtmb-020","dir":"Changelog","previous_headings":"","what":"sdmTMB 0.2.0","title":"sdmTMB 0.2.0","text":"Initial submission CRAN.","code":""},{"path":"https://pbs-assess.github.io/sdmTMB/news/index.html","id":"sdmtmb-014","dir":"Changelog","previous_headings":"","what":"sdmTMB 0.1.4","title":"sdmTMB 0.1.4","text":"Relax range parameter sanity() check 1x 1.5x greatest distance data. Add Pearson residuals several families. residuals(fit, type = \"pearson\") Useful checking overdispersion N > 1 binomial Poisson families, among uses. See overdisp_fun() function : https://bbolker.github.io/mixedmodels-misc/glmmFAQ.html#testing--overdispersioncomputing-overdispersion-factor Fix bug using residuals() simulate() binomial families specified via cbind() weights = N. binomial sample size wasn’t passed typically resulting Inf/-Inf. Add mixture families: gamma_mix(), lognormal_mix() associated delta/hurdle families: delta_gamma_mix(), delta_lognormal_mix(). families feature mixture two distributions different means shared variance parameters. Add delta_beta() family.","code":""},{"path":"https://pbs-assess.github.io/sdmTMB/news/index.html","id":"sdmtmb-013","dir":"Changelog","previous_headings":"","what":"sdmTMB 0.1.3","title":"sdmTMB 0.1.3","text":"Tweak sanity() checking standard error size. Export previously experimental plot_anisotropy() function. old function now plot_anisotropy2(). Allow passing offset data predict.sdmTMB() via offset argument.","code":""},{"path":"https://pbs-assess.github.io/sdmTMB/news/index.html","id":"sdmtmb-012","dir":"Changelog","previous_headings":"","what":"sdmTMB 0.1.2","title":"sdmTMB 0.1.2","text":"Switch effects = 'ran_vals' random intercept values tidy.sdmTMB() match broom.mixed package. Make tidy.sdmTMB() return tibble tibble package installed. Note affect old code since drop = FALSE default tibbles drop = TRUE default data frames (.e., tibbles always return data frame subsetted). Fix longstanding issue predicting newdata mgcv’s t2(). Previously disabled issues. now works expected. Add knots argument sdmTMB(), passed mgcv. common use specify end points cyclical spline (e.g., s(x, bs = 'cc', k = 4), knots = list(x = c(1, 3, 5, 7))) data don’t extend fully boundaries match .","code":""},{"path":"https://pbs-assess.github.io/sdmTMB/news/index.html","id":"sdmtmb-011","dir":"Changelog","previous_headings":"","what":"sdmTMB 0.1.1","title":"sdmTMB 0.1.1","text":"Preparing release CRAN. Add time-varying AR1 option (originally always random walk). See time_varying_type argument ?sdmTMB. Allow prediction newdata missing time elements. #130 Add check offset() (work sdmTMB, use offset argument instead). #131 Add check random slopes (sdmTMB currently random intercepts, although slopes can vary spatially). #131","code":""},{"path":"https://pbs-assess.github.io/sdmTMB/news/index.html","id":"sdmtmb-010","dir":"Changelog","previous_headings":"","what":"sdmTMB 0.1.0","title":"sdmTMB 0.1.0","text":"ADREPORT several parameters natural space. https://github.com/pbs-assess/sdmTMB/discussions/113 Improve robustness model print() esoteric mgcv smoothers. Let sims_var work multiple spatially varying slopes (zeta_s); return output named list coefficients. #107 Add threshold_coefs sdmTMB_simulate(). Don’t make fake mesh non-spatial model (faster).","code":""},{"path":"https://pbs-assess.github.io/sdmTMB/news/index.html","id":"sdmtmb-00269001","dir":"Changelog","previous_headings":"","what":"sdmTMB 0.0.26.9001","title":"sdmTMB 0.0.26.9001","text":"Add vignettes visreg, ggeffects, delta families (thanks J. Indivero!) #83 #87 #89 Forecasting presence-vignettes merged soon. Add support emmeans package. See ?emmeans.sdmTMB examples. Add support effects package. ggeffects::ggeffect() function can used make fast marginal effects plots. ggeffects::ggpredict() works custom fork ggeffects. pull request made shortly. #101 Add vcov(), fixef(), df.residual(), formula(), terms(), model.frame() methods. Add support \"cloglog\" link. Code adapted glmmTMB robust likelihood implementation. delta models, default share anisotropy parameters VAST. Separate anisotropy (old behavior) can estimated control = sdmTMBcontrol(map = list(ln_H_input = factor(c(1, 2, 3, 4)))) Add experimental do_index, predict_args, index_args sdmTMB(). can used perform prediction index calculation time fitting. large datasets meshes can save time compared fitting, predicting, index calculation 3 separate steps since TMB AD object doesn’t rebuilt. somewhat slow initial fitting. Remove max_gradient bad_eig get_index() output. Use unique locations prediction huge speedups large newdata gridded data. Fix bug rare cases get_index() return gibberish small values. Add bayesian argument, TRUE adds Jacobian adjustments non-linear transformed parameters. TRUE model passed tmbstan, FALSE otherwise. #95 Add experimental -yet-exported sdmTMB:::plot_anisotropy2(). Add many anisotropy, delta model, index calculation unit tests.","code":""},{"path":"https://pbs-assess.github.io/sdmTMB/news/index.html","id":"sdmtmb-00249001","dir":"Changelog","previous_headings":"","what":"sdmTMB 0.0.24.9001","title":"sdmTMB 0.0.24.9001","text":"Enable random walk random field TMB simulation sdmTMB_simulate(). Add check irregular time AR1 random walk processes. Fix bugs introduced delta model code (offsets extra_time threshold model prediction). Fix bug sanity() message small random field SDs.","code":""},{"path":"https://pbs-assess.github.io/sdmTMB/news/index.html","id":"sdmtmb-00249000","dir":"Changelog","previous_headings":"","what":"sdmTMB 0.0.24.9000","title":"sdmTMB 0.0.24.9000","text":"Add support ‘delta’ (‘hurdle’) models. See examples documentation ?sdmTMB. resulted substantial restructuring internal model code. default model components (e.g., binomial & Gamma) share formula, spatial, spatiotemporal structure, can separated supplying argument values lists first element corresponds first model second element corresponds second model (limitations described ?sdmTMB documentation ‘Details’). Add support multiple spatially varying coefficients (used limited single variable). Add compatibility ‘visreg’ package visualizing conditional effects parameters. See ?visreg_delta examples. Add MCMC residual type residuals.sdmTMB(). ‘better’ residuals slower calculate. See documentation ‘Details’ ?residuals.sdmTMB. Make offset argument sdmTMB(). Using reserved word offset formula now deprecated. Add sanity() function perform basic sanity checks model fits. Make sdmTMB() model object compatible update() method. Remove several deprecated arguments. Overhaul examples ?sdmTMB. Use faster “low-rank sparse hessian bias-correction” TMB bias correction. Add parallel processing support. See parallel argument sdmTMBcontrol. default, grabs value sdmTMB.cores option. E.g. options(sdmTMB.cores = 4). currently enabled Mac/Linux. Using many cores can much slower 1 core. Use ‘cli’ package cli_abort()/cli_warn()/cli_inform() stop()/warning()/message(). Add many unit tests.","code":""},{"path":"https://pbs-assess.github.io/sdmTMB/news/index.html","id":"sdmtmb-00239000","dir":"Changelog","previous_headings":"","what":"sdmTMB 0.0.23.9000","title":"sdmTMB 0.0.23.9000","text":"package version number used internal testing ‘delta’ branch several people.","code":""},{"path":"https://pbs-assess.github.io/sdmTMB/news/index.html","id":"sdmtmb-00229001","dir":"Changelog","previous_headings":"","what":"sdmTMB 0.0.22.9001","title":"sdmTMB 0.0.22.9001","text":"Switch TMBad library ~3-fold speedup(!)","code":""},{"path":"https://pbs-assess.github.io/sdmTMB/news/index.html","id":"sdmtmb-00229000","dir":"Changelog","previous_headings":"","what":"sdmTMB 0.0.22.9000","title":"sdmTMB 0.0.22.9000","text":"Fix bug predictions poly(..., raw = FALSE) newdata. #77","code":""},{"path":"https://pbs-assess.github.io/sdmTMB/news/index.html","id":"sdmtmb-00219009","dir":"Changelog","previous_headings":"","what":"sdmTMB 0.0.21.9009","title":"sdmTMB 0.0.21.9009","text":"Add experimental sdmTMB_stacking() ensemble model stacking weights. Add fake mesh random fields . #59 Make predict(..., newdata = NULL) also use last.par.best instead last.par match newdata = df. Fix bug MVN fixed-effect prior indexing sims n_sims arguments deprecated standardized nsim match simulate() S3 method. Bias correction get_index() get_cog() now selective just applied necessary derived parameters. INLA projection matrix ‘’ now shared across spatial spatiotemporal fields. Add add_utm_columns() ease adding UTM columns.","code":""},{"path":"https://pbs-assess.github.io/sdmTMB/news/index.html","id":"sdmtmb-00209001","dir":"Changelog","previous_headings":"","what":"sdmTMB 0.0.20.9001","title":"sdmTMB 0.0.20.9001","text":"Add dharma_residuals(). Fix bug simulate.sdmTMB() residuals.sdmTMB() binomial family.","code":""},{"path":"https://pbs-assess.github.io/sdmTMB/news/index.html","id":"sdmtmb-00209000","dir":"Changelog","previous_headings":"","what":"sdmTMB 0.0.20.9000","title":"sdmTMB 0.0.20.9000","text":"Smoothers now appear print() output. format roughly match brms. main-effect component (e.g., sdepth s(depth)) represents linear component random effect (e.g., sds(depth)) component output corresponds standard deviation penalized weights. Add censored_poisson(link = 'log') family; implemented @joenomiddlename fields sdmTMB() now deprecated replaced spatiotemporal. include_spatial sdmTMB() now deprecated replaced spatial. spatial_only sdmTMB() now deprecated replaced spatiotemporal. E.g. spatial_only = TRUE now spatiotemporal = '' leaving time = NULL. spde sdmTMB() now deprecated replaced mesh. sdmTMB_simulate() new likely replace sdmTMB_sim() eventually. sdmTMB_simulate() set take formula data frame easier use want different spatial observations (covariates) time slice. can also take fitted model modify parts simulate. Finally, function uses TMB simulation much faster flexible can simulate (e.g., anisotropy) previous version. spatial_trend now spatial_varying accepts one-sided formula single predictor coefficient varying space random field. Note may want include fixed effect variable improve interpretability. (scaled) time column used, represent local-time-trend model . Tweedie power (p) parameter now print() tidy() output. thetaf now tweedie_p sdmTMB_sim().","code":""},{"path":"https://pbs-assess.github.io/sdmTMB/news/index.html","id":"sdmtmb-00199003","dir":"Changelog","previous_headings":"","what":"sdmTMB 0.0.19.9003","title":"sdmTMB 0.0.19.9003","text":"Fix bug affecting prediction se_fit = TRUE breakpoint models.","code":""},{"path":"https://pbs-assess.github.io/sdmTMB/news/index.html","id":"sdmtmb-00199002","dir":"Changelog","previous_headings":"","what":"sdmTMB 0.0.19.9002","title":"sdmTMB 0.0.19.9002","text":"Simulation parameter covariance matrix works random effects turned . #57","code":""},{"path":"https://pbs-assess.github.io/sdmTMB/news/index.html","id":"sdmtmb-00199000","dir":"Changelog","previous_headings":"","what":"sdmTMB 0.0.19.9000","title":"sdmTMB 0.0.19.9000","text":"Smoothers s() now penalized smoothers: determine degree wiggliness (mgcv) longer necessary choose appropriate k value priori. Models fit previous versions sdmTMB s(x, k = ...) match models specified way version >= 0.0.19 since basis functions now penalized. various mgcv::s() options supported t2() (ti() te()) supported.","code":""},{"path":"https://pbs-assess.github.io/sdmTMB/news/index.html","id":"sdmtmb-00189001","dir":"Changelog","previous_headings":"","what":"sdmTMB 0.0.18.9001","title":"sdmTMB 0.0.18.9001","text":"Add ELPD (expected log predictive density) sdmTMB_cv() https://arxiv.org/abs/1507.04544 Fix bug evaluating ... sdmTMB_cv() called within function. #54","code":""},{"path":"https://pbs-assess.github.io/sdmTMB/news/index.html","id":"sdmtmb-00189000","dir":"Changelog","previous_headings":"","what":"sdmTMB 0.0.18.9000","title":"sdmTMB 0.0.18.9000","text":"Fix minor error PC Matern prior","code":""},{"path":"https://pbs-assess.github.io/sdmTMB/news/index.html","id":"sdmtmb-00179000","dir":"Changelog","previous_headings":"","what":"sdmTMB 0.0.17.9000","title":"sdmTMB 0.0.17.9000","text":"Add random walk option: fields = \"RW\". Depreciate ar1_fields argument. See new fields argument `sdmTMB(). Many packages moved ‘Imports’ ‘Suggests’","code":""},{"path":"https://pbs-assess.github.io/sdmTMB/news/index.html","id":"sdmtmb-00169000","dir":"Changelog","previous_headings":"","what":"sdmTMB 0.0.16.9000","title":"sdmTMB 0.0.16.9000","text":"Lower default nlminb() eval.max iter.max 1000 2000. Added profile option sdmTMBcontrol(). can dramatically improve model fitting speed many fixed effects. Note result likely slightly different TRUE vs. FALSE. Added simulation MVN precision matrix predict.sdmTMB(). See sims argument. Added gather_sims() spread_sims() extract parameter simulations joint precision matrix format matches tidybayes package. Added get_index_sims() population index calculated MVN simulation draws. Added extract_mcmc() extract MCMC samples model passed tmbstan. Added ability predict model fitted tmbstan. See tmbstan_model argument predict.sdmTMB(). Allowed separate random field Matern range parameters spatial spatiotemporal fields. E.g. sdmTMB(shared_range = FALSE) Bounded AR1 rho parameter -0.999 0.999 improve convergence; -1 1. Please post issue creates problems model. Added map, start, lower, upper options control model fitting. See sdmTMBcontrol(). Added priors parameters. See ?sdmTMB::priors priors argument sdmTMB(). PC priors available random fields. See ?pc_matern details . Moved many less-common arguments sdmTMB() sdmTMBcontrol(). Fix bug sdmTMB_cv() fitting testing data splits reversed. .e., small chunk fit; big chunk tested.","code":""},{"path":"https://pbs-assess.github.io/sdmTMB/news/index.html","id":"sdmtmb-00159000","dir":"Changelog","previous_headings":"","what":"sdmTMB 0.0.15.9000","title":"sdmTMB 0.0.15.9000","text":"Added experimental penalized complexity (PC) prior used INLA. See arguments matern_prior_O matern_prior_E. Added back normalize argument sdmTMB() default FALSE. Setting TRUE can dramatically speed model fits (~4 times test models).","code":""},{"path":"https://pbs-assess.github.io/sdmTMB/news/index.html","id":"sdmtmb-00149003","dir":"Changelog","previous_headings":"","what":"sdmTMB 0.0.14.9003","title":"sdmTMB 0.0.14.9003","text":"Added vignette making pretty maps output","code":""},{"path":"https://pbs-assess.github.io/sdmTMB/news/index.html","id":"sdmtmb-00149001","dir":"Changelog","previous_headings":"","what":"sdmTMB 0.0.14.9001","title":"sdmTMB 0.0.14.9001","text":"AR1 spatial-model Missing factor levels time Coordinate systems big","code":""},{"path":"https://pbs-assess.github.io/sdmTMB/news/index.html","id":"sdmtmb-00149000","dir":"Changelog","previous_headings":"","what":"sdmTMB 0.0.14.9000","title":"sdmTMB 0.0.14.9000","text":"Add re_form_iid predict.sdmTMB(). Add map_rf option sdmTMB(). lets map (fix starting values zero) random fields produce classic GLM/GLMM.","code":""},{"path":"https://pbs-assess.github.io/sdmTMB/news/index.html","id":"sdmtmb-00139000","dir":"Changelog","previous_headings":"","what":"sdmTMB 0.0.13.9000","title":"sdmTMB 0.0.13.9000","text":"Add IID random intercepts interface. E.g. ... + (1 | g) #34","code":""},{"path":"https://pbs-assess.github.io/sdmTMB/news/index.html","id":"sdmtmb-00129000","dir":"Changelog","previous_headings":"","what":"sdmTMB 0.0.12.9000","title":"sdmTMB 0.0.12.9000","text":"Add epsilon_predictor argument sdmTMB() allow model spatiotemporal variance time.","code":""},{"path":"https://pbs-assess.github.io/sdmTMB/news/index.html","id":"sdmtmb-00119000","dir":"Changelog","previous_headings":"","what":"sdmTMB 0.0.11.9000","title":"sdmTMB 0.0.11.9000","text":"Add penalties argument allow regularization.","code":""},{"path":"https://pbs-assess.github.io/sdmTMB/news/index.html","id":"sdmtmb-00109001","dir":"Changelog","previous_headings":"","what":"sdmTMB 0.0.10.9001","title":"sdmTMB 0.0.10.9001","text":"Fix Student-t degrees freedom randomized quantile residuals","code":""},{"path":"https://pbs-assess.github.io/sdmTMB/news/index.html","id":"sdmtmb-00109000","dir":"Changelog","previous_headings":"","what":"sdmTMB 0.0.10.9000","title":"sdmTMB 0.0.10.9000","text":"Fixed parameter initialization inverse links #35 Switched Gamma ‘phi’ parameter representing shape instead CV match glm(), glmmTMB(), etc.","code":""},{"path":"https://pbs-assess.github.io/sdmTMB/news/index.html","id":"sdmtmb-0099000","dir":"Changelog","previous_headings":"","what":"sdmTMB 0.0.9.9000","title":"sdmTMB 0.0.9.9000","text":"Switched density/abundance index calculation use link function opposed hardcoded log() get_generic() function can used grab things like standardized average values response across grid. used log_total raw TMB output now link_total users shouldn’t notice difference.","code":""},{"path":"https://pbs-assess.github.io/sdmTMB/news/index.html","id":"sdmtmb-0089000","dir":"Changelog","previous_headings":"","what":"sdmTMB 0.0.8.9000","title":"sdmTMB 0.0.8.9000","text":"Overhauled simulation function. function now called sdmTMB_sim() uses INLA functions instead RandomFields functions simulating random fields. simulation function can now accommodate families links takes INLA mesh input.","code":""},{"path":"https://pbs-assess.github.io/sdmTMB/news/index.html","id":"sdmtmb-0079001","dir":"Changelog","previous_headings":"","what":"sdmTMB 0.0.7.9001","title":"sdmTMB 0.0.7.9001","text":"Allow specifying degrees freedom Student-t family #29","code":""},{"path":"https://pbs-assess.github.io/sdmTMB/news/index.html","id":"sdmtmb-0079000","dir":"Changelog","previous_headings":"","what":"sdmTMB 0.0.7.9000","title":"sdmTMB 0.0.7.9000","text":"Added tidy() method (broom broom.mixed) return data frame parameter estimates. function can extract fixed effects random effect parameters (variances, AR1 correlation, spatial range). Added argument extra_time sdmTMB(). introduces additional time slices can predict want interpolate forecast. Internally, uses Eric Ward’s ‘weights hack’. also useful data unevenly spaced time want gaps evenly spaced random walk AR1 process (add missing years extra_time). make_spde() now replaced make_mesh() make_spde() soft deprecated. make_mesh() carries x y column names predict function line tidyverse style taking data frame first. make_mesh() can accept cutoff argument (INLA), likely better default way specify mesh since scales across regions better line literature INLA. make_mesh() can use binary search algorithm find cutoff best matches desired number knots (thanks Kelli Johnson idea). Barrier meshes now possible. See add_barrier_mesh() example. pkgdown website now gets auto generated GitHub actions. start model description vignette. much work progress.","code":""},{"path":"https://pbs-assess.github.io/sdmTMB/news/index.html","id":"sdmtmb-0069009","dir":"Changelog","previous_headings":"","what":"sdmTMB 0.0.6.9009","title":"sdmTMB 0.0.6.9009","text":"Fixed bug dlnorm","code":""},{"path":"https://pbs-assess.github.io/sdmTMB/news/index.html","id":"sdmtmb-0069005","dir":"Changelog","previous_headings":"","what":"sdmTMB 0.0.6.9005","title":"sdmTMB 0.0.6.9005","text":"Fixed bug predictions standard errors one(?) parameter (breakpoint parameter) passed initial instead MLE value.","code":""},{"path":"https://pbs-assess.github.io/sdmTMB/news/index.html","id":"sdmtmb-0069004","dir":"Changelog","previous_headings":"","what":"sdmTMB 0.0.6.9004","title":"sdmTMB 0.0.6.9004","text":"Fixed bug predictions new data models break points Overhauled cross validation function. function now: uses Eric’s weights hack can also used forecasting initializes subsequent folds MLE first fold considerable speed increases works parallel future plan initialized; see examples Added threshold parameters print method Added forecasting example weights hack Fixed bug linear break point models","code":""},{"path":"https://pbs-assess.github.io/sdmTMB/news/index.html","id":"sdmtmb-0069002","dir":"Changelog","previous_headings":"","what":"sdmTMB 0.0.6.9002","title":"sdmTMB 0.0.6.9002","text":"Fixed GAM predictions 0s new data. Add linear logistic threshold models. #17","code":""},{"path":"https://pbs-assess.github.io/sdmTMB/news/index.html","id":"sdmtmb-0059000","dir":"Changelog","previous_headings":"","what":"sdmTMB 0.0.5.9000","title":"sdmTMB 0.0.5.9000","text":"Added parsing mgcv formulas splines. #16 Added ability predict standard errors population level. helps making marginal-effect plots. #15 Added optimization options aid convergence. Also added run_extra_optimization() run already fit models. Default extra optimization. Added binomial likelihood cross validation. Git hash ee3f3ba. Started keeping track news NEWS.md.","code":""}]
