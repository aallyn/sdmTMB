---
title: "Threshold modeling with sdmTMB"
date: "`r Sys.Date()`"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Threshold modeling with sdmTMB}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

**If the code in this vignette has not been evaluated, a rendered version is available on the [documentation site](https://pbs-assess.github.io/sdmTMB/index.html) under 'Articles'.**

```{r setup, include = FALSE, cache=FALSE}
dplyr_installed <- require("dplyr", quietly = TRUE)
ggplot_installed <- require("ggplot2", quietly = TRUE)
inla_installed <- requireNamespace("INLA", quietly = TRUE)
pkgs <- dplyr_installed && ggplot_installed && inla_installed
EVAL <- identical(Sys.getenv("NOT_CRAN"), "true") && pkgs
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  fig.width = 7,
  fig.asp = 0.618,
  eval = EVAL,
  purl = EVAL
)
```

```{r packages, message=FALSE, warning=TRUE}
library(ggplot2)
library(dplyr)
library(sdmTMB)
```

We'll repeat the same models used for the index standardization vignette, using the built-in data for Pacific cod. 

As a summary, 
- We've included columns for depth and depth squared. 
- Depth was centred and scaled by its standard deviation and we've included those in the data frame so that they could be used to similarly scale the prediction grid.
- The density units should be kg/km^2^.
- Here, X and Y are coordinates in UTM zone 9.

```{r glimpse-pcod}
glimpse(pcod)
```

As before, the SPDE mesh is created using 75 knots for a balance between speed and accuracy. You will likely want to use more for applied scenarios. You will want to make sure that increasing the number of knots does not change the conclusions.

```{r spde, fig.asp=0.8}
pcod_spde <- make_mesh(pcod, c("X", "Y"), cutoff = 12)
```

We will extend the simple GLMM used in the index standardization vignette to include a threshold effect. For real applications, the threshold effect might be a function of habitat covariates, environmental variables, etc. Because 'depth' is the only external variable in the `pcod` data frame, we'll use that. For any threshold model, you can specify the model as a linear threshold (`breakpt()`) or logistic (`logistic()`) as part of the formula. Note: as before, if we want to use this model for index standardization then we need to include `0 + as.factor(year)` or `-1 + as.factor(year)` so that we have a factor predictor that represents the mean estimate for each time slice.

This first example uses the 'depth_scaled' covariate (depth, standardized ~ N(0,1)) and the logistic function, similar to selectivity curves used in fisheries models. The form is 

$$s(x)=\tau + \psi *\quad { \left[ 1+{ \exp }^{ -ln\left( 19 \right) \quad *\quad \left( x-s50 \right) \quad /\quad \left( s95\quad -\quad s50 \right)  } \right]  }^{ -1 }$$
where $\psi$ is a scaling parameter (controlling the height of the y-axis for the response, and is unconstrained), $\tau$ is an intercept, $s50$ is a parameter controlling the point at which the function reaches 50% of the maximum ($\psi$), and $s95$ is a parameter controlling the point at which the function reaches 95%. The parameter $s50$ is unconstrained, and $s95$ is constrained to be larger than $s50$.

```{r fitlogistic}
m <- sdmTMB(
  data = pcod,
  formula = density ~ 0 + logistic(depth_scaled) + as.factor(year),
  time = "year", mesh = pcod_spde,
  family = tweedie(link = "log")
)
```

We can then look at the important coefficients from the model. Here we're looking at 's50', 's95', and 'smax'.

```{r outputlogistic}
print(m)
```

We can visualize the effect:

```{r logistic-eff}
nd <- data.frame(
  depth_scaled = seq(min(pcod$depth_scaled) + 0.5, 
    max(pcod$depth_scaled) - 0.2, length.out = 100), 
  year = 2015L # a chosen year
)
p <- predict(m, newdata = nd, se_fit = TRUE, re_form = NA)
ggplot(p, aes(depth_scaled, exp(est), 
  ymin = exp(est - 1.96 * est_se), 
  ymax = exp(est + 1.96 * est_se))) +
  geom_line() + geom_ribbon(alpha = 0.4)
```

Next, we can try to fit the same model but use a linear breakpoint / cutpoint model:

```{r fitlinear}
m <- sdmTMB(
  data = pcod,
  formula = density ~ 0 + breakpt(depth_scaled) + as.factor(year),
  time = "year", mesh = pcod_spde,
  family = tweedie(link = "log")
)
```

For this model, the important parameters are the slope, 'depth_scaled-slope', and breakpoint, 'depth_scaled-breakpt'.

```{r outputlinear}
print(m)
```

We can visualize the linear breakpoint effect:

```{r brkpt-eff, warning=FALSE}
p <- predict(m, newdata = nd, se_fit = TRUE, re_form = NA, xy_cols = c("X", "Y"))
ggplot(p, aes(depth_scaled, exp(est), 
  ymin = exp(est - 1.96 * est_se), 
  ymax = exp(est + 1.96 * est_se))) +
  geom_line() + geom_ribbon(alpha = 0.4)
```

##Special Case: Logistic Threshold on Metabolic Index

There additionally is an option for a unique parameterization of the logistic threshold, where the parameter delta indicates the difference between s95 and s50 (see above). In this form, the scaling parameter can be interpreted as the extent of decline in the response with x, rather than the rate of increase. Additionally, it is set up so that as x approaches infinity, x contributes nothing to the predicted response.

$$
s(x)=\tau + \psi\ { \left[ 1+{ e }^{ -\ln \left(19\right) \cdot \left( x-s50 \right)
     / \left(delta) } \right] -1}^{-1},
$$
This version of the logistic function was created for use with a temperature-influenced oxygen metric based on the Metabolic Index [(see Deutsch et al. 2015)](https://pubmed.ncbi.nlm.nih.gov/26045435/), and we will use this as an example.

The Metabolic Index in this case is based on environmental temperature and oxygen data, and a parameter Eo that represents the impact of temperature on oxygen tolerance. 

We first simulate ocean temperature and oxygen data, and then calculate the inverse temperature.
```{r}
#Generate random temperature and oxygen data
N <- 3000
set.seed(123)
temp <- rnorm(N)
po2 <- rlnorm(N)

kelvin = 273.15 #For converting celsius to Kelvin
boltz = 0.000086173324 #Boltzmann's constant
tref <- 12 #Reference temperature

#Calcualte inverse temperature
env$invtemp <- (1 / boltz)  * ( 1 / (temp + 273.15) - 1 / (tref + 273.15))
```

Then, we specify our Eo value, and calculate the metabolic index (i.e. mi)
```{r}
Eo <-  0.3
mi <- po2 * exp(Eo * invtemp)
```

We will then simulate fish density data (log_mu) by specifying a slope value (beta1), a parameter for the effect of the metabolic index (beta3), and the parameters for the logistic function (delta and x50), and using a normal distribution to generate observations.
```{r}
beta1 <- -0.4
beta3 <- 0.3
delta <- 3
x50 <- 5

log_mu <- beta1 + beta3 * (1 / (1 + exp(-log(19) * (mi - x50) / delta)) - 1)
mu <- exp(log_mu)

obs <- rlnorm(N, log_mu - 0.5 * sigma^2, sigma)
```

We can use sdmTMB to fit a model of fish density that jointly estimates the logistic threshold on metabolic index and the temperature-impacted oxygen parameter Eo. To do so, sdmTMB requires data columns "pO2" and "invtemp". We can then specify starting parameters to help improve estimation, and can fit the model using "logistic(mi) in the function. 
```{r}
  dat <- data.frame(y = obs, po2 = po2, invtemp = invtemp)

  start <- matrix(0, ncol = 1, nrow = 4)
  start[1,1] <- x50
  start[2,1] <- delta
  start[3,1] <- beta3
  start[4,1] <- Eo

  m2 <- sdmTMB(y ~ logistic(mi), 
               data = dat, 
               spatial = "off",
              family = lognormal(),
              control = sdmTMBcontrol(start = list(b_threshold = start))) #Specify starting parameters
              tidy(m2)
  print(m2)
```

